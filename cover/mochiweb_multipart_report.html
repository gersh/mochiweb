<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
          <head>
            <title>mochiweb_multipart - C0 code coverage information</title>
            <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
            <style type='text/css'>span.marked0 {
     background-color: rgb(185, 210, 200);
     display: block;
    }
    span.marked { display: block; background-color: #ffffff; }
    span.highlight { display: block; background-color: #fff9d7; }
    span.covered { display: block; background-color: #f7f7f7 ; }
    span.uncovered { display: block; background-color: #ffebe8 ; }
    span.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    div.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    body {
     font-family: verdana, arial, helvetica;
    }
    div.footer {
     font-size: 68%;
     margin-top: 1.5em;
    }
    h1, h2, h3, h4, h5, h6 {
     margin-bottom: 0.5em;
    }
    h5 {
     margin-top: 0.5em;
    }
    .hidden {
     display: none;
    }
    div.separator {
     height: 10px;
    }
    table.percent_graph {
     height: 12px;
     border: 1px solid #E2E6EF; 
     empty-cells: show;
    }
    table.percent_graph td.covered {
     height: 10px;
     background: #00f000;
    }
    table.percent_graph td.uncovered {
     height: 10px;
     background: #e00000;
    }
    table.percent_graph td.NA {
     height: 10px;
     background: #eaeaea;
    }
    table.report {
     border-collapse: collapse;
     width: 100%;
    }
    table.report td.heading {
     background: #dcecff;
     border: 1px solid #E2E6EF; 
     font-weight: bold;
     text-align: center;
    }
    table.report td.heading:hover {
     background: #c0ffc0;
    }
    table.report td.text {
     border: 1px solid #E2E6EF; 
    }
    table.report td.value {
     text-align: right;
     border: 1px solid #E2E6EF; 
    }
    table.report tr.light {
     background-color: rgb(240, 240, 245);
    }
    table.report tr.dark {
     background-color: rgb(230, 230, 235);
    }
    </style>
          </head>
          <body>
            <h3>C0 code coverage information</h3>
            <p>Generated on 2009-02-25 01:24:47 with <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.
            </p>            
        <table class='report'>
          <thead>
            <tr>
              <td class='heading'>Name</td>
              <td class='heading'>Total lines</td>
              <td class='heading'>Lines of code</td>
              <td class='heading'>Total coverage</td>
              <td class='heading'>Code coverage</td>
            </tr>
          </thead>
          <tbody>
            <tr class='light'>

              <td>
                <a href='mochiweb_multipart_report.html'>mochiweb_multipart</a>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td>
                <table cellspacing='0' cellpadding='0' align='right'>
                  <tr>
                    <td><tt>55%</tt>&nbsp;</td><td>
                      <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                      <tr><td class='covered' width='55' /><td class='uncovered' width='45' /></tr>
                      </table>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </tbody>
        </table><pre><span class="marked"><a name="line1"></a>....1 %% @author Bob Ippolito <bob@mochimedia.com>
</span><span class="marked"><a name="line2"></a>....2 %% @copyright 2007 Mochi Media, Inc.
</span><span class="marked"><a name="line3"></a>....3 
</span><span class="marked"><a name="line4"></a>....4 %% @doc Utilities for parsing multipart/form-data.
</span><span class="marked"><a name="line5"></a>....5 
</span><span class="marked"><a name="line6"></a>....6 -module(mochiweb_multipart).
</span><span class="marked"><a name="line7"></a>....7 -author('bob@mochimedia.com').
</span><span class="marked"><a name="line8"></a>....8 
</span><span class="marked"><a name="line9"></a>....9 -export([parse_form/1, parse_form/2]).
</span><span class="marked"><a name="line10"></a>...10 -export([parse_multipart_request/2, find_in_binary/2, find_boundary/2, get_boundary/1]).
</span><span class="marked"><a name="line11"></a>...11 
</span><span class="marked"><a name="line12"></a>...12 -define(CHUNKSIZE, 4096).
</span><span class="marked"><a name="line13"></a>...13 
</span><span class="marked"><a name="line14"></a>...14 -record(mp, {state, boundary, length, buffer, callback, req}).
</span><span class="marked"><a name="line15"></a>...15 
</span><span class="marked"><a name="line16"></a>...16 %% TODO: DOCUMENT THIS MODULE.
</span><span class="marked"><a name="line17"></a>...17 
</span><span class="marked"><a name="line18"></a>...18 parse_form(Req) ->
</span><span class="uncovered"><a name="line19"></a>...19     parse_form(Req, fun default_file_handler/2).
</span><span class="marked"><a name="line20"></a>...20 
</span><span class="marked"><a name="line21"></a>...21 parse_form(Req, FileHandler) ->
</span><span class="uncovered"><a name="line22"></a>...22     Callback = fun (Next) -> parse_form_outer(Next, FileHandler, []) end,
</span><span class="uncovered"><a name="line23"></a>...23     {_, _, Res} = parse_multipart_request(Req, Callback),
</span><span class="uncovered"><a name="line24"></a>...24     Res.
</span><span class="marked"><a name="line25"></a>...25 
</span><span class="marked"><a name="line26"></a>...26 parse_form_outer(eof, _, Acc) ->
</span><span class="uncovered"><a name="line27"></a>...27     lists:reverse(Acc);
</span><span class="marked"><a name="line28"></a>...28 parse_form_outer({headers, H}, FileHandler, State) ->
</span><span class="uncovered"><a name="line29"></a>...29     {"form-data", H1} = proplists:get_value("content-disposition", H),
</span><span class="uncovered"><a name="line30"></a>...30     Name = proplists:get_value("name", H1),
</span><span class="uncovered"><a name="line31"></a>...31     Filename = proplists:get_value("filename", H1),
</span><span class="uncovered"><a name="line32"></a>...32     case Filename of
</span><span class="marked"><a name="line33"></a>...33         undefined ->
</span><span class="uncovered"><a name="line34"></a>...34             fun (Next) ->
</span><span class="uncovered"><a name="line35"></a>...35                     parse_form_value(Next, {Name, []}, FileHandler, State)
</span><span class="marked"><a name="line36"></a>...36             end;
</span><span class="marked"><a name="line37"></a>...37         _ ->
</span><span class="uncovered"><a name="line38"></a>...38             ContentType = proplists:get_value("content-type", H),
</span><span class="uncovered"><a name="line39"></a>...39             Handler = FileHandler(Filename, ContentType),
</span><span class="uncovered"><a name="line40"></a>...40             fun (Next) ->
</span><span class="uncovered"><a name="line41"></a>...41                     parse_form_file(Next, {Name, Handler}, FileHandler, State)
</span><span class="marked"><a name="line42"></a>...42             end
</span><span class="marked"><a name="line43"></a>...43     end.
</span><span class="marked"><a name="line44"></a>...44 
</span><span class="marked"><a name="line45"></a>...45 parse_form_value(body_end, {Name, Acc}, FileHandler, State) ->
</span><span class="uncovered"><a name="line46"></a>...46     Value = binary_to_list(iolist_to_binary(lists:reverse(Acc))),
</span><span class="uncovered"><a name="line47"></a>...47     State1 = [{Name, Value} | State],
</span><span class="uncovered"><a name="line48"></a>...48     fun (Next) -> parse_form_outer(Next, FileHandler, State1) end;
</span><span class="marked"><a name="line49"></a>...49 parse_form_value({body, Data}, {Name, Acc}, FileHandler, State) ->
</span><span class="uncovered"><a name="line50"></a>...50     Acc1 = [Data | Acc],
</span><span class="uncovered"><a name="line51"></a>...51     fun (Next) -> parse_form_value(Next, {Name, Acc1}, FileHandler, State) end.
</span><span class="marked"><a name="line52"></a>...52 
</span><span class="marked"><a name="line53"></a>...53 parse_form_file(body_end, {Name, Handler}, FileHandler, State) ->
</span><span class="uncovered"><a name="line54"></a>...54     Value = Handler(eof),
</span><span class="uncovered"><a name="line55"></a>...55     State1 = [{Name, Value} | State],
</span><span class="uncovered"><a name="line56"></a>...56     fun (Next) -> parse_form_outer(Next, FileHandler, State1) end;
</span><span class="marked"><a name="line57"></a>...57 parse_form_file({body, Data}, {Name, Handler}, FileHandler, State) ->
</span><span class="uncovered"><a name="line58"></a>...58     H1 = Handler(Data),
</span><span class="uncovered"><a name="line59"></a>...59     fun (Next) -> parse_form_file(Next, {Name, H1}, FileHandler, State) end.
</span><span class="marked"><a name="line60"></a>...60 
</span><span class="marked"><a name="line61"></a>...61 default_file_handler(Filename, ContentType) ->
</span><span class="uncovered"><a name="line62"></a>...62     default_file_handler_1(Filename, ContentType, []).
</span><span class="marked"><a name="line63"></a>...63 
</span><span class="marked"><a name="line64"></a>...64 default_file_handler_1(Filename, ContentType, Acc) ->
</span><span class="uncovered"><a name="line65"></a>...65     fun(eof) ->
</span><span class="uncovered"><a name="line66"></a>...66             Value = iolist_to_binary(lists:reverse(Acc)),
</span><span class="uncovered"><a name="line67"></a>...67             {Filename, ContentType, Value};
</span><span class="marked"><a name="line68"></a>...68        (Next) ->
</span><span class="uncovered"><a name="line69"></a>...69             default_file_handler_1(Filename, ContentType, [Next | Acc])
</span><span class="marked"><a name="line70"></a>...70     end.
</span><span class="marked"><a name="line71"></a>...71 
</span><span class="marked"><a name="line72"></a>...72 parse_multipart_request(Req, Callback) ->
</span><span class="marked"><a name="line73"></a>...73     %% TODO: Support chunked?
</span><span class="covered"><a name="line74"></a>...74     Length = list_to_integer(Req:get_header_value("content-length")),
</span><span class="covered"><a name="line75"></a>...75     Boundary = iolist_to_binary(
</span><span class="marked"><a name="line76"></a>...76                  get_boundary(Req:get_header_value("content-type"))),
</span><span class="covered"><a name="line77"></a>...77     Prefix = <<"\r\n--", Boundary/binary>>,
</span><span class="covered"><a name="line78"></a>...78     BS = size(Boundary),
</span><span class="covered"><a name="line79"></a>...79     Chunk = read_chunk(Req, Length),
</span><span class="covered"><a name="line80"></a>...80     Length1 = Length - size(Chunk),
</span><span class="covered"><a name="line81"></a>...81     <<"--", Boundary:BS/binary, "\r\n", Rest/binary>> = Chunk,
</span><span class="covered"><a name="line82"></a>...82     feed_mp(headers, #mp{boundary=Prefix,
</span><span class="marked"><a name="line83"></a>...83                          length=Length1,
</span><span class="marked"><a name="line84"></a>...84                          buffer=Rest,
</span><span class="marked"><a name="line85"></a>...85                          callback=Callback,
</span><span class="marked"><a name="line86"></a>...86                          req=Req}).
</span><span class="marked"><a name="line87"></a>...87 
</span><span class="marked"><a name="line88"></a>...88 parse_headers(<<>>) ->
</span><span class="uncovered"><a name="line89"></a>...89     [];
</span><span class="marked"><a name="line90"></a>...90 parse_headers(Binary) ->
</span><span class="covered"><a name="line91"></a>...91     parse_headers(Binary, []).
</span><span class="marked"><a name="line92"></a>...92 
</span><span class="marked"><a name="line93"></a>...93 parse_headers(Binary, Acc) ->
</span><span class="covered"><a name="line94"></a>...94     case find_in_binary(<<"\r\n">>, Binary) of
</span><span class="marked"><a name="line95"></a>...95         {exact, N} ->
</span><span class="covered"><a name="line96"></a>...96             <<Line:N/binary, "\r\n", Rest/binary>> = Binary,
</span><span class="covered"><a name="line97"></a>...97             parse_headers(Rest, [split_header(Line) | Acc]);
</span><span class="marked"><a name="line98"></a>...98         not_found ->
</span><span class="covered"><a name="line99"></a>...99             lists:reverse([split_header(Binary) | Acc])
</span><span class="marked"><a name="line100"></a>..100     end.
</span><span class="marked"><a name="line101"></a>..101 
</span><span class="marked"><a name="line102"></a>..102 split_header(Line) ->
</span><span class="covered"><a name="line103"></a>..103     {Name, [$: | Value]} = lists:splitwith(fun (C) -> C =/= $: end,
</span><span class="marked"><a name="line104"></a>..104                                            binary_to_list(Line)),
</span><span class="covered"><a name="line105"></a>..105     {string:to_lower(string:strip(Name)),
</span><span class="marked"><a name="line106"></a>..106      mochiweb_util:parse_header(Value)}.
</span><span class="marked"><a name="line107"></a>..107 
</span><span class="marked"><a name="line108"></a>..108 read_chunk(Req, Length) when Length > 0 ->
</span><span class="covered"><a name="line109"></a>..109     case Length of
</span><span class="marked"><a name="line110"></a>..110         Length when Length < ?CHUNKSIZE ->
</span><span class="covered"><a name="line111"></a>..111             Req:recv(Length);
</span><span class="marked"><a name="line112"></a>..112         _ ->
</span><span class="uncovered"><a name="line113"></a>..113             Req:recv(?CHUNKSIZE)
</span><span class="marked"><a name="line114"></a>..114     end.
</span><span class="marked"><a name="line115"></a>..115 
</span><span class="marked"><a name="line116"></a>..116 read_more(State=#mp{length=Length, buffer=Buffer, req=Req}) ->
</span><span class="uncovered"><a name="line117"></a>..117     Data = read_chunk(Req, Length),
</span><span class="uncovered"><a name="line118"></a>..118     Buffer1 = <<Buffer/binary, Data/binary>>,
</span><span class="uncovered"><a name="line119"></a>..119     State#mp{length=Length - size(Data),
</span><span class="marked"><a name="line120"></a>..120              buffer=Buffer1}.
</span><span class="marked"><a name="line121"></a>..121 
</span><span class="marked"><a name="line122"></a>..122 feed_mp(headers, State=#mp{buffer=Buffer, callback=Callback}) ->
</span><span class="covered"><a name="line123"></a>..123     {State1, P} = case find_in_binary(<<"\r\n\r\n">>, Buffer) of
</span><span class="marked"><a name="line124"></a>..124                       {exact, N} ->
</span><span class="covered"><a name="line125"></a>..125                           {State, N};
</span><span class="marked"><a name="line126"></a>..126                       _ ->
</span><span class="uncovered"><a name="line127"></a>..127                           S1 = read_more(State),
</span><span class="marked"><a name="line128"></a>..128                           %% Assume headers must be less than ?CHUNKSIZE
</span><span class="uncovered"><a name="line129"></a>..129                           {exact, N} = find_in_binary(<<"\r\n\r\n">>,
</span><span class="marked"><a name="line130"></a>..130                                                       S1#mp.buffer),
</span><span class="uncovered"><a name="line131"></a>..131                           {S1, N}
</span><span class="marked"><a name="line132"></a>..132                   end,
</span><span class="covered"><a name="line133"></a>..133     <<Headers:P/binary, "\r\n\r\n", Rest/binary>> = State1#mp.buffer,
</span><span class="covered"><a name="line134"></a>..134     NextCallback = Callback({headers, parse_headers(Headers)}),
</span><span class="covered"><a name="line135"></a>..135     feed_mp(body, State1#mp{buffer=Rest,
</span><span class="marked"><a name="line136"></a>..136                             callback=NextCallback});
</span><span class="marked"><a name="line137"></a>..137 feed_mp(body, State=#mp{boundary=Prefix, buffer=Buffer, callback=Callback}) ->
</span><span class="covered"><a name="line138"></a>..138     case find_boundary(Prefix, Buffer) of
</span><span class="marked"><a name="line139"></a>..139         {end_boundary, Start, Skip} ->
</span><span class="covered"><a name="line140"></a>..140             <<Data:Start/binary, _:Skip/binary, Rest/binary>> = Buffer,
</span><span class="covered"><a name="line141"></a>..141             C1 = Callback({body, Data}),
</span><span class="covered"><a name="line142"></a>..142             C2 = C1(body_end),
</span><span class="covered"><a name="line143"></a>..143             {State#mp.length, Rest, C2(eof)};
</span><span class="marked"><a name="line144"></a>..144         {next_boundary, Start, Skip} ->
</span><span class="covered"><a name="line145"></a>..145             <<Data:Start/binary, _:Skip/binary, Rest/binary>> = Buffer,
</span><span class="covered"><a name="line146"></a>..146             C1 = Callback({body, Data}),
</span><span class="covered"><a name="line147"></a>..147             feed_mp(headers, State#mp{callback=C1(body_end),
</span><span class="marked"><a name="line148"></a>..148                                       buffer=Rest});
</span><span class="marked"><a name="line149"></a>..149         {maybe, Start} ->
</span><span class="uncovered"><a name="line150"></a>..150             <<Data:Start/binary, Rest/binary>> = Buffer,
</span><span class="uncovered"><a name="line151"></a>..151             feed_mp(body, read_more(State#mp{callback=Callback({body, Data}),
</span><span class="marked"><a name="line152"></a>..152                                              buffer=Rest}));
</span><span class="marked"><a name="line153"></a>..153         not_found ->
</span><span class="uncovered"><a name="line154"></a>..154             {Data, Rest} = {Buffer, <<>>},
</span><span class="uncovered"><a name="line155"></a>..155             feed_mp(body, read_more(State#mp{callback=Callback({body, Data}),
</span><span class="marked"><a name="line156"></a>..156                                              buffer=Rest}))
</span><span class="marked"><a name="line157"></a>..157     end.
</span><span class="marked"><a name="line158"></a>..158 
</span><span class="marked"><a name="line159"></a>..159 get_boundary(ContentType) ->
</span><span class="covered"><a name="line160"></a>..160     {"multipart/form-data", Opts} = mochiweb_util:parse_header(ContentType),
</span><span class="covered"><a name="line161"></a>..161     case proplists:get_value("boundary", Opts) of
</span><span class="marked"><a name="line162"></a>..162         S when is_list(S) ->
</span><span class="covered"><a name="line163"></a>..163             S
</span><span class="marked"><a name="line164"></a>..164     end.
</span><span class="marked"><a name="line165"></a>..165 
</span><span class="marked"><a name="line166"></a>..166 find_in_binary(B, Data) when size(B) > 0 ->
</span><span class="covered"><a name="line167"></a>..167     case size(Data) - size(B) of
</span><span class="marked"><a name="line168"></a>..168         Last when Last < 0 ->
</span><span class="covered"><a name="line169"></a>..169             partial_find(B, Data, 0, size(Data));
</span><span class="marked"><a name="line170"></a>..170         Last ->
</span><span class="covered"><a name="line171"></a>..171             find_in_binary(B, size(B), Data, 0, Last)
</span><span class="marked"><a name="line172"></a>..172     end.
</span><span class="marked"><a name="line173"></a>..173 
</span><span class="marked"><a name="line174"></a>..174 find_in_binary(B, BS, D, N, Last) when N =< Last->
</span><span class="covered"><a name="line175"></a>..175     case D of
</span><span class="marked"><a name="line176"></a>..176         <<_:N/binary, B:BS/binary, _/binary>> ->
</span><span class="covered"><a name="line177"></a>..177             {exact, N};
</span><span class="marked"><a name="line178"></a>..178         _ ->
</span><span class="covered"><a name="line179"></a>..179             find_in_binary(B, BS, D, 1 + N, Last)
</span><span class="marked"><a name="line180"></a>..180     end;
</span><span class="marked"><a name="line181"></a>..181 find_in_binary(B, BS, D, N, Last) when N =:= 1 + Last ->
</span><span class="covered"><a name="line182"></a>..182     partial_find(B, D, N, BS - 1).
</span><span class="marked"><a name="line183"></a>..183 
</span><span class="marked"><a name="line184"></a>..184 partial_find(_B, _D, _N, 0) ->
</span><span class="covered"><a name="line185"></a>..185     not_found;
</span><span class="marked"><a name="line186"></a>..186 partial_find(B, D, N, K) ->
</span><span class="covered"><a name="line187"></a>..187     <<B1:K/binary, _/binary>> = B,
</span><span class="covered"><a name="line188"></a>..188     case D of
</span><span class="marked"><a name="line189"></a>..189         <<_Skip:N/binary, B1:K/binary>> ->
</span><span class="covered"><a name="line190"></a>..190             {partial, N, K};
</span><span class="marked"><a name="line191"></a>..191         _ ->
</span><span class="covered"><a name="line192"></a>..192             partial_find(B, D, 1 + N, K - 1)
</span><span class="marked"><a name="line193"></a>..193     end.
</span><span class="marked"><a name="line194"></a>..194 
</span><span class="marked"><a name="line195"></a>..195 find_boundary(Prefix, Data) ->
</span><span class="covered"><a name="line196"></a>..196     case find_in_binary(Prefix, Data) of
</span><span class="marked"><a name="line197"></a>..197         {exact, Skip} ->
</span><span class="covered"><a name="line198"></a>..198             PrefixSkip = Skip + size(Prefix),
</span><span class="covered"><a name="line199"></a>..199             case Data of
</span><span class="marked"><a name="line200"></a>..200                 <<_:PrefixSkip/binary, "\r\n", _/binary>> ->
</span><span class="covered"><a name="line201"></a>..201                     {next_boundary, Skip, size(Prefix) + 2};
</span><span class="marked"><a name="line202"></a>..202                 <<_:PrefixSkip/binary, "--\r\n", _/binary>> ->
</span><span class="covered"><a name="line203"></a>..203                     {end_boundary, Skip, size(Prefix) + 4};
</span><span class="marked"><a name="line204"></a>..204                 _ when size(Data) < PrefixSkip + 4 ->
</span><span class="marked"><a name="line205"></a>..205                     %% Underflow
</span><span class="covered"><a name="line206"></a>..206                     {maybe, Skip};
</span><span class="marked"><a name="line207"></a>..207                 _ ->
</span><span class="marked"><a name="line208"></a>..208                     %% False positive
</span><span class="uncovered"><a name="line209"></a>..209                     not_found
</span><span class="marked"><a name="line210"></a>..210             end;
</span><span class="marked"><a name="line211"></a>..211         {partial, Skip, Length} when (Skip + Length) =:= size(Data) ->
</span><span class="marked"><a name="line212"></a>..212             %% Underflow
</span><span class="covered"><a name="line213"></a>..213             {maybe, Skip};
</span><span class="marked"><a name="line214"></a>..214         _ ->
</span><span class="covered"><a name="line215"></a>..215             not_found
</span><span class="marked"><a name="line216"></a>..216     end.
</span></pre><hr /><p>Generated using <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.</p>
          </body>
        </html>
    