<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
          <head>
            <title>mochiweb_request - C0 code coverage information</title>
            <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
            <style type='text/css'>span.marked0 {
     background-color: rgb(185, 210, 200);
     display: block;
    }
    span.marked { display: block; background-color: #ffffff; }
    span.highlight { display: block; background-color: #fff9d7; }
    span.covered { display: block; background-color: #f7f7f7 ; }
    span.uncovered { display: block; background-color: #ffebe8 ; }
    span.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    div.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    body {
     font-family: verdana, arial, helvetica;
    }
    div.footer {
     font-size: 68%;
     margin-top: 1.5em;
    }
    h1, h2, h3, h4, h5, h6 {
     margin-bottom: 0.5em;
    }
    h5 {
     margin-top: 0.5em;
    }
    .hidden {
     display: none;
    }
    div.separator {
     height: 10px;
    }
    table.percent_graph {
     height: 12px;
     border: 1px solid #E2E6EF; 
     empty-cells: show;
    }
    table.percent_graph td.covered {
     height: 10px;
     background: #00f000;
    }
    table.percent_graph td.uncovered {
     height: 10px;
     background: #e00000;
    }
    table.percent_graph td.NA {
     height: 10px;
     background: #eaeaea;
    }
    table.report {
     border-collapse: collapse;
     width: 100%;
    }
    table.report td.heading {
     background: #dcecff;
     border: 1px solid #E2E6EF; 
     font-weight: bold;
     text-align: center;
    }
    table.report td.heading:hover {
     background: #c0ffc0;
    }
    table.report td.text {
     border: 1px solid #E2E6EF; 
    }
    table.report td.value {
     text-align: right;
     border: 1px solid #E2E6EF; 
    }
    table.report tr.light {
     background-color: rgb(240, 240, 245);
    }
    table.report tr.dark {
     background-color: rgb(230, 230, 235);
    }
    </style>
          </head>
          <body>
            <h3>C0 code coverage information</h3>
            <p>Generated on 2009-02-25 00:22:45 with <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.
            </p>            
        <table class='report'>
          <thead>
            <tr>
              <td class='heading'>Name</td>
              <td class='heading'>Total lines</td>
              <td class='heading'>Lines of code</td>
              <td class='heading'>Total coverage</td>
              <td class='heading'>Code coverage</td>
            </tr>
          </thead>
          <tbody>
            <tr class='light'>

              <td>
                <a href='mochiweb_request_report.html'>mochiweb_request</a>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td>
                <table cellspacing='0' cellpadding='0' align='right'>
                  <tr>
                    <td><tt>0%</tt>&nbsp;</td><td>
                      <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                      <tr><td class='covered' width='0' /><td class='uncovered' width='100' /></tr>
                      </table>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </tbody>
        </table><pre><span class="marked"><a name="line1"></a>....1 %% @author Bob Ippolito <bob@mochimedia.com>
</span><span class="marked"><a name="line2"></a>....2 %% @copyright 2007 Mochi Media, Inc.
</span><span class="marked"><a name="line3"></a>....3 
</span><span class="marked"><a name="line4"></a>....4 %% @doc MochiWeb HTTP Request abstraction.
</span><span class="marked"><a name="line5"></a>....5 
</span><span class="marked"><a name="line6"></a>....6 -module(mochiweb_request, [Socket, Method, RawPath, Version, Headers]).
</span><span class="marked"><a name="line7"></a>....7 -author('bob@mochimedia.com').
</span><span class="marked"><a name="line8"></a>....8 
</span><span class="marked"><a name="line9"></a>....9 -include_lib("kernel/include/file.hrl").
</span><span class="marked"><a name="line10"></a>...10 
</span><span class="marked"><a name="line11"></a>...11 -define(QUIP, "Any of you quaids got a smint?").
</span><span class="marked"><a name="line12"></a>...12 -define(READ_SIZE, 8192).
</span><span class="marked"><a name="line13"></a>...13 
</span><span class="marked"><a name="line14"></a>...14 -export([get_header_value/1, get_primary_header_value/1, get/1, dump/0]).
</span><span class="marked"><a name="line15"></a>...15 -export([send/1, recv/1, recv/2, recv_body/0, recv_body/1, stream_body/3]).
</span><span class="marked"><a name="line16"></a>...16 -export([start_response/1, start_response_length/1, start_raw_response/1]).
</span><span class="marked"><a name="line17"></a>...17 -export([respond/1, ok/1]).
</span><span class="marked"><a name="line18"></a>...18 -export([not_found/0, not_found/1]).
</span><span class="marked"><a name="line19"></a>...19 -export([redirect/1, redirect/2]).
</span><span class="marked"><a name="line20"></a>...20 -export([parse_post/0, parse_qs/0]).
</span><span class="marked"><a name="line21"></a>...21 -export([should_close/0, cleanup/0]).
</span><span class="marked"><a name="line22"></a>...22 -export([parse_cookie/0, get_cookie_value/1]).
</span><span class="marked"><a name="line23"></a>...23 -export([serve_file/2, serve_file/3]).
</span><span class="marked"><a name="line24"></a>...24 -export([test/0]).
</span><span class="marked"><a name="line25"></a>...25 
</span><span class="marked"><a name="line26"></a>...26 -define(SAVE_QS, mochiweb_request_qs).
</span><span class="marked"><a name="line27"></a>...27 -define(SAVE_PATH, mochiweb_request_path).
</span><span class="marked"><a name="line28"></a>...28 -define(SAVE_RECV, mochiweb_request_recv).
</span><span class="marked"><a name="line29"></a>...29 -define(SAVE_BODY, mochiweb_request_body).
</span><span class="marked"><a name="line30"></a>...30 -define(SAVE_BODY_LENGTH, mochiweb_request_body_length).
</span><span class="marked"><a name="line31"></a>...31 -define(SAVE_POST, mochiweb_request_post).
</span><span class="marked"><a name="line32"></a>...32 -define(SAVE_COOKIE, mochiweb_request_cookie).
</span><span class="marked"><a name="line33"></a>...33 -define(SAVE_FORCE_CLOSE, mochiweb_request_force_close).
</span><span class="marked"><a name="line34"></a>...34 
</span><span class="marked"><a name="line35"></a>...35 %% @type iolist() = [iolist() | binary() | char()].
</span><span class="marked"><a name="line36"></a>...36 %% @type iodata() = binary() | iolist().
</span><span class="marked"><a name="line37"></a>...37 %% @type key() = atom() | string() | binary()
</span><span class="marked"><a name="line38"></a>...38 %% @type value() = atom() | string() | binary() | integer()
</span><span class="marked"><a name="line39"></a>...39 %% @type headers(). A mochiweb_headers structure.
</span><span class="marked"><a name="line40"></a>...40 %% @type response(). A mochiweb_response parameterized module instance.
</span><span class="marked"><a name="line41"></a>...41 %% @type ioheaders() = headers() | [{key(), value()}].
</span><span class="marked"><a name="line42"></a>...42 
</span><span class="marked"><a name="line43"></a>...43 % 10 second default idle timeout
</span><span class="marked"><a name="line44"></a>...44 -define(IDLE_TIMEOUT, 10000).
</span><span class="marked"><a name="line45"></a>...45 
</span><span class="marked"><a name="line46"></a>...46 % Maximum recv_body() length of 1MB
</span><span class="marked"><a name="line47"></a>...47 -define(MAX_RECV_BODY, (1024*1024)).
</span><span class="marked"><a name="line48"></a>...48 
</span><span class="marked"><a name="line49"></a>...49 %% @spec get_header_value(K) -> undefined | Value
</span><span class="marked"><a name="line50"></a>...50 %% @doc Get the value of a given request header.
</span><span class="marked"><a name="line51"></a>...51 get_header_value(K) ->
</span><span class="uncovered"><a name="line52"></a>...52     mochiweb_headers:get_value(K, Headers).
</span><span class="marked"><a name="line53"></a>...53 
</span><span class="marked"><a name="line54"></a>...54 get_primary_header_value(K) ->
</span><span class="uncovered"><a name="line55"></a>...55     mochiweb_headers:get_primary_value(K, Headers).
</span><span class="marked"><a name="line56"></a>...56 
</span><span class="marked"><a name="line57"></a>...57 %% @type field() = socket | method | raw_path | version | headers | peer | path | body_length | range
</span><span class="marked"><a name="line58"></a>...58 
</span><span class="marked"><a name="line59"></a>...59 %% @spec get(field()) -> term()
</span><span class="marked"><a name="line60"></a>...60 %% @doc Return the internal representation of the given field.
</span><span class="marked"><a name="line61"></a>...61 get(socket) ->
</span><span class="uncovered"><a name="line62"></a>...62     Socket;
</span><span class="marked"><a name="line63"></a>...63 get(method) ->
</span><span class="uncovered"><a name="line64"></a>...64     Method;
</span><span class="marked"><a name="line65"></a>...65 get(raw_path) ->
</span><span class="uncovered"><a name="line66"></a>...66     RawPath;
</span><span class="marked"><a name="line67"></a>...67 get(version) ->
</span><span class="uncovered"><a name="line68"></a>...68     Version;
</span><span class="marked"><a name="line69"></a>...69 get(headers) ->
</span><span class="uncovered"><a name="line70"></a>...70     Headers;
</span><span class="marked"><a name="line71"></a>...71 get(peer) ->
</span><span class="uncovered"><a name="line72"></a>...72     case inet:peername(Socket) of
</span><span class="marked"><a name="line73"></a>...73         {ok, {Addr={10, _, _, _}, _Port}} ->
</span><span class="uncovered"><a name="line74"></a>...74             case get_header_value("x-forwarded-for") of
</span><span class="marked"><a name="line75"></a>...75                 undefined ->
</span><span class="uncovered"><a name="line76"></a>...76                     inet_parse:ntoa(Addr);
</span><span class="marked"><a name="line77"></a>...77                 Hosts ->
</span><span class="uncovered"><a name="line78"></a>...78                     string:strip(lists:last(string:tokens(Hosts, ",")))
</span><span class="marked"><a name="line79"></a>...79             end;
</span><span class="marked"><a name="line80"></a>...80         {ok, {{127, 0, 0, 1}, _Port}} ->
</span><span class="uncovered"><a name="line81"></a>...81             case get_header_value("x-forwarded-for") of
</span><span class="marked"><a name="line82"></a>...82                 undefined ->
</span><span class="uncovered"><a name="line83"></a>...83                     "127.0.0.1";
</span><span class="marked"><a name="line84"></a>...84                 Hosts ->
</span><span class="uncovered"><a name="line85"></a>...85                     string:strip(lists:last(string:tokens(Hosts, ",")))
</span><span class="marked"><a name="line86"></a>...86             end;
</span><span class="marked"><a name="line87"></a>...87         {ok, {Addr, _Port}} ->
</span><span class="uncovered"><a name="line88"></a>...88             inet_parse:ntoa(Addr)
</span><span class="marked"><a name="line89"></a>...89     end;
</span><span class="marked"><a name="line90"></a>...90 get(path) ->
</span><span class="uncovered"><a name="line91"></a>...91     case erlang:get(?SAVE_PATH) of
</span><span class="marked"><a name="line92"></a>...92         undefined ->
</span><span class="uncovered"><a name="line93"></a>...93             {Path0, _, _} = mochiweb_util:urlsplit_path(RawPath),
</span><span class="uncovered"><a name="line94"></a>...94             Path = mochiweb_util:unquote(Path0),
</span><span class="uncovered"><a name="line95"></a>...95             put(?SAVE_PATH, Path),
</span><span class="uncovered"><a name="line96"></a>...96             Path;
</span><span class="marked"><a name="line97"></a>...97         Cached ->
</span><span class="uncovered"><a name="line98"></a>...98             Cached
</span><span class="marked"><a name="line99"></a>...99     end;
</span><span class="marked"><a name="line100"></a>..100 get(body_length) ->
</span><span class="uncovered"><a name="line101"></a>..101     erlang:get(?SAVE_BODY_LENGTH);
</span><span class="marked"><a name="line102"></a>..102 get(range) ->
</span><span class="uncovered"><a name="line103"></a>..103     case get_header_value(range) of
</span><span class="marked"><a name="line104"></a>..104         undefined ->
</span><span class="uncovered"><a name="line105"></a>..105             undefined;
</span><span class="marked"><a name="line106"></a>..106         RawRange ->
</span><span class="uncovered"><a name="line107"></a>..107             parse_range_request(RawRange)
</span><span class="marked"><a name="line108"></a>..108     end.
</span><span class="marked"><a name="line109"></a>..109 
</span><span class="marked"><a name="line110"></a>..110 %% @spec dump() -> {mochiweb_request, [{atom(), term()}]}
</span><span class="marked"><a name="line111"></a>..111 %% @doc Dump the internal representation to a "human readable" set of terms
</span><span class="marked"><a name="line112"></a>..112 %%      for debugging/inspection purposes.
</span><span class="marked"><a name="line113"></a>..113 dump() ->
</span><span class="uncovered"><a name="line114"></a>..114     {?MODULE, [{method, Method},
</span><span class="marked"><a name="line115"></a>..115                {version, Version},
</span><span class="marked"><a name="line116"></a>..116                {raw_path, RawPath},
</span><span class="marked"><a name="line117"></a>..117                {headers, mochiweb_headers:to_list(Headers)}]}.
</span><span class="marked"><a name="line118"></a>..118 
</span><span class="marked"><a name="line119"></a>..119 %% @spec send(iodata()) -> ok
</span><span class="marked"><a name="line120"></a>..120 %% @doc Send data over the socket.
</span><span class="marked"><a name="line121"></a>..121 send(Data) ->
</span><span class="uncovered"><a name="line122"></a>..122     case gen_tcp:send(Socket, Data) of
</span><span class="marked"><a name="line123"></a>..123         ok ->
</span><span class="uncovered"><a name="line124"></a>..124             ok;
</span><span class="marked"><a name="line125"></a>..125         _ ->
</span><span class="uncovered"><a name="line126"></a>..126             exit(normal)
</span><span class="marked"><a name="line127"></a>..127     end.
</span><span class="marked"><a name="line128"></a>..128 
</span><span class="marked"><a name="line129"></a>..129 %% @spec recv(integer()) -> binary()
</span><span class="marked"><a name="line130"></a>..130 %% @doc Receive Length bytes from the client as a binary, with the default
</span><span class="marked"><a name="line131"></a>..131 %%      idle timeout.
</span><span class="marked"><a name="line132"></a>..132 recv(Length) ->
</span><span class="uncovered"><a name="line133"></a>..133     recv(Length, ?IDLE_TIMEOUT).
</span><span class="marked"><a name="line134"></a>..134 
</span><span class="marked"><a name="line135"></a>..135 %% @spec recv(integer(), integer()) -> binary()
</span><span class="marked"><a name="line136"></a>..136 %% @doc Receive Length bytes from the client as a binary, with the given
</span><span class="marked"><a name="line137"></a>..137 %%      Timeout in msec.
</span><span class="marked"><a name="line138"></a>..138 recv(Length, Timeout) ->
</span><span class="uncovered"><a name="line139"></a>..139     case gen_tcp:recv(Socket, Length, Timeout) of
</span><span class="marked"><a name="line140"></a>..140         {ok, Data} ->
</span><span class="uncovered"><a name="line141"></a>..141             put(?SAVE_RECV, true),
</span><span class="uncovered"><a name="line142"></a>..142             Data;
</span><span class="marked"><a name="line143"></a>..143         _ ->
</span><span class="uncovered"><a name="line144"></a>..144             exit(normal)
</span><span class="marked"><a name="line145"></a>..145     end.
</span><span class="marked"><a name="line146"></a>..146 
</span><span class="marked"><a name="line147"></a>..147 %% @spec body_length() -> undefined | chunked | unknown_transfer_encoding | integer()
</span><span class="marked"><a name="line148"></a>..148 %% @doc  Infer body length from transfer-encoding and content-length headers.
</span><span class="marked"><a name="line149"></a>..149 body_length() ->
</span><span class="uncovered"><a name="line150"></a>..150     case get_header_value("transfer-encoding") of
</span><span class="marked"><a name="line151"></a>..151         undefined ->
</span><span class="uncovered"><a name="line152"></a>..152             case get_header_value("content-length") of
</span><span class="marked"><a name="line153"></a>..153                 undefined ->
</span><span class="uncovered"><a name="line154"></a>..154                     undefined;
</span><span class="marked"><a name="line155"></a>..155                 Length ->
</span><span class="uncovered"><a name="line156"></a>..156                     list_to_integer(Length)
</span><span class="marked"><a name="line157"></a>..157             end;
</span><span class="marked"><a name="line158"></a>..158         "chunked" ->
</span><span class="uncovered"><a name="line159"></a>..159             chunked;
</span><span class="marked"><a name="line160"></a>..160         Unknown ->
</span><span class="uncovered"><a name="line161"></a>..161             {unknown_transfer_encoding, Unknown}
</span><span class="marked"><a name="line162"></a>..162     end.
</span><span class="marked"><a name="line163"></a>..163 
</span><span class="marked"><a name="line164"></a>..164 
</span><span class="marked"><a name="line165"></a>..165 %% @spec recv_body() -> binary()
</span><span class="marked"><a name="line166"></a>..166 %% @doc Receive the body of the HTTP request (defined by Content-Length).
</span><span class="marked"><a name="line167"></a>..167 %%      Will only receive up to the default max-body length of 1MB.
</span><span class="marked"><a name="line168"></a>..168 recv_body() ->
</span><span class="uncovered"><a name="line169"></a>..169     recv_body(?MAX_RECV_BODY).
</span><span class="marked"><a name="line170"></a>..170 
</span><span class="marked"><a name="line171"></a>..171 %% @spec recv_body(integer()) -> binary()
</span><span class="marked"><a name="line172"></a>..172 %% @doc Receive the body of the HTTP request (defined by Content-Length).
</span><span class="marked"><a name="line173"></a>..173 %%      Will receive up to MaxBody bytes.
</span><span class="marked"><a name="line174"></a>..174 recv_body(MaxBody) ->
</span><span class="uncovered"><a name="line175"></a>..175 	case erlang:get(?SAVE_BODY) of
</span><span class="marked"><a name="line176"></a>..176         undefined ->	
</span><span class="uncovered"><a name="line177"></a>..177 		    case get_header_value("expect") of
</span><span class="marked"><a name="line178"></a>..178 		        "100-continue" ->
</span><span class="uncovered"><a name="line179"></a>..179 		            start_raw_response({100, gb_trees:empty()});
</span><span class="marked"><a name="line180"></a>..180 		        _Else ->
</span><span class="uncovered"><a name="line181"></a>..181 		            ok
</span><span class="marked"><a name="line182"></a>..182 		    end,
</span><span class="uncovered"><a name="line183"></a>..183             Body = stream_body(?MAX_RECV_BODY, fun
</span><span class="marked"><a name="line184"></a>..184                 ({0, _ChunkedFooter}, {_LengthAcc, BinAcc}) -> 
</span><span class="uncovered"><a name="line185"></a>..185                     iolist_to_binary(lists:reverse(BinAcc));
</span><span class="marked"><a name="line186"></a>..186                 ({Length, Bin}, {LengthAcc, BinAcc}) ->
</span><span class="uncovered"><a name="line187"></a>..187                     NewLength = Length + LengthAcc,
</span><span class="uncovered"><a name="line188"></a>..188                     if NewLength > MaxBody ->
</span><span class="uncovered"><a name="line189"></a>..189                         exit({body_too_large, chunked});
</span><span class="marked"><a name="line190"></a>..190                     true -> 
</span><span class="uncovered"><a name="line191"></a>..191                         {NewLength, [Bin | BinAcc]}
</span><span class="marked"><a name="line192"></a>..192                     end
</span><span class="marked"><a name="line193"></a>..193                 end, {0, []}, MaxBody),
</span><span class="uncovered"><a name="line194"></a>..194             put(?SAVE_BODY, Body),
</span><span class="uncovered"><a name="line195"></a>..195 		    Body;
</span><span class="uncovered"><a name="line196"></a>..196 		X -> X
</span><span class="marked"><a name="line197"></a>..197     end.
</span><span class="marked"><a name="line198"></a>..198 
</span><span class="marked"><a name="line199"></a>..199 stream_body(MaxChunkSize, ChunkFun, FunState) ->
</span><span class="uncovered"><a name="line200"></a>..200     stream_body(MaxChunkSize, ChunkFun, FunState, undefined).
</span><span class="marked"><a name="line201"></a>..201     
</span><span class="marked"><a name="line202"></a>..202 stream_body(MaxChunkSize, ChunkFun, FunState, MaxBodyLength) ->
</span><span class="marked"><a name="line203"></a>..203 
</span><span class="uncovered"><a name="line204"></a>..204     case get_header_value("expect") of
</span><span class="marked"><a name="line205"></a>..205         "100-continue" ->
</span><span class="uncovered"><a name="line206"></a>..206             start_raw_response({100, gb_trees:empty()});
</span><span class="marked"><a name="line207"></a>..207         _Else ->
</span><span class="uncovered"><a name="line208"></a>..208             ok
</span><span class="marked"><a name="line209"></a>..209     end,
</span><span class="uncovered"><a name="line210"></a>..210     case body_length() of
</span><span class="marked"><a name="line211"></a>..211         undefined ->
</span><span class="uncovered"><a name="line212"></a>..212             undefined;
</span><span class="marked"><a name="line213"></a>..213         {unknown_transfer_encoding, Unknown} ->
</span><span class="uncovered"><a name="line214"></a>..214             exit({unknown_transfer_encoding, Unknown});
</span><span class="marked"><a name="line215"></a>..215         chunked ->
</span><span class="marked"><a name="line216"></a>..216             % In this case the MaxBody is actually used to
</span><span class="marked"><a name="line217"></a>..217             % determine the maximum allowed size of a single
</span><span class="marked"><a name="line218"></a>..218             % chunk.
</span><span class="uncovered"><a name="line219"></a>..219             stream_chunked_body(MaxChunkSize, ChunkFun, FunState);
</span><span class="marked"><a name="line220"></a>..220         0 ->
</span><span class="uncovered"><a name="line221"></a>..221             <<>>;
</span><span class="marked"><a name="line222"></a>..222         Length when is_integer(Length) ->
</span><span class="uncovered"><a name="line223"></a>..223             case MaxBodyLength of
</span><span class="marked"><a name="line224"></a>..224             MaxBodyLength when is_integer(MaxBodyLength), MaxBodyLength < Length ->
</span><span class="uncovered"><a name="line225"></a>..225                 exit({body_too_large, content_length});
</span><span class="marked"><a name="line226"></a>..226             _ ->
</span><span class="uncovered"><a name="line227"></a>..227                 stream_unchunked_body(Length, MaxChunkSize, ChunkFun, FunState)
</span><span class="marked"><a name="line228"></a>..228             end;     
</span><span class="marked"><a name="line229"></a>..229         Length ->
</span><span class="uncovered"><a name="line230"></a>..230             exit({length_not_integer, Length})
</span><span class="marked"><a name="line231"></a>..231     end.
</span><span class="marked"><a name="line232"></a>..232 
</span><span class="marked"><a name="line233"></a>..233 
</span><span class="marked"><a name="line234"></a>..234 %% @spec start_response({integer(), ioheaders()}) -> response()
</span><span class="marked"><a name="line235"></a>..235 %% @doc Start the HTTP response by sending the Code HTTP response and
</span><span class="marked"><a name="line236"></a>..236 %%      ResponseHeaders. The server will set header defaults such as Server
</span><span class="marked"><a name="line237"></a>..237 %%      and Date if not present in ResponseHeaders.
</span><span class="marked"><a name="line238"></a>..238 start_response({Code, ResponseHeaders}) ->
</span><span class="uncovered"><a name="line239"></a>..239     HResponse = mochiweb_headers:make(ResponseHeaders),
</span><span class="uncovered"><a name="line240"></a>..240     HResponse1 = mochiweb_headers:default_from_list(server_headers(),
</span><span class="marked"><a name="line241"></a>..241                                                     HResponse),
</span><span class="uncovered"><a name="line242"></a>..242     start_raw_response({Code, HResponse1}).
</span><span class="marked"><a name="line243"></a>..243 
</span><span class="marked"><a name="line244"></a>..244 %% @spec start_raw_response({integer(), headers()}) -> response()
</span><span class="marked"><a name="line245"></a>..245 %% @doc Start the HTTP response by sending the Code HTTP response and
</span><span class="marked"><a name="line246"></a>..246 %%      ResponseHeaders.
</span><span class="marked"><a name="line247"></a>..247 start_raw_response({Code, ResponseHeaders}) ->
</span><span class="uncovered"><a name="line248"></a>..248     F = fun ({K, V}, Acc) ->
</span><span class="uncovered"><a name="line249"></a>..249                 [make_io(K), <<": ">>, V, <<"\r\n">> | Acc]
</span><span class="marked"><a name="line250"></a>..250         end,
</span><span class="uncovered"><a name="line251"></a>..251     End = lists:foldl(F, [<<"\r\n">>],
</span><span class="marked"><a name="line252"></a>..252                       mochiweb_headers:to_list(ResponseHeaders)),
</span><span class="uncovered"><a name="line253"></a>..253     send([make_version(Version), make_code(Code), <<"\r\n">> | End]),
</span><span class="uncovered"><a name="line254"></a>..254     mochiweb_http:new_response({THIS, Code, ResponseHeaders}).
</span><span class="marked"><a name="line255"></a>..255 
</span><span class="marked"><a name="line256"></a>..256 
</span><span class="marked"><a name="line257"></a>..257 %% @spec start_response_length({integer(), ioheaders(), integer()}) -> response()
</span><span class="marked"><a name="line258"></a>..258 %% @doc Start the HTTP response by sending the Code HTTP response and
</span><span class="marked"><a name="line259"></a>..259 %%      ResponseHeaders including a Content-Length of Length. The server
</span><span class="marked"><a name="line260"></a>..260 %%      will set header defaults such as Server
</span><span class="marked"><a name="line261"></a>..261 %%      and Date if not present in ResponseHeaders.
</span><span class="marked"><a name="line262"></a>..262 start_response_length({Code, ResponseHeaders, Length}) ->
</span><span class="uncovered"><a name="line263"></a>..263     HResponse = mochiweb_headers:make(ResponseHeaders),
</span><span class="uncovered"><a name="line264"></a>..264     HResponse1 = mochiweb_headers:enter("Content-Length", Length, HResponse),
</span><span class="uncovered"><a name="line265"></a>..265     start_response({Code, HResponse1}).
</span><span class="marked"><a name="line266"></a>..266 
</span><span class="marked"><a name="line267"></a>..267 %% @spec respond({integer(), ioheaders(), iodata() | chunked | {file, IoDevice}}) -> response()
</span><span class="marked"><a name="line268"></a>..268 %% @doc Start the HTTP response with start_response, and send Body to the
</span><span class="marked"><a name="line269"></a>..269 %%      client (if the get(method) /= 'HEAD'). The Content-Length header
</span><span class="marked"><a name="line270"></a>..270 %%      will be set by the Body length, and the server will insert header
</span><span class="marked"><a name="line271"></a>..271 %%      defaults.
</span><span class="marked"><a name="line272"></a>..272 respond({Code, ResponseHeaders, {file, IoDevice}}) ->
</span><span class="uncovered"><a name="line273"></a>..273     Length = iodevice_size(IoDevice),
</span><span class="uncovered"><a name="line274"></a>..274     Response = start_response_length({Code, ResponseHeaders, Length}),
</span><span class="uncovered"><a name="line275"></a>..275     case Method of
</span><span class="marked"><a name="line276"></a>..276         'HEAD' ->
</span><span class="uncovered"><a name="line277"></a>..277             ok;
</span><span class="marked"><a name="line278"></a>..278         _ ->
</span><span class="uncovered"><a name="line279"></a>..279             iodevice_stream(IoDevice)
</span><span class="marked"><a name="line280"></a>..280     end,
</span><span class="uncovered"><a name="line281"></a>..281     Response;
</span><span class="marked"><a name="line282"></a>..282 respond({Code, ResponseHeaders, chunked}) ->
</span><span class="uncovered"><a name="line283"></a>..283     HResponse = mochiweb_headers:make(ResponseHeaders),
</span><span class="uncovered"><a name="line284"></a>..284     HResponse1 = case Method of
</span><span class="marked"><a name="line285"></a>..285                      'HEAD' ->
</span><span class="marked"><a name="line286"></a>..286                          %% This is what Google does, http://www.google.com/
</span><span class="marked"><a name="line287"></a>..287                          %% is chunked but HEAD gets Content-Length: 0.
</span><span class="marked"><a name="line288"></a>..288                          %% The RFC is ambiguous so emulating Google is smart.
</span><span class="uncovered"><a name="line289"></a>..289                          mochiweb_headers:enter("Content-Length", "0",
</span><span class="marked"><a name="line290"></a>..290                                                 HResponse);
</span><span class="marked"><a name="line291"></a>..291                      _ when Version >= {1, 1} ->
</span><span class="marked"><a name="line292"></a>..292                          %% Only use chunked encoding for HTTP/1.1
</span><span class="uncovered"><a name="line293"></a>..293                          mochiweb_headers:enter("Transfer-Encoding", "chunked",
</span><span class="marked"><a name="line294"></a>..294                                                 HResponse);
</span><span class="marked"><a name="line295"></a>..295                      _ ->
</span><span class="marked"><a name="line296"></a>..296                          %% For pre-1.1 clients we send the data as-is
</span><span class="marked"><a name="line297"></a>..297                          %% without a Content-Length header and without
</span><span class="marked"><a name="line298"></a>..298                          %% chunk delimiters. Since the end of the document
</span><span class="marked"><a name="line299"></a>..299                          %% is now ambiguous we must force a close.
</span><span class="uncovered"><a name="line300"></a>..300                          put(?SAVE_FORCE_CLOSE, true),
</span><span class="uncovered"><a name="line301"></a>..301                          HResponse
</span><span class="marked"><a name="line302"></a>..302                  end,
</span><span class="uncovered"><a name="line303"></a>..303     start_response({Code, HResponse1});
</span><span class="marked"><a name="line304"></a>..304 respond({Code, ResponseHeaders, Body}) ->
</span><span class="uncovered"><a name="line305"></a>..305     Response = start_response_length({Code, ResponseHeaders, iolist_size(Body)}),
</span><span class="uncovered"><a name="line306"></a>..306     case Method of
</span><span class="marked"><a name="line307"></a>..307         'HEAD' ->
</span><span class="uncovered"><a name="line308"></a>..308             ok;
</span><span class="marked"><a name="line309"></a>..309         _ ->
</span><span class="uncovered"><a name="line310"></a>..310             send(Body)
</span><span class="marked"><a name="line311"></a>..311     end,
</span><span class="uncovered"><a name="line312"></a>..312     Response.
</span><span class="marked"><a name="line313"></a>..313 
</span><span class="marked"><a name="line314"></a>..314 %% @spec not_found() -> response()
</span><span class="marked"><a name="line315"></a>..315 %% @doc Alias for <code>not_found([])</code>.
</span><span class="marked"><a name="line316"></a>..316 not_found() ->
</span><span class="uncovered"><a name="line317"></a>..317     not_found([]).
</span><span class="marked"><a name="line318"></a>..318 
</span><span class="marked"><a name="line319"></a>..319 %% @spec not_found(ExtraHeaders) -> response()
</span><span class="marked"><a name="line320"></a>..320 %% @doc Alias for <code>respond({404, [{"Content-Type", "text/plain"}
</span><span class="marked"><a name="line321"></a>..321 %% | ExtraHeaders], &lt;&lt;"Not found."&gt;&gt;})</code>.
</span><span class="marked"><a name="line322"></a>..322 not_found(ExtraHeaders) ->
</span><span class="uncovered"><a name="line323"></a>..323     respond({404, [{"Content-Type", "text/plain"} | ExtraHeaders],
</span><span class="marked"><a name="line324"></a>..324              <<"Not found.">>}).
</span><span class="marked"><a name="line325"></a>..325 
</span><span class="marked"><a name="line326"></a>..326 %% @spec redirect(Path::string()) -> response()
</span><span class="marked"><a name="line327"></a>..327 %% @doc Alias for <code>not_found(Path, [])</code>.
</span><span class="marked"><a name="line328"></a>..328 redirect(Path) ->
</span><span class="uncovered"><a name="line329"></a>..329     redirect(Path, []).
</span><span class="marked"><a name="line330"></a>..330 
</span><span class="marked"><a name="line331"></a>..331 %% @spec redirect(Path::string(), ExtraHeaders::list()) -> response()
</span><span class="marked"><a name="line332"></a>..332 %% @doc Alias for <code>respond({302, [{"Content-Type", "text/plain"}, {"Location", Path},
</span><span class="marked"><a name="line333"></a>..333 %% | ExtraHeaders], &lt;&lt;"Found."&gt;&gt;})</code>.
</span><span class="marked"><a name="line334"></a>..334 redirect(Path, ExtraHeaders) ->
</span><span class="uncovered"><a name="line335"></a>..335     respond({302, % using a Found instead of See Other as per compatibility note http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.3
</span><span class="marked"><a name="line336"></a>..336              [{"Content-Type", "text/plain"},
</span><span class="marked"><a name="line337"></a>..337               {"Location", Path} | ExtraHeaders],
</span><span class="marked"><a name="line338"></a>..338              <<"Found.">>}).
</span><span class="marked"><a name="line339"></a>..339 
</span><span class="marked"><a name="line340"></a>..340 %% @spec ok({value(), iodata()} | {value(), ioheaders(), iodata() | {file, IoDevice}}) ->
</span><span class="marked"><a name="line341"></a>..341 %%           response()
</span><span class="marked"><a name="line342"></a>..342 %% @doc respond({200, [{"Content-Type", ContentType} | Headers], Body}).
</span><span class="marked"><a name="line343"></a>..343 ok({ContentType, Body}) ->
</span><span class="uncovered"><a name="line344"></a>..344     ok({ContentType, [], Body});
</span><span class="marked"><a name="line345"></a>..345 ok({ContentType, ResponseHeaders, Body}) ->
</span><span class="uncovered"><a name="line346"></a>..346     HResponse = mochiweb_headers:make(ResponseHeaders),
</span><span class="uncovered"><a name="line347"></a>..347     case THIS:get(range) of
</span><span class="marked"><a name="line348"></a>..348         X when X =:= undefined; X =:= fail ->
</span><span class="uncovered"><a name="line349"></a>..349             HResponse1 = mochiweb_headers:enter("Content-Type", ContentType, HResponse),
</span><span class="uncovered"><a name="line350"></a>..350             respond({200, HResponse1, Body});
</span><span class="marked"><a name="line351"></a>..351         Ranges ->
</span><span class="uncovered"><a name="line352"></a>..352             {PartList, Size} = range_parts(Body, Ranges),
</span><span class="uncovered"><a name="line353"></a>..353             case PartList of
</span><span class="marked"><a name="line354"></a>..354                 [] -> %% no valid ranges
</span><span class="uncovered"><a name="line355"></a>..355                     HResponse1 = mochiweb_headers:enter("Content-Type",
</span><span class="marked"><a name="line356"></a>..356                                                         ContentType,
</span><span class="marked"><a name="line357"></a>..357                                                         HResponse),
</span><span class="marked"><a name="line358"></a>..358                     %% could be 416, for now we'll just return 200
</span><span class="uncovered"><a name="line359"></a>..359                     respond({200, HResponse1, Body});
</span><span class="marked"><a name="line360"></a>..360                 PartList ->
</span><span class="uncovered"><a name="line361"></a>..361                     {RangeHeaders, RangeBody} =
</span><span class="marked"><a name="line362"></a>..362                         parts_to_body(PartList, ContentType, Size),
</span><span class="uncovered"><a name="line363"></a>..363                     HResponse1 = mochiweb_headers:enter_from_list(
</span><span class="marked"><a name="line364"></a>..364                                    [{"Accept-Ranges", "bytes"} |
</span><span class="marked"><a name="line365"></a>..365                                     RangeHeaders],
</span><span class="marked"><a name="line366"></a>..366                                    HResponse),
</span><span class="uncovered"><a name="line367"></a>..367                     respond({206, HResponse1, RangeBody})
</span><span class="marked"><a name="line368"></a>..368             end
</span><span class="marked"><a name="line369"></a>..369     end.
</span><span class="marked"><a name="line370"></a>..370 
</span><span class="marked"><a name="line371"></a>..371 %% @spec should_close() -> bool()
</span><span class="marked"><a name="line372"></a>..372 %% @doc Return true if the connection must be closed. If false, using
</span><span class="marked"><a name="line373"></a>..373 %%      Keep-Alive should be safe.
</span><span class="marked"><a name="line374"></a>..374 should_close() ->
</span><span class="uncovered"><a name="line375"></a>..375     ForceClose = erlang:get(mochiweb_request_force_close) =/= undefined,
</span><span class="uncovered"><a name="line376"></a>..376     DidNotRecv = erlang:get(mochiweb_request_recv) =:= undefined,
</span><span class="uncovered"><a name="line377"></a>..377     ForceClose orelse Version < {1, 0}
</span><span class="marked"><a name="line378"></a>..378         %% Connection: close
</span><span class="uncovered"><a name="line379"></a>..379         orelse get_header_value("connection") =:= "close"
</span><span class="marked"><a name="line380"></a>..380         %% HTTP 1.0 requires Connection: Keep-Alive
</span><span class="uncovered"><a name="line381"></a>..381         orelse (Version =:= {1, 0}
</span><span class="uncovered"><a name="line382"></a>..382                 andalso get_header_value("connection") =/= "Keep-Alive")
</span><span class="marked"><a name="line383"></a>..383         %% unread data left on the socket, can't safely continue
</span><span class="uncovered"><a name="line384"></a>..384         orelse (DidNotRecv
</span><span class="uncovered"><a name="line385"></a>..385                 andalso get_header_value("content-length") =/= undefined
</span><span class="uncovered"><a name="line386"></a>..386                 andalso list_to_integer(get_header_value("content-length")) > 0)
</span><span class="uncovered"><a name="line387"></a>..387         orelse (DidNotRecv
</span><span class="uncovered"><a name="line388"></a>..388                 andalso get_header_value("transfer-encoding") =:= "chunked").
</span><span class="marked"><a name="line389"></a>..389 
</span><span class="marked"><a name="line390"></a>..390 %% @spec cleanup() -> ok
</span><span class="marked"><a name="line391"></a>..391 %% @doc Clean up any junk in the process dictionary, required before continuing
</span><span class="marked"><a name="line392"></a>..392 %%      a Keep-Alive request.
</span><span class="marked"><a name="line393"></a>..393 cleanup() ->
</span><span class="uncovered"><a name="line394"></a>..394     [erase(K) || K <- [?SAVE_QS,
</span><span class="marked"><a name="line395"></a>..395                        ?SAVE_PATH,
</span><span class="marked"><a name="line396"></a>..396                        ?SAVE_RECV,
</span><span class="marked"><a name="line397"></a>..397                        ?SAVE_BODY,
</span><span class="marked"><a name="line398"></a>..398                        ?SAVE_POST,
</span><span class="marked"><a name="line399"></a>..399                        ?SAVE_COOKIE,
</span><span class="marked"><a name="line400"></a>..400                        ?SAVE_FORCE_CLOSE]],
</span><span class="uncovered"><a name="line401"></a>..401     ok.
</span><span class="marked"><a name="line402"></a>..402 
</span><span class="marked"><a name="line403"></a>..403 %% @spec parse_qs() -> [{Key::string(), Value::string()}]
</span><span class="marked"><a name="line404"></a>..404 %% @doc Parse the query string of the URL.
</span><span class="marked"><a name="line405"></a>..405 parse_qs() ->
</span><span class="uncovered"><a name="line406"></a>..406     case erlang:get(?SAVE_QS) of
</span><span class="marked"><a name="line407"></a>..407         undefined ->
</span><span class="uncovered"><a name="line408"></a>..408             {_, QueryString, _} = mochiweb_util:urlsplit_path(RawPath),
</span><span class="uncovered"><a name="line409"></a>..409             Parsed = mochiweb_util:parse_qs(QueryString),
</span><span class="uncovered"><a name="line410"></a>..410             put(?SAVE_QS, Parsed),
</span><span class="uncovered"><a name="line411"></a>..411             Parsed;
</span><span class="marked"><a name="line412"></a>..412         Cached ->
</span><span class="uncovered"><a name="line413"></a>..413             Cached
</span><span class="marked"><a name="line414"></a>..414     end.
</span><span class="marked"><a name="line415"></a>..415 
</span><span class="marked"><a name="line416"></a>..416 %% @spec get_cookie_value(Key::string) -> string() | undefined
</span><span class="marked"><a name="line417"></a>..417 %% @doc Get the value of the given cookie.
</span><span class="marked"><a name="line418"></a>..418 get_cookie_value(Key) ->
</span><span class="uncovered"><a name="line419"></a>..419     proplists:get_value(Key, parse_cookie()).
</span><span class="marked"><a name="line420"></a>..420 
</span><span class="marked"><a name="line421"></a>..421 %% @spec parse_cookie() -> [{Key::string(), Value::string()}]
</span><span class="marked"><a name="line422"></a>..422 %% @doc Parse the cookie header.
</span><span class="marked"><a name="line423"></a>..423 parse_cookie() ->
</span><span class="uncovered"><a name="line424"></a>..424     case erlang:get(?SAVE_COOKIE) of
</span><span class="marked"><a name="line425"></a>..425         undefined ->
</span><span class="uncovered"><a name="line426"></a>..426             Cookies = case get_header_value("cookie") of
</span><span class="marked"><a name="line427"></a>..427                           undefined ->
</span><span class="uncovered"><a name="line428"></a>..428                               [];
</span><span class="marked"><a name="line429"></a>..429                           Value ->
</span><span class="uncovered"><a name="line430"></a>..430                               mochiweb_cookies:parse_cookie(Value)
</span><span class="marked"><a name="line431"></a>..431                       end,
</span><span class="uncovered"><a name="line432"></a>..432             put(?SAVE_COOKIE, Cookies),
</span><span class="uncovered"><a name="line433"></a>..433             Cookies;
</span><span class="marked"><a name="line434"></a>..434         Cached ->
</span><span class="uncovered"><a name="line435"></a>..435             Cached
</span><span class="marked"><a name="line436"></a>..436     end.
</span><span class="marked"><a name="line437"></a>..437 
</span><span class="marked"><a name="line438"></a>..438 %% @spec parse_post() -> [{Key::string(), Value::string()}]
</span><span class="marked"><a name="line439"></a>..439 %% @doc Parse an application/x-www-form-urlencoded form POST. This
</span><span class="marked"><a name="line440"></a>..440 %%      has the side-effect of calling recv_body().
</span><span class="marked"><a name="line441"></a>..441 parse_post() ->
</span><span class="uncovered"><a name="line442"></a>..442     case erlang:get(?SAVE_POST) of
</span><span class="marked"><a name="line443"></a>..443         undefined ->
</span><span class="uncovered"><a name="line444"></a>..444             Parsed = case recv_body() of
</span><span class="marked"><a name="line445"></a>..445                          undefined ->
</span><span class="uncovered"><a name="line446"></a>..446                              [];
</span><span class="marked"><a name="line447"></a>..447                          Binary ->
</span><span class="uncovered"><a name="line448"></a>..448                              case get_primary_header_value("content-type") of
</span><span class="marked"><a name="line449"></a>..449                                  "application/x-www-form-urlencoded" ++ _ ->
</span><span class="uncovered"><a name="line450"></a>..450                                      mochiweb_util:parse_qs(Binary);
</span><span class="marked"><a name="line451"></a>..451                                  _ ->
</span><span class="uncovered"><a name="line452"></a>..452                                      []
</span><span class="marked"><a name="line453"></a>..453                              end
</span><span class="marked"><a name="line454"></a>..454                      end,
</span><span class="uncovered"><a name="line455"></a>..455             put(?SAVE_POST, Parsed),
</span><span class="uncovered"><a name="line456"></a>..456             Parsed;
</span><span class="marked"><a name="line457"></a>..457         Cached ->
</span><span class="uncovered"><a name="line458"></a>..458             Cached
</span><span class="marked"><a name="line459"></a>..459     end.
</span><span class="marked"><a name="line460"></a>..460 
</span><span class="marked"><a name="line461"></a>..461 %% @spec stream_chunked_body(integer(), fun(), term()) -> term()
</span><span class="marked"><a name="line462"></a>..462 %% @doc The function is called for each chunk.
</span><span class="marked"><a name="line463"></a>..463 %%      Used internally by read_chunked_body.
</span><span class="marked"><a name="line464"></a>..464 stream_chunked_body(MaxChunkSize, Fun, FunState) ->
</span><span class="uncovered"><a name="line465"></a>..465     case read_chunk_length() of
</span><span class="marked"><a name="line466"></a>..466         0 ->
</span><span class="uncovered"><a name="line467"></a>..467             Fun({0, read_chunk(0)}, FunState);
</span><span class="marked"><a name="line468"></a>..468         Length when Length > MaxChunkSize ->
</span><span class="uncovered"><a name="line469"></a>..469             NewState = read_sub_chunks(Length, MaxChunkSize, Fun, FunState),
</span><span class="uncovered"><a name="line470"></a>..470             stream_chunked_body(MaxChunkSize, Fun, NewState);
</span><span class="marked"><a name="line471"></a>..471         Length ->
</span><span class="uncovered"><a name="line472"></a>..472             NewState = Fun({Length, read_chunk(Length)}, FunState),
</span><span class="uncovered"><a name="line473"></a>..473             stream_chunked_body(MaxChunkSize, Fun, NewState)
</span><span class="marked"><a name="line474"></a>..474     end.
</span><span class="marked"><a name="line475"></a>..475 
</span><span class="marked"><a name="line476"></a>..476 stream_unchunked_body(0, _MaxChunkSize, Fun, FunState) ->
</span><span class="uncovered"><a name="line477"></a>..477     Fun({0, <<>>}, FunState);
</span><span class="marked"><a name="line478"></a>..478 stream_unchunked_body(Length, MaxChunkSize, Fun, FunState) when Length > MaxChunkSize ->
</span><span class="uncovered"><a name="line479"></a>..479     Bin = recv(MaxChunkSize),
</span><span class="uncovered"><a name="line480"></a>..480     NewState = Fun({MaxChunkSize, Bin}, FunState),
</span><span class="uncovered"><a name="line481"></a>..481     stream_unchunked_body(Length - MaxChunkSize, MaxChunkSize, Fun, NewState);
</span><span class="marked"><a name="line482"></a>..482 stream_unchunked_body(Length, MaxChunkSize, Fun, FunState) ->
</span><span class="uncovered"><a name="line483"></a>..483     Bin = recv(Length),
</span><span class="uncovered"><a name="line484"></a>..484     NewState = Fun({Length, Bin}, FunState),
</span><span class="uncovered"><a name="line485"></a>..485     stream_unchunked_body(0, MaxChunkSize, Fun, NewState).
</span><span class="marked"><a name="line486"></a>..486 
</span><span class="marked"><a name="line487"></a>..487 
</span><span class="marked"><a name="line488"></a>..488 %% @spec read_chunk_length() -> integer()
</span><span class="marked"><a name="line489"></a>..489 %% @doc Read the length of the next HTTP chunk.
</span><span class="marked"><a name="line490"></a>..490 read_chunk_length() ->
</span><span class="uncovered"><a name="line491"></a>..491     inet:setopts(Socket, [{packet, line}]),
</span><span class="uncovered"><a name="line492"></a>..492     case gen_tcp:recv(Socket, 0, ?IDLE_TIMEOUT) of
</span><span class="marked"><a name="line493"></a>..493         {ok, Header} ->
</span><span class="uncovered"><a name="line494"></a>..494             inet:setopts(Socket, [{packet, raw}]),
</span><span class="uncovered"><a name="line495"></a>..495             Splitter = fun (C) ->
</span><span class="uncovered"><a name="line496"></a>..496                                C =/= $\r andalso C =/= $\n andalso C =/= $
</span><span class="marked"><a name="line497"></a>..497                        end,
</span><span class="uncovered"><a name="line498"></a>..498             {Hex, _Rest} = lists:splitwith(Splitter, binary_to_list(Header)),
</span><span class="uncovered"><a name="line499"></a>..499             mochihex:to_int(Hex);
</span><span class="marked"><a name="line500"></a>..500         _ ->
</span><span class="uncovered"><a name="line501"></a>..501             exit(normal)
</span><span class="marked"><a name="line502"></a>..502     end.
</span><span class="marked"><a name="line503"></a>..503 
</span><span class="marked"><a name="line504"></a>..504 %% @spec read_chunk(integer()) -> Chunk::binary() | [Footer::binary()]
</span><span class="marked"><a name="line505"></a>..505 %% @doc Read in a HTTP chunk of the given length. If Length is 0, then read the
</span><span class="marked"><a name="line506"></a>..506 %%      HTTP footers (as a list of binaries, since they're nominal).
</span><span class="marked"><a name="line507"></a>..507 read_chunk(0) ->
</span><span class="uncovered"><a name="line508"></a>..508     inet:setopts(Socket, [{packet, line}]),
</span><span class="uncovered"><a name="line509"></a>..509     F = fun (F1, Acc) ->
</span><span class="uncovered"><a name="line510"></a>..510                 case gen_tcp:recv(Socket, 0, ?IDLE_TIMEOUT) of
</span><span class="marked"><a name="line511"></a>..511                     {ok, <<"\r\n">>} ->
</span><span class="uncovered"><a name="line512"></a>..512                         Acc;
</span><span class="marked"><a name="line513"></a>..513                     {ok, Footer} ->
</span><span class="uncovered"><a name="line514"></a>..514                         F1(F1, [Footer | Acc]);
</span><span class="marked"><a name="line515"></a>..515                     _ ->
</span><span class="uncovered"><a name="line516"></a>..516                         exit(normal)
</span><span class="marked"><a name="line517"></a>..517                 end
</span><span class="marked"><a name="line518"></a>..518         end,
</span><span class="uncovered"><a name="line519"></a>..519     Footers = F(F, []),
</span><span class="uncovered"><a name="line520"></a>..520     inet:setopts(Socket, [{packet, raw}]),
</span><span class="uncovered"><a name="line521"></a>..521     Footers;
</span><span class="marked"><a name="line522"></a>..522 read_chunk(Length) ->
</span><span class="uncovered"><a name="line523"></a>..523     case gen_tcp:recv(Socket, 2 + Length, ?IDLE_TIMEOUT) of
</span><span class="marked"><a name="line524"></a>..524         {ok, <<Chunk:Length/binary, "\r\n">>} ->
</span><span class="uncovered"><a name="line525"></a>..525             Chunk;
</span><span class="marked"><a name="line526"></a>..526         _ ->
</span><span class="uncovered"><a name="line527"></a>..527             exit(normal)
</span><span class="marked"><a name="line528"></a>..528     end.
</span><span class="marked"><a name="line529"></a>..529 
</span><span class="marked"><a name="line530"></a>..530 read_sub_chunks(Length, MaxChunkSize, Fun, FunState) when Length > MaxChunkSize ->
</span><span class="uncovered"><a name="line531"></a>..531     Bin = recv(MaxChunkSize),
</span><span class="uncovered"><a name="line532"></a>..532     NewState = Fun({size(Bin), Bin}, FunState),
</span><span class="uncovered"><a name="line533"></a>..533     read_sub_chunks(Length - MaxChunkSize, MaxChunkSize, Fun, NewState);
</span><span class="marked"><a name="line534"></a>..534 
</span><span class="marked"><a name="line535"></a>..535 read_sub_chunks(Length, _MaxChunkSize, Fun, FunState) ->
</span><span class="uncovered"><a name="line536"></a>..536     Fun({Length, read_chunk(Length)}, FunState).
</span><span class="marked"><a name="line537"></a>..537     
</span><span class="marked"><a name="line538"></a>..538 %% @spec serve_file(Path, DocRoot) -> Response
</span><span class="marked"><a name="line539"></a>..539 %% @doc Serve a file relative to DocRoot.
</span><span class="marked"><a name="line540"></a>..540 serve_file(Path, DocRoot) ->
</span><span class="uncovered"><a name="line541"></a>..541     serve_file(Path, DocRoot, []).
</span><span class="marked"><a name="line542"></a>..542 
</span><span class="marked"><a name="line543"></a>..543 %% @spec serve_file(Path, DocRoot, ExtraHeaders) -> Response
</span><span class="marked"><a name="line544"></a>..544 %% @doc Serve a file relative to DocRoot.
</span><span class="marked"><a name="line545"></a>..545 serve_file(Path, DocRoot, ExtraHeaders) ->
</span><span class="uncovered"><a name="line546"></a>..546     case mochiweb_util:safe_relative_path(Path) of
</span><span class="marked"><a name="line547"></a>..547         undefined ->
</span><span class="uncovered"><a name="line548"></a>..548             not_found(ExtraHeaders);
</span><span class="marked"><a name="line549"></a>..549         RelPath ->
</span><span class="uncovered"><a name="line550"></a>..550             FullPath = filename:join([DocRoot, RelPath]),
</span><span class="uncovered"><a name="line551"></a>..551             File = case filelib:is_dir(FullPath) of
</span><span class="marked"><a name="line552"></a>..552                        true ->
</span><span class="uncovered"><a name="line553"></a>..553                            filename:join([FullPath, "index.html"]);
</span><span class="marked"><a name="line554"></a>..554                        false ->
</span><span class="uncovered"><a name="line555"></a>..555                            FullPath
</span><span class="marked"><a name="line556"></a>..556                    end,
</span><span class="uncovered"><a name="line557"></a>..557             case file:read_file_info(File) of
</span><span class="marked"><a name="line558"></a>..558                 {ok, FileInfo} ->
</span><span class="uncovered"><a name="line559"></a>..559                     LastModified = httpd_util:rfc1123_date(FileInfo#file_info.mtime),
</span><span class="uncovered"><a name="line560"></a>..560                     case get_header_value("if-modified-since") of
</span><span class="marked"><a name="line561"></a>..561                         LastModified ->
</span><span class="uncovered"><a name="line562"></a>..562                             respond({304, ExtraHeaders, ""});
</span><span class="marked"><a name="line563"></a>..563                         _ ->
</span><span class="uncovered"><a name="line564"></a>..564                             case file:open(File, [raw, binary]) of
</span><span class="marked"><a name="line565"></a>..565                                 {ok, IoDevice} ->
</span><span class="uncovered"><a name="line566"></a>..566                                     ContentType = mochiweb_util:guess_mime(File),
</span><span class="uncovered"><a name="line567"></a>..567                                     Res = ok({ContentType,
</span><span class="marked"><a name="line568"></a>..568                                               [{"last-modified", LastModified}
</span><span class="marked"><a name="line569"></a>..569                                                | ExtraHeaders],
</span><span class="marked"><a name="line570"></a>..570                                               {file, IoDevice}}),
</span><span class="uncovered"><a name="line571"></a>..571                                     file:close(IoDevice),
</span><span class="uncovered"><a name="line572"></a>..572                                     Res;
</span><span class="marked"><a name="line573"></a>..573                                 _ ->
</span><span class="uncovered"><a name="line574"></a>..574                                     not_found(ExtraHeaders)
</span><span class="marked"><a name="line575"></a>..575                             end
</span><span class="marked"><a name="line576"></a>..576                     end;
</span><span class="marked"><a name="line577"></a>..577                 {error, _} ->
</span><span class="uncovered"><a name="line578"></a>..578                     not_found(ExtraHeaders)
</span><span class="marked"><a name="line579"></a>..579             end
</span><span class="marked"><a name="line580"></a>..580     end.
</span><span class="marked"><a name="line581"></a>..581 
</span><span class="marked"><a name="line582"></a>..582 
</span><span class="marked"><a name="line583"></a>..583 %% Internal API
</span><span class="marked"><a name="line584"></a>..584 
</span><span class="marked"><a name="line585"></a>..585 server_headers() ->
</span><span class="uncovered"><a name="line586"></a>..586     [{"Server", "MochiWeb/1.0 (" ++ ?QUIP ++ ")"},
</span><span class="marked"><a name="line587"></a>..587      {"Date", httpd_util:rfc1123_date()}].
</span><span class="marked"><a name="line588"></a>..588 
</span><span class="marked"><a name="line589"></a>..589 make_io(Atom) when is_atom(Atom) ->
</span><span class="uncovered"><a name="line590"></a>..590     atom_to_list(Atom);
</span><span class="marked"><a name="line591"></a>..591 make_io(Integer) when is_integer(Integer) ->
</span><span class="uncovered"><a name="line592"></a>..592     integer_to_list(Integer);
</span><span class="marked"><a name="line593"></a>..593 make_io(Io) when is_list(Io); is_binary(Io) ->
</span><span class="uncovered"><a name="line594"></a>..594     Io.
</span><span class="marked"><a name="line595"></a>..595 
</span><span class="marked"><a name="line596"></a>..596 make_code(X) when is_integer(X) ->
</span><span class="uncovered"><a name="line597"></a>..597     [integer_to_list(X), [" " | httpd_util:reason_phrase(X)]];
</span><span class="marked"><a name="line598"></a>..598 make_code(Io) when is_list(Io); is_binary(Io) ->
</span><span class="uncovered"><a name="line599"></a>..599     Io.
</span><span class="marked"><a name="line600"></a>..600 
</span><span class="marked"><a name="line601"></a>..601 make_version({1, 0}) ->
</span><span class="uncovered"><a name="line602"></a>..602     <<"HTTP/1.0 ">>;
</span><span class="marked"><a name="line603"></a>..603 make_version(_) ->
</span><span class="uncovered"><a name="line604"></a>..604     <<"HTTP/1.1 ">>.
</span><span class="marked"><a name="line605"></a>..605 
</span><span class="marked"><a name="line606"></a>..606 iodevice_stream(IoDevice) ->
</span><span class="uncovered"><a name="line607"></a>..607     case file:read(IoDevice, ?READ_SIZE) of
</span><span class="marked"><a name="line608"></a>..608         eof ->
</span><span class="uncovered"><a name="line609"></a>..609             ok;
</span><span class="marked"><a name="line610"></a>..610         {ok, Data} ->
</span><span class="uncovered"><a name="line611"></a>..611             ok = send(Data),
</span><span class="uncovered"><a name="line612"></a>..612             iodevice_stream(IoDevice)
</span><span class="marked"><a name="line613"></a>..613     end.
</span><span class="marked"><a name="line614"></a>..614 
</span><span class="marked"><a name="line615"></a>..615 
</span><span class="marked"><a name="line616"></a>..616 parts_to_body([{Start, End, Body}], ContentType, Size) ->
</span><span class="marked"><a name="line617"></a>..617     %% return body for a range reponse with a single body
</span><span class="uncovered"><a name="line618"></a>..618     HeaderList = [{"Content-Type", ContentType},
</span><span class="marked"><a name="line619"></a>..619                   {"Content-Range",
</span><span class="marked"><a name="line620"></a>..620                    ["bytes ",
</span><span class="marked"><a name="line621"></a>..621                     make_io(Start), "-", make_io(End),
</span><span class="marked"><a name="line622"></a>..622                     "/", make_io(Size)]}],
</span><span class="uncovered"><a name="line623"></a>..623     {HeaderList, Body};
</span><span class="marked"><a name="line624"></a>..624 parts_to_body(BodyList, ContentType, Size) when is_list(BodyList) ->
</span><span class="marked"><a name="line625"></a>..625     %% return
</span><span class="marked"><a name="line626"></a>..626     %% header Content-Type: multipart/byteranges; boundary=441934886133bdee4
</span><span class="marked"><a name="line627"></a>..627     %% and multipart body
</span><span class="uncovered"><a name="line628"></a>..628     Boundary = mochihex:to_hex(crypto:rand_bytes(8)),
</span><span class="uncovered"><a name="line629"></a>..629     HeaderList = [{"Content-Type",
</span><span class="marked"><a name="line630"></a>..630                    ["multipart/byteranges; ",
</span><span class="marked"><a name="line631"></a>..631                     "boundary=", Boundary]}],
</span><span class="uncovered"><a name="line632"></a>..632     MultiPartBody = multipart_body(BodyList, ContentType, Boundary, Size),
</span><span class="marked"><a name="line633"></a>..633 
</span><span class="uncovered"><a name="line634"></a>..634     {HeaderList, MultiPartBody}.
</span><span class="marked"><a name="line635"></a>..635 
</span><span class="marked"><a name="line636"></a>..636 multipart_body([], _ContentType, Boundary, _Size) ->
</span><span class="uncovered"><a name="line637"></a>..637     ["--", Boundary, "--\r\n"];
</span><span class="marked"><a name="line638"></a>..638 multipart_body([{Start, End, Body} | BodyList], ContentType, Boundary, Size) ->
</span><span class="uncovered"><a name="line639"></a>..639     ["--", Boundary, "\r\n",
</span><span class="marked"><a name="line640"></a>..640      "Content-Type: ", ContentType, "\r\n",
</span><span class="marked"><a name="line641"></a>..641      "Content-Range: ",
</span><span class="marked"><a name="line642"></a>..642          "bytes ", make_io(Start), "-", make_io(End),
</span><span class="marked"><a name="line643"></a>..643              "/", make_io(Size), "\r\n\r\n",
</span><span class="marked"><a name="line644"></a>..644      Body, "\r\n"
</span><span class="marked"><a name="line645"></a>..645      | multipart_body(BodyList, ContentType, Boundary, Size)].
</span><span class="marked"><a name="line646"></a>..646 
</span><span class="marked"><a name="line647"></a>..647 iodevice_size(IoDevice) ->
</span><span class="uncovered"><a name="line648"></a>..648     {ok, Size} = file:position(IoDevice, eof),
</span><span class="uncovered"><a name="line649"></a>..649     {ok, 0} = file:position(IoDevice, bof),
</span><span class="uncovered"><a name="line650"></a>..650     Size.
</span><span class="marked"><a name="line651"></a>..651 
</span><span class="marked"><a name="line652"></a>..652 range_parts({file, IoDevice}, Ranges) ->
</span><span class="uncovered"><a name="line653"></a>..653     Size = iodevice_size(IoDevice),
</span><span class="uncovered"><a name="line654"></a>..654     F = fun (Spec, Acc) ->
</span><span class="uncovered"><a name="line655"></a>..655                 case range_skip_length(Spec, Size) of
</span><span class="marked"><a name="line656"></a>..656                     invalid_range ->
</span><span class="uncovered"><a name="line657"></a>..657                         Acc;
</span><span class="marked"><a name="line658"></a>..658                     V ->
</span><span class="uncovered"><a name="line659"></a>..659                         [V | Acc]
</span><span class="marked"><a name="line660"></a>..660                 end
</span><span class="marked"><a name="line661"></a>..661         end,
</span><span class="uncovered"><a name="line662"></a>..662     LocNums = lists:foldr(F, [], Ranges),
</span><span class="uncovered"><a name="line663"></a>..663     {ok, Data} = file:pread(IoDevice, LocNums),
</span><span class="uncovered"><a name="line664"></a>..664     Bodies = lists:zipwith(fun ({Skip, Length}, PartialBody) ->
</span><span class="uncovered"><a name="line665"></a>..665                                    {Skip, Skip + Length - 1, PartialBody}
</span><span class="marked"><a name="line666"></a>..666                            end,
</span><span class="marked"><a name="line667"></a>..667                            LocNums, Data),
</span><span class="uncovered"><a name="line668"></a>..668     {Bodies, Size};
</span><span class="marked"><a name="line669"></a>..669 
</span><span class="marked"><a name="line670"></a>..670 range_parts(Body0, Ranges) ->
</span><span class="uncovered"><a name="line671"></a>..671     Body = iolist_to_binary(Body0),
</span><span class="uncovered"><a name="line672"></a>..672     Size = size(Body),
</span><span class="uncovered"><a name="line673"></a>..673     F = fun(Spec, Acc) ->
</span><span class="uncovered"><a name="line674"></a>..674                 case range_skip_length(Spec, Size) of
</span><span class="marked"><a name="line675"></a>..675                     invalid_range ->
</span><span class="uncovered"><a name="line676"></a>..676                         Acc;
</span><span class="marked"><a name="line677"></a>..677                     {Skip, Length} ->
</span><span class="uncovered"><a name="line678"></a>..678                         <<_:Skip/binary, PartialBody:Length/binary, _/binary>> = Body,
</span><span class="uncovered"><a name="line679"></a>..679                         [{Skip, Skip + Length - 1, PartialBody} | Acc]
</span><span class="marked"><a name="line680"></a>..680                 end
</span><span class="marked"><a name="line681"></a>..681         end,
</span><span class="uncovered"><a name="line682"></a>..682     {lists:foldr(F, [], Ranges), Size}.
</span><span class="marked"><a name="line683"></a>..683 
</span><span class="marked"><a name="line684"></a>..684 range_skip_length(Spec, Size) ->
</span><span class="uncovered"><a name="line685"></a>..685     case Spec of
</span><span class="marked"><a name="line686"></a>..686         {none, R} when R =< Size, R >= 0 ->
</span><span class="uncovered"><a name="line687"></a>..687             {Size - R, R};
</span><span class="marked"><a name="line688"></a>..688         {none, _OutOfRange} ->
</span><span class="uncovered"><a name="line689"></a>..689             {0, Size};
</span><span class="marked"><a name="line690"></a>..690         {R, none} when R >= 0, R < Size ->
</span><span class="uncovered"><a name="line691"></a>..691             {R, Size - R};
</span><span class="marked"><a name="line692"></a>..692         {_OutOfRange, none} ->
</span><span class="uncovered"><a name="line693"></a>..693             invalid_range;
</span><span class="marked"><a name="line694"></a>..694         {Start, End} when 0 =< Start, Start =< End, End < Size ->
</span><span class="uncovered"><a name="line695"></a>..695             {Start, End - Start + 1};
</span><span class="marked"><a name="line696"></a>..696         {_OutOfRange, _End} ->
</span><span class="uncovered"><a name="line697"></a>..697             invalid_range
</span><span class="marked"><a name="line698"></a>..698     end.
</span><span class="marked"><a name="line699"></a>..699 
</span><span class="marked"><a name="line700"></a>..700 parse_range_request(RawRange) when is_list(RawRange) ->
</span><span class="uncovered"><a name="line701"></a>..701     try
</span><span class="marked"><a name="line702"></a>..702         "bytes=" ++ RangeString = RawRange,
</span><span class="marked"><a name="line703"></a>..703         Ranges = string:tokens(RangeString, ","),
</span><span class="marked"><a name="line704"></a>..704         lists:map(fun ("-" ++ V)  ->
</span><span class="uncovered"><a name="line705"></a>..705                           {none, list_to_integer(V)};
</span><span class="marked"><a name="line706"></a>..706                       (R) ->
</span><span class="uncovered"><a name="line707"></a>..707                           case string:tokens(R, "-") of
</span><span class="marked"><a name="line708"></a>..708                               [S1, S2] ->
</span><span class="uncovered"><a name="line709"></a>..709                                   {list_to_integer(S1), list_to_integer(S2)};
</span><span class="marked"><a name="line710"></a>..710                               [S] ->
</span><span class="uncovered"><a name="line711"></a>..711                                   {list_to_integer(S), none}
</span><span class="marked"><a name="line712"></a>..712                           end
</span><span class="marked"><a name="line713"></a>..713                   end,
</span><span class="marked"><a name="line714"></a>..714                   Ranges)
</span><span class="marked"><a name="line715"></a>..715     catch
</span><span class="marked"><a name="line716"></a>..716         _:_ ->
</span><span class="uncovered"><a name="line717"></a>..717             fail
</span><span class="marked"><a name="line718"></a>..718     end.
</span><span class="marked"><a name="line719"></a>..719 
</span><span class="marked"><a name="line720"></a>..720 
</span><span class="marked"><a name="line721"></a>..721 test() ->
</span><span class="uncovered"><a name="line722"></a>..722     ok = test_range(),
</span><span class="uncovered"><a name="line723"></a>..723     ok.
</span><span class="marked"><a name="line724"></a>..724 
</span><span class="marked"><a name="line725"></a>..725 test_range() ->
</span><span class="marked"><a name="line726"></a>..726     %% valid, single ranges
</span><span class="uncovered"><a name="line727"></a>..727     io:format("Testing parse_range_request with valid single ranges~n"),
</span><span class="uncovered"><a name="line728"></a>..728     io:format("1"),
</span><span class="uncovered"><a name="line729"></a>..729     [{20, 30}] = parse_range_request("bytes=20-30"),
</span><span class="uncovered"><a name="line730"></a>..730     io:format("2"),
</span><span class="uncovered"><a name="line731"></a>..731     [{20, none}] = parse_range_request("bytes=20-"),
</span><span class="uncovered"><a name="line732"></a>..732     io:format("3"),
</span><span class="uncovered"><a name="line733"></a>..733     [{none, 20}] = parse_range_request("bytes=-20"),
</span><span class="uncovered"><a name="line734"></a>..734     io:format(".. ok ~n"),
</span><span class="marked"><a name="line735"></a>..735 
</span><span class="marked"><a name="line736"></a>..736 
</span><span class="marked"><a name="line737"></a>..737     %% invalid, single ranges
</span><span class="uncovered"><a name="line738"></a>..738     io:format("Testing parse_range_request with invalid ranges~n"),
</span><span class="uncovered"><a name="line739"></a>..739     io:format("1"),
</span><span class="uncovered"><a name="line740"></a>..740     fail = parse_range_request(""),
</span><span class="uncovered"><a name="line741"></a>..741     io:format("2"),
</span><span class="uncovered"><a name="line742"></a>..742     fail = parse_range_request("garbage"),
</span><span class="uncovered"><a name="line743"></a>..743     io:format("3"),
</span><span class="uncovered"><a name="line744"></a>..744     fail = parse_range_request("bytes=-20-30"),
</span><span class="uncovered"><a name="line745"></a>..745     io:format(".. ok ~n"),
</span><span class="marked"><a name="line746"></a>..746 
</span><span class="marked"><a name="line747"></a>..747     %% valid, multiple range
</span><span class="uncovered"><a name="line748"></a>..748     io:format("Testing parse_range_request with valid multiple ranges~n"),
</span><span class="uncovered"><a name="line749"></a>..749     io:format("1"),
</span><span class="uncovered"><a name="line750"></a>..750     [{20, 30}, {50, 100}, {110, 200}] = 
</span><span class="marked"><a name="line751"></a>..751         parse_range_request("bytes=20-30,50-100,110-200"),
</span><span class="uncovered"><a name="line752"></a>..752     io:format("2"),
</span><span class="uncovered"><a name="line753"></a>..753     [{20, none}, {50, 100}, {none, 200}] = 
</span><span class="marked"><a name="line754"></a>..754         parse_range_request("bytes=20-,50-100,-200"),
</span><span class="uncovered"><a name="line755"></a>..755     io:format(".. ok~n"),
</span><span class="marked"><a name="line756"></a>..756     
</span><span class="marked"><a name="line757"></a>..757     %% no ranges
</span><span class="uncovered"><a name="line758"></a>..758     io:format("Testing out parse_range_request with no ranges~n"),
</span><span class="uncovered"><a name="line759"></a>..759     io:format("1"),
</span><span class="uncovered"><a name="line760"></a>..760     [] = parse_range_request("bytes="),
</span><span class="uncovered"><a name="line761"></a>..761     io:format(".. ok~n"),
</span><span class="marked"><a name="line762"></a>..762     
</span><span class="uncovered"><a name="line763"></a>..763     Body = <<"012345678901234567890123456789012345678901234567890123456789">>,
</span><span class="uncovered"><a name="line764"></a>..764     BodySize = size(Body), %% 60
</span><span class="uncovered"><a name="line765"></a>..765     BodySize = 60,
</span><span class="marked"><a name="line766"></a>..766 
</span><span class="marked"><a name="line767"></a>..767     %% these values assume BodySize =:= 60
</span><span class="uncovered"><a name="line768"></a>..768     io:format("Testing out range_skip_length on valid ranges~n"),
</span><span class="uncovered"><a name="line769"></a>..769     io:format("1"),
</span><span class="uncovered"><a name="line770"></a>..770     {1,9} = range_skip_length({1,9}, BodySize), %% 1-9
</span><span class="uncovered"><a name="line771"></a>..771     io:format("2"),
</span><span class="uncovered"><a name="line772"></a>..772     {10,10} = range_skip_length({10,19}, BodySize), %% 10-19
</span><span class="uncovered"><a name="line773"></a>..773     io:format("3"),
</span><span class="uncovered"><a name="line774"></a>..774     {40, 20} = range_skip_length({none, 20}, BodySize), %% -20
</span><span class="uncovered"><a name="line775"></a>..775     io:format("4"),
</span><span class="uncovered"><a name="line776"></a>..776     {30, 30} = range_skip_length({30, none}, BodySize), %% 30-
</span><span class="uncovered"><a name="line777"></a>..777     io:format(".. ok ~n"),
</span><span class="marked"><a name="line778"></a>..778     
</span><span class="marked"><a name="line779"></a>..779     %% valid edge cases for range_skip_length
</span><span class="uncovered"><a name="line780"></a>..780     io:format("Testing out range_skip_length on valid edge case ranges~n"),
</span><span class="uncovered"><a name="line781"></a>..781     io:format("1"),
</span><span class="uncovered"><a name="line782"></a>..782     {BodySize, 0} = range_skip_length({none, 0}, BodySize),
</span><span class="uncovered"><a name="line783"></a>..783     io:format("2"),
</span><span class="uncovered"><a name="line784"></a>..784     {0, BodySize} = range_skip_length({none, BodySize}, BodySize),
</span><span class="uncovered"><a name="line785"></a>..785     io:format("3"),
</span><span class="uncovered"><a name="line786"></a>..786     {0, BodySize} = range_skip_length({0, none}, BodySize),
</span><span class="uncovered"><a name="line787"></a>..787     BodySizeLess1 = BodySize - 1,
</span><span class="uncovered"><a name="line788"></a>..788     io:format("4"),
</span><span class="uncovered"><a name="line789"></a>..789     {BodySizeLess1, 1} = range_skip_length({BodySize - 1, none}, BodySize),
</span><span class="marked"><a name="line790"></a>..790 
</span><span class="marked"><a name="line791"></a>..791     %% out of range, return whole thing
</span><span class="uncovered"><a name="line792"></a>..792     io:format("5"),
</span><span class="uncovered"><a name="line793"></a>..793     {0, BodySize} = range_skip_length({none, BodySize + 1}, BodySize),
</span><span class="uncovered"><a name="line794"></a>..794     io:format("6"),
</span><span class="uncovered"><a name="line795"></a>..795     {0, BodySize} = range_skip_length({none, -1}, BodySize),
</span><span class="uncovered"><a name="line796"></a>..796     io:format(".. ok ~n"),
</span><span class="marked"><a name="line797"></a>..797 
</span><span class="marked"><a name="line798"></a>..798     %% invalid ranges
</span><span class="uncovered"><a name="line799"></a>..799     io:format("Testing out range_skip_length on invalid ranges~n"),
</span><span class="uncovered"><a name="line800"></a>..800     io:format("1"),
</span><span class="uncovered"><a name="line801"></a>..801     invalid_range = range_skip_length({-1, 30}, BodySize),
</span><span class="uncovered"><a name="line802"></a>..802     io:format("2"),
</span><span class="uncovered"><a name="line803"></a>..803     invalid_range = range_skip_length({0, BodySize + 1}, BodySize),
</span><span class="uncovered"><a name="line804"></a>..804     io:format("3"),
</span><span class="uncovered"><a name="line805"></a>..805     invalid_range = range_skip_length({-1, BodySize + 1}, BodySize),
</span><span class="uncovered"><a name="line806"></a>..806     io:format("4"),
</span><span class="uncovered"><a name="line807"></a>..807     invalid_range = range_skip_length({BodySize, 40}, BodySize),
</span><span class="uncovered"><a name="line808"></a>..808     io:format("5"),
</span><span class="uncovered"><a name="line809"></a>..809     invalid_range = range_skip_length({-1, none}, BodySize),
</span><span class="uncovered"><a name="line810"></a>..810     io:format("6"),
</span><span class="uncovered"><a name="line811"></a>..811     invalid_range = range_skip_length({BodySize, none}, BodySize),
</span><span class="uncovered"><a name="line812"></a>..812     io:format(".. ok ~n"),
</span><span class="uncovered"><a name="line813"></a>..813     ok.
</span><span class="marked"><a name="line814"></a>..814     
</span></pre><hr /><p>Generated using <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.</p>
          </body>
        </html>
    