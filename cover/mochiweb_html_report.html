<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
          <head>
            <title>mochiweb_html - C0 code coverage information</title>
            <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
            <style type='text/css'>span.marked0 {
     background-color: rgb(185, 210, 200);
     display: block;
    }
    span.marked { display: block; background-color: #ffffff; }
    span.highlight { display: block; background-color: #fff9d7; }
    span.covered { display: block; background-color: #f7f7f7 ; }
    span.uncovered { display: block; background-color: #ffebe8 ; }
    span.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    div.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    body {
     font-family: verdana, arial, helvetica;
    }
    div.footer {
     font-size: 68%;
     margin-top: 1.5em;
    }
    h1, h2, h3, h4, h5, h6 {
     margin-bottom: 0.5em;
    }
    h5 {
     margin-top: 0.5em;
    }
    .hidden {
     display: none;
    }
    div.separator {
     height: 10px;
    }
    table.percent_graph {
     height: 12px;
     border: 1px solid #E2E6EF; 
     empty-cells: show;
    }
    table.percent_graph td.covered {
     height: 10px;
     background: #00f000;
    }
    table.percent_graph td.uncovered {
     height: 10px;
     background: #e00000;
    }
    table.percent_graph td.NA {
     height: 10px;
     background: #eaeaea;
    }
    table.report {
     border-collapse: collapse;
     width: 100%;
    }
    table.report td.heading {
     background: #dcecff;
     border: 1px solid #E2E6EF; 
     font-weight: bold;
     text-align: center;
    }
    table.report td.heading:hover {
     background: #c0ffc0;
    }
    table.report td.text {
     border: 1px solid #E2E6EF; 
    }
    table.report td.value {
     text-align: right;
     border: 1px solid #E2E6EF; 
    }
    table.report tr.light {
     background-color: rgb(240, 240, 245);
    }
    table.report tr.dark {
     background-color: rgb(230, 230, 235);
    }
    </style>
          </head>
          <body>
            <h3>C0 code coverage information</h3>
            <p>Generated on 2009-02-25 00:22:45 with <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.
            </p>            
        <table class='report'>
          <thead>
            <tr>
              <td class='heading'>Name</td>
              <td class='heading'>Total lines</td>
              <td class='heading'>Lines of code</td>
              <td class='heading'>Total coverage</td>
              <td class='heading'>Code coverage</td>
            </tr>
          </thead>
          <tbody>
            <tr class='light'>

              <td>
                <a href='mochiweb_html_report.html'>mochiweb_html</a>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td>
                <table cellspacing='0' cellpadding='0' align='right'>
                  <tr>
                    <td><tt>0%</tt>&nbsp;</td><td>
                      <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                      <tr><td class='covered' width='0' /><td class='uncovered' width='100' /></tr>
                      </table>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </tbody>
        </table><pre><span class="marked"><a name="line1"></a>....1 %% @author Bob Ippolito <bob@mochimedia.com>
</span><span class="marked"><a name="line2"></a>....2 %% @copyright 2007 Mochi Media, Inc.
</span><span class="marked"><a name="line3"></a>....3 
</span><span class="marked"><a name="line4"></a>....4 %% @doc Loosely tokenizes and generates parse trees for HTML 4.
</span><span class="marked"><a name="line5"></a>....5 -module(mochiweb_html).
</span><span class="marked"><a name="line6"></a>....6 -export([tokens/1, parse/1, parse_tokens/1, to_tokens/1, escape/1,
</span><span class="marked"><a name="line7"></a>....7          escape_attr/1, to_html/1, test/0]).
</span><span class="marked"><a name="line8"></a>....8 
</span><span class="marked"><a name="line9"></a>....9 % This is a macro to placate syntax highlighters..
</span><span class="marked"><a name="line10"></a>...10 -define(QUOTE, $\").
</span><span class="marked"><a name="line11"></a>...11 -define(SQUOTE, $\').
</span><span class="marked"><a name="line12"></a>...12 -define(ADV_COL(S, N),
</span><span class="marked"><a name="line13"></a>...13         S#decoder{column=N+S#decoder.column,
</span><span class="marked"><a name="line14"></a>...14                   offset=N+S#decoder.offset}).
</span><span class="marked"><a name="line15"></a>...15 -define(INC_COL(S),
</span><span class="marked"><a name="line16"></a>...16         S#decoder{column=1+S#decoder.column,
</span><span class="marked"><a name="line17"></a>...17                   offset=1+S#decoder.offset}).
</span><span class="marked"><a name="line18"></a>...18 -define(INC_LINE(S),
</span><span class="marked"><a name="line19"></a>...19         S#decoder{column=1,
</span><span class="marked"><a name="line20"></a>...20                   line=1+S#decoder.line,
</span><span class="marked"><a name="line21"></a>...21                   offset=1+S#decoder.offset}).
</span><span class="marked"><a name="line22"></a>...22 -define(INC_CHAR(S, C),
</span><span class="marked"><a name="line23"></a>...23         case C of
</span><span class="marked"><a name="line24"></a>...24             $\n ->
</span><span class="marked"><a name="line25"></a>...25                 S#decoder{column=1,
</span><span class="marked"><a name="line26"></a>...26                           line=1+S#decoder.line,
</span><span class="marked"><a name="line27"></a>...27                           offset=1+S#decoder.offset};
</span><span class="marked"><a name="line28"></a>...28             _ ->
</span><span class="marked"><a name="line29"></a>...29                 S#decoder{column=1+S#decoder.column,
</span><span class="marked"><a name="line30"></a>...30                           offset=1+S#decoder.offset}
</span><span class="marked"><a name="line31"></a>...31         end).
</span><span class="marked"><a name="line32"></a>...32 
</span><span class="marked"><a name="line33"></a>...33 -define(IS_WHITESPACE(C),
</span><span class="marked"><a name="line34"></a>...34         (C =:= $\s orelse C =:= $\t orelse C =:= $\r orelse C =:= $\n)).
</span><span class="marked"><a name="line35"></a>...35 -define(IS_LITERAL_SAFE(C),
</span><span class="marked"><a name="line36"></a>...36         ((C >= $A andalso C =< $Z) orelse (C >= $a andalso C =< $z)
</span><span class="marked"><a name="line37"></a>...37          orelse (C >= $0 andalso C =< $9))).
</span><span class="marked"><a name="line38"></a>...38 
</span><span class="marked"><a name="line39"></a>...39 -record(decoder, {line=1,
</span><span class="marked"><a name="line40"></a>...40                   column=1,
</span><span class="marked"><a name="line41"></a>...41                   offset=0}).
</span><span class="marked"><a name="line42"></a>...42 
</span><span class="marked"><a name="line43"></a>...43 %% @type html_node() = {string(), [html_attr()], [html_node() | string()]}
</span><span class="marked"><a name="line44"></a>...44 %% @type html_attr() = {string(), string()}
</span><span class="marked"><a name="line45"></a>...45 %% @type html_token() = html_data() | start_tag() | end_tag() | inline_html() | html_comment() | html_doctype()
</span><span class="marked"><a name="line46"></a>...46 %% @type html_data() = {data, string(), Whitespace::boolean()}
</span><span class="marked"><a name="line47"></a>...47 %% @type start_tag() = {start_tag, Name, [html_attr()], Singleton::boolean()}
</span><span class="marked"><a name="line48"></a>...48 %% @type end_tag() = {end_tag, Name}
</span><span class="marked"><a name="line49"></a>...49 %% @type html_comment() = {comment, Comment}
</span><span class="marked"><a name="line50"></a>...50 %% @type html_doctype() = {doctype, [Doctype]}
</span><span class="marked"><a name="line51"></a>...51 %% @type inline_html() = {'=', iolist()}
</span><span class="marked"><a name="line52"></a>...52 
</span><span class="marked"><a name="line53"></a>...53 %% External API.
</span><span class="marked"><a name="line54"></a>...54 
</span><span class="marked"><a name="line55"></a>...55 %% @spec parse(string() | binary()) -> html_node()
</span><span class="marked"><a name="line56"></a>...56 %% @doc tokenize and then transform the token stream into a HTML tree.
</span><span class="marked"><a name="line57"></a>...57 parse(Input) ->
</span><span class="uncovered"><a name="line58"></a>...58     parse_tokens(tokens(Input)).
</span><span class="marked"><a name="line59"></a>...59 
</span><span class="marked"><a name="line60"></a>...60 %% @spec parse_tokens([html_token()]) -> html_node()
</span><span class="marked"><a name="line61"></a>...61 %% @doc Transform the output of tokens(Doc) into a HTML tree.
</span><span class="marked"><a name="line62"></a>...62 parse_tokens(Tokens) when is_list(Tokens) ->
</span><span class="marked"><a name="line63"></a>...63     %% Skip over doctype, processing instructions
</span><span class="uncovered"><a name="line64"></a>...64     F = fun (X) ->
</span><span class="uncovered"><a name="line65"></a>...65                 case X of
</span><span class="marked"><a name="line66"></a>...66                     {start_tag, _, _, false} ->
</span><span class="uncovered"><a name="line67"></a>...67                         false;
</span><span class="marked"><a name="line68"></a>...68                     _ ->
</span><span class="uncovered"><a name="line69"></a>...69                         true
</span><span class="marked"><a name="line70"></a>...70                 end
</span><span class="marked"><a name="line71"></a>...71         end,
</span><span class="uncovered"><a name="line72"></a>...72     [{start_tag, Tag, Attrs, false} | Rest] = lists:dropwhile(F, Tokens),
</span><span class="uncovered"><a name="line73"></a>...73     {Tree, _} = tree(Rest, [norm({Tag, Attrs})]),
</span><span class="uncovered"><a name="line74"></a>...74     Tree.
</span><span class="marked"><a name="line75"></a>...75 
</span><span class="marked"><a name="line76"></a>...76 %% @spec tokens(StringOrBinary) -> [html_token()]
</span><span class="marked"><a name="line77"></a>...77 %% @doc Transform the input UTF-8 HTML into a token stream.
</span><span class="marked"><a name="line78"></a>...78 tokens(Input) ->
</span><span class="uncovered"><a name="line79"></a>...79     tokens(iolist_to_binary(Input), #decoder{}, []).
</span><span class="marked"><a name="line80"></a>...80 
</span><span class="marked"><a name="line81"></a>...81 %% @spec to_tokens(html_node()) -> [html_token()]
</span><span class="marked"><a name="line82"></a>...82 %% @doc Convert a html_node() tree to a list of tokens.
</span><span class="marked"><a name="line83"></a>...83 to_tokens({Tag0}) ->
</span><span class="uncovered"><a name="line84"></a>...84     to_tokens({Tag0, [], []});
</span><span class="marked"><a name="line85"></a>...85 to_tokens(T={'=', _}) ->
</span><span class="uncovered"><a name="line86"></a>...86     [T];
</span><span class="marked"><a name="line87"></a>...87 to_tokens(T={doctype, _}) ->
</span><span class="uncovered"><a name="line88"></a>...88     [T];
</span><span class="marked"><a name="line89"></a>...89 to_tokens(T={comment, _}) ->
</span><span class="uncovered"><a name="line90"></a>...90     [T];
</span><span class="marked"><a name="line91"></a>...91 to_tokens({Tag0, Acc}) ->
</span><span class="uncovered"><a name="line92"></a>...92     to_tokens({Tag0, [], Acc});
</span><span class="marked"><a name="line93"></a>...93 to_tokens({Tag0, Attrs, Acc}) ->
</span><span class="uncovered"><a name="line94"></a>...94     Tag = to_tag(Tag0),
</span><span class="uncovered"><a name="line95"></a>...95     to_tokens([{Tag, Acc}], [{start_tag, Tag, Attrs, is_singleton(Tag)}]).
</span><span class="marked"><a name="line96"></a>...96 
</span><span class="marked"><a name="line97"></a>...97 %% @spec to_html([html_token()] | html_node()) -> iolist()
</span><span class="marked"><a name="line98"></a>...98 %% @doc Convert a list of html_token() to a HTML document.
</span><span class="marked"><a name="line99"></a>...99 to_html(Node) when is_tuple(Node) ->
</span><span class="uncovered"><a name="line100"></a>..100     to_html(to_tokens(Node));
</span><span class="marked"><a name="line101"></a>..101 to_html(Tokens) when is_list(Tokens) ->
</span><span class="uncovered"><a name="line102"></a>..102     to_html(Tokens, []).
</span><span class="marked"><a name="line103"></a>..103 
</span><span class="marked"><a name="line104"></a>..104 %% @spec escape(string() | atom() | binary()) -> binary()
</span><span class="marked"><a name="line105"></a>..105 %% @doc Escape a string such that it's safe for HTML (amp; lt; gt;).
</span><span class="marked"><a name="line106"></a>..106 escape(B) when is_binary(B) ->
</span><span class="uncovered"><a name="line107"></a>..107     escape(binary_to_list(B), []);
</span><span class="marked"><a name="line108"></a>..108 escape(A) when is_atom(A) ->
</span><span class="uncovered"><a name="line109"></a>..109     escape(atom_to_list(A), []);
</span><span class="marked"><a name="line110"></a>..110 escape(S) when is_list(S) ->
</span><span class="uncovered"><a name="line111"></a>..111     escape(S, []).
</span><span class="marked"><a name="line112"></a>..112 
</span><span class="marked"><a name="line113"></a>..113 %% @spec escape_attr(string() | binary() | atom() | integer() | float()) -> binary()
</span><span class="marked"><a name="line114"></a>..114 %% @doc Escape a string such that it's safe for HTML attrs
</span><span class="marked"><a name="line115"></a>..115 %%      (amp; lt; gt; quot;).
</span><span class="marked"><a name="line116"></a>..116 escape_attr(B) when is_binary(B) ->
</span><span class="uncovered"><a name="line117"></a>..117     escape_attr(binary_to_list(B), []);
</span><span class="marked"><a name="line118"></a>..118 escape_attr(A) when is_atom(A) ->
</span><span class="uncovered"><a name="line119"></a>..119     escape_attr(atom_to_list(A), []);
</span><span class="marked"><a name="line120"></a>..120 escape_attr(S) when is_list(S) ->
</span><span class="uncovered"><a name="line121"></a>..121     escape_attr(S, []);
</span><span class="marked"><a name="line122"></a>..122 escape_attr(I) when is_integer(I) ->
</span><span class="uncovered"><a name="line123"></a>..123     escape_attr(integer_to_list(I), []);
</span><span class="marked"><a name="line124"></a>..124 escape_attr(F) when is_float(F) ->
</span><span class="uncovered"><a name="line125"></a>..125     escape_attr(mochinum:digits(F), []).
</span><span class="marked"><a name="line126"></a>..126 
</span><span class="marked"><a name="line127"></a>..127 %% @spec test() -> ok
</span><span class="marked"><a name="line128"></a>..128 %% @doc Run tests for mochiweb_html.
</span><span class="marked"><a name="line129"></a>..129 test() ->
</span><span class="uncovered"><a name="line130"></a>..130     test_destack(),
</span><span class="uncovered"><a name="line131"></a>..131     test_tokens(),
</span><span class="uncovered"><a name="line132"></a>..132     test_tokens2(),
</span><span class="uncovered"><a name="line133"></a>..133     test_parse(),
</span><span class="uncovered"><a name="line134"></a>..134     test_parse2(),
</span><span class="uncovered"><a name="line135"></a>..135     test_parse_tokens(),
</span><span class="uncovered"><a name="line136"></a>..136     test_escape(),
</span><span class="uncovered"><a name="line137"></a>..137     test_escape_attr(),
</span><span class="uncovered"><a name="line138"></a>..138     test_to_html(),
</span><span class="uncovered"><a name="line139"></a>..139     ok.
</span><span class="marked"><a name="line140"></a>..140 
</span><span class="marked"><a name="line141"></a>..141 
</span><span class="marked"><a name="line142"></a>..142 %% Internal API
</span><span class="marked"><a name="line143"></a>..143 
</span><span class="marked"><a name="line144"></a>..144 test_to_html() ->
</span><span class="uncovered"><a name="line145"></a>..145     Expect = <<"<html><head><title>hey!</title></head><body><p class=\"foo\">what's up<br /></p><div>sucka</div><!-- comment! --></body></html>">>,
</span><span class="uncovered"><a name="line146"></a>..146     Expect = iolist_to_binary(
</span><span class="marked"><a name="line147"></a>..147                to_html({html, [],
</span><span class="marked"><a name="line148"></a>..148                         [{<<"head">>, [],
</span><span class="marked"><a name="line149"></a>..149                           [{title, <<"hey!">>}]},
</span><span class="marked"><a name="line150"></a>..150                          {body, [],
</span><span class="marked"><a name="line151"></a>..151                           [{p, [{class, foo}], [<<"what's">>, <<" up">>, {br}]},
</span><span class="marked"><a name="line152"></a>..152                            {'div', <<"sucka">>},
</span><span class="marked"><a name="line153"></a>..153                            {comment, <<" comment! ">>}]}]})),
</span><span class="uncovered"><a name="line154"></a>..154     Expect1 = <<"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">">>,
</span><span class="uncovered"><a name="line155"></a>..155     Expect1 = iolist_to_binary(
</span><span class="marked"><a name="line156"></a>..156                 to_html({doctype,
</span><span class="marked"><a name="line157"></a>..157                          [<<"html">>, <<"PUBLIC">>,
</span><span class="marked"><a name="line158"></a>..158                           <<"-//W3C//DTD XHTML 1.0 Transitional//EN">>,
</span><span class="marked"><a name="line159"></a>..159                           <<"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">>]})),
</span><span class="uncovered"><a name="line160"></a>..160     ok.
</span><span class="marked"><a name="line161"></a>..161 to_html([], Acc) ->
</span><span class="uncovered"><a name="line162"></a>..162     lists:reverse(Acc);
</span><span class="marked"><a name="line163"></a>..163 to_html([{'=', Content} | Rest], Acc) ->
</span><span class="uncovered"><a name="line164"></a>..164     to_html(Rest, [Content | Acc]);
</span><span class="marked"><a name="line165"></a>..165 to_html([{pi, Tag, Attrs} | Rest], Acc) ->
</span><span class="uncovered"><a name="line166"></a>..166     Open = [<<"<?">>,
</span><span class="marked"><a name="line167"></a>..167             Tag,
</span><span class="marked"><a name="line168"></a>..168             attrs_to_html(Attrs, []),
</span><span class="marked"><a name="line169"></a>..169             <<"?>">>],
</span><span class="uncovered"><a name="line170"></a>..170     to_html(Rest, [Open | Acc]);
</span><span class="marked"><a name="line171"></a>..171 to_html([{comment, Comment} | Rest], Acc) ->
</span><span class="uncovered"><a name="line172"></a>..172     to_html(Rest, [[<<"<!--">>, Comment, <<"-->">>] | Acc]);
</span><span class="marked"><a name="line173"></a>..173 to_html([{doctype, Parts} | Rest], Acc) ->
</span><span class="uncovered"><a name="line174"></a>..174     Inside = doctype_to_html(Parts, Acc),
</span><span class="uncovered"><a name="line175"></a>..175     to_html(Rest, [[<<"<!DOCTYPE">>, Inside, <<">">>] | Acc]);
</span><span class="marked"><a name="line176"></a>..176 to_html([{data, Data, _Whitespace} | Rest], Acc) ->
</span><span class="uncovered"><a name="line177"></a>..177     to_html(Rest, [escape(Data) | Acc]);
</span><span class="marked"><a name="line178"></a>..178 to_html([{start_tag, Tag, Attrs, Singleton} | Rest], Acc) ->
</span><span class="uncovered"><a name="line179"></a>..179     Open = [<<"<">>,
</span><span class="marked"><a name="line180"></a>..180             Tag,
</span><span class="marked"><a name="line181"></a>..181             attrs_to_html(Attrs, []),
</span><span class="marked"><a name="line182"></a>..182             case Singleton of
</span><span class="uncovered"><a name="line183"></a>..183                 true -> <<" />">>;
</span><span class="uncovered"><a name="line184"></a>..184                 false -> <<">">>
</span><span class="marked"><a name="line185"></a>..185             end],
</span><span class="uncovered"><a name="line186"></a>..186     to_html(Rest, [Open | Acc]);
</span><span class="marked"><a name="line187"></a>..187 to_html([{end_tag, Tag} | Rest], Acc) ->
</span><span class="uncovered"><a name="line188"></a>..188     to_html(Rest, [[<<"</">>, Tag, <<">">>] | Acc]).
</span><span class="marked"><a name="line189"></a>..189 
</span><span class="marked"><a name="line190"></a>..190 doctype_to_html([], Acc) ->
</span><span class="uncovered"><a name="line191"></a>..191     lists:reverse(Acc);
</span><span class="marked"><a name="line192"></a>..192 doctype_to_html([Word | Rest], Acc) ->
</span><span class="uncovered"><a name="line193"></a>..193     case lists:all(fun (C) -> ?IS_LITERAL_SAFE(C) end,
</span><span class="marked"><a name="line194"></a>..194                    binary_to_list(iolist_to_binary(Word))) of
</span><span class="marked"><a name="line195"></a>..195         true ->
</span><span class="uncovered"><a name="line196"></a>..196             doctype_to_html(Rest, [[<<" ">>, Word] | Acc]);
</span><span class="marked"><a name="line197"></a>..197         false ->
</span><span class="uncovered"><a name="line198"></a>..198             doctype_to_html(Rest, [[<<" \"">>, escape_attr(Word), ?QUOTE] | Acc])
</span><span class="marked"><a name="line199"></a>..199     end.
</span><span class="marked"><a name="line200"></a>..200 
</span><span class="marked"><a name="line201"></a>..201 attrs_to_html([], Acc) ->
</span><span class="uncovered"><a name="line202"></a>..202     lists:reverse(Acc);
</span><span class="marked"><a name="line203"></a>..203 attrs_to_html([{K, V} | Rest], Acc) ->
</span><span class="uncovered"><a name="line204"></a>..204     attrs_to_html(Rest,
</span><span class="marked"><a name="line205"></a>..205                   [[<<" ">>, escape(K), <<"=\"">>,
</span><span class="marked"><a name="line206"></a>..206                     escape_attr(V), <<"\"">>] | Acc]).
</span><span class="marked"><a name="line207"></a>..207 
</span><span class="marked"><a name="line208"></a>..208 test_escape() ->
</span><span class="uncovered"><a name="line209"></a>..209     <<"&amp;quot;\"word &lt;&lt;up!&amp;quot;">> =
</span><span class="marked"><a name="line210"></a>..210         escape(<<"&quot;\"word <<up!&quot;">>),
</span><span class="uncovered"><a name="line211"></a>..211     ok.
</span><span class="marked"><a name="line212"></a>..212 
</span><span class="marked"><a name="line213"></a>..213 test_escape_attr() ->
</span><span class="uncovered"><a name="line214"></a>..214     <<"&amp;quot;&quot;word &lt;&lt;up!&amp;quot;">> =
</span><span class="marked"><a name="line215"></a>..215         escape_attr(<<"&quot;\"word <<up!&quot;">>),
</span><span class="uncovered"><a name="line216"></a>..216     ok.
</span><span class="marked"><a name="line217"></a>..217 
</span><span class="marked"><a name="line218"></a>..218 escape([], Acc) ->
</span><span class="uncovered"><a name="line219"></a>..219     list_to_binary(lists:reverse(Acc));
</span><span class="marked"><a name="line220"></a>..220 escape("<" ++ Rest, Acc) ->
</span><span class="uncovered"><a name="line221"></a>..221     escape(Rest, lists:reverse("&lt;", Acc));
</span><span class="marked"><a name="line222"></a>..222 escape(">" ++ Rest, Acc) ->
</span><span class="uncovered"><a name="line223"></a>..223     escape(Rest, lists:reverse("&gt;", Acc));
</span><span class="marked"><a name="line224"></a>..224 escape("&" ++ Rest, Acc) ->
</span><span class="uncovered"><a name="line225"></a>..225     escape(Rest, lists:reverse("&amp;", Acc));
</span><span class="marked"><a name="line226"></a>..226 escape([C | Rest], Acc) ->
</span><span class="uncovered"><a name="line227"></a>..227     escape(Rest, [C | Acc]).
</span><span class="marked"><a name="line228"></a>..228 
</span><span class="marked"><a name="line229"></a>..229 escape_attr([], Acc) ->
</span><span class="uncovered"><a name="line230"></a>..230     list_to_binary(lists:reverse(Acc));
</span><span class="marked"><a name="line231"></a>..231 escape_attr("<" ++ Rest, Acc) ->
</span><span class="uncovered"><a name="line232"></a>..232     escape_attr(Rest, lists:reverse("&lt;", Acc));
</span><span class="marked"><a name="line233"></a>..233 escape_attr(">" ++ Rest, Acc) ->
</span><span class="uncovered"><a name="line234"></a>..234     escape_attr(Rest, lists:reverse("&gt;", Acc));
</span><span class="marked"><a name="line235"></a>..235 escape_attr("&" ++ Rest, Acc) ->
</span><span class="uncovered"><a name="line236"></a>..236     escape_attr(Rest, lists:reverse("&amp;", Acc));
</span><span class="marked"><a name="line237"></a>..237 escape_attr([?QUOTE | Rest], Acc) ->
</span><span class="uncovered"><a name="line238"></a>..238     escape_attr(Rest, lists:reverse("&quot;", Acc));
</span><span class="marked"><a name="line239"></a>..239 escape_attr([C | Rest], Acc) ->
</span><span class="uncovered"><a name="line240"></a>..240     escape_attr(Rest, [C | Acc]).
</span><span class="marked"><a name="line241"></a>..241 
</span><span class="marked"><a name="line242"></a>..242 to_tag(A) when is_atom(A) ->
</span><span class="uncovered"><a name="line243"></a>..243     norm(atom_to_list(A));
</span><span class="marked"><a name="line244"></a>..244 to_tag(L) ->
</span><span class="uncovered"><a name="line245"></a>..245     norm(L).
</span><span class="marked"><a name="line246"></a>..246 
</span><span class="marked"><a name="line247"></a>..247 to_tokens([], Acc) ->
</span><span class="uncovered"><a name="line248"></a>..248     lists:reverse(Acc);
</span><span class="marked"><a name="line249"></a>..249 to_tokens([{Tag, []} | Rest], Acc) ->
</span><span class="uncovered"><a name="line250"></a>..250     to_tokens(Rest, [{end_tag, to_tag(Tag)} | Acc]);
</span><span class="marked"><a name="line251"></a>..251 to_tokens([{Tag0, [{T0} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line252"></a>..252     %% Allow {br}
</span><span class="uncovered"><a name="line253"></a>..253     to_tokens([{Tag0, [{T0, [], []} | R1]} | Rest], Acc);
</span><span class="marked"><a name="line254"></a>..254 to_tokens([{Tag0, [T0={'=', _C0} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line255"></a>..255     %% Allow {'=', iolist()}
</span><span class="uncovered"><a name="line256"></a>..256     to_tokens([{Tag0, R1} | Rest], [T0 | Acc]);
</span><span class="marked"><a name="line257"></a>..257 to_tokens([{Tag0, [T0={comment, _C0} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line258"></a>..258     %% Allow {comment, iolist()}
</span><span class="uncovered"><a name="line259"></a>..259     to_tokens([{Tag0, R1} | Rest], [T0 | Acc]);
</span><span class="marked"><a name="line260"></a>..260 to_tokens([{Tag0, [{T0, A0=[{_, _} | _]} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line261"></a>..261     %% Allow {p, [{"class", "foo"}]}
</span><span class="uncovered"><a name="line262"></a>..262     to_tokens([{Tag0, [{T0, A0, []} | R1]} | Rest], Acc);
</span><span class="marked"><a name="line263"></a>..263 to_tokens([{Tag0, [{T0, C0} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line264"></a>..264     %% Allow {p, "content"} and {p, <<"content">>}
</span><span class="uncovered"><a name="line265"></a>..265     to_tokens([{Tag0, [{T0, [], C0} | R1]} | Rest], Acc);
</span><span class="marked"><a name="line266"></a>..266 to_tokens([{Tag0, [{T0, A1, C0} | R1]} | Rest], Acc) when is_binary(C0) ->
</span><span class="marked"><a name="line267"></a>..267     %% Allow {"p", [{"class", "foo"}], <<"content">>}
</span><span class="uncovered"><a name="line268"></a>..268     to_tokens([{Tag0, [{T0, A1, binary_to_list(C0)} | R1]} | Rest], Acc);
</span><span class="marked"><a name="line269"></a>..269 to_tokens([{Tag0, [{T0, A1, C0=[C | _]} | R1]} | Rest], Acc)
</span><span class="marked"><a name="line270"></a>..270   when is_integer(C) ->
</span><span class="marked"><a name="line271"></a>..271     %% Allow {"p", [{"class", "foo"}], "content"}
</span><span class="uncovered"><a name="line272"></a>..272     to_tokens([{Tag0, [{T0, A1, [C0]} | R1]} | Rest], Acc);
</span><span class="marked"><a name="line273"></a>..273 to_tokens([{Tag0, [{T0, A1, C1} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line274"></a>..274     %% Native {"p", [{"class", "foo"}], ["content"]}
</span><span class="uncovered"><a name="line275"></a>..275     Tag = to_tag(Tag0),
</span><span class="uncovered"><a name="line276"></a>..276     T1 = to_tag(T0),
</span><span class="uncovered"><a name="line277"></a>..277     case is_singleton(norm(T1)) of
</span><span class="marked"><a name="line278"></a>..278         true ->
</span><span class="uncovered"><a name="line279"></a>..279             to_tokens([{Tag, R1} | Rest], [{start_tag, T1, A1, true} | Acc]);
</span><span class="marked"><a name="line280"></a>..280         false ->
</span><span class="uncovered"><a name="line281"></a>..281             to_tokens([{T1, C1}, {Tag, R1} | Rest],
</span><span class="marked"><a name="line282"></a>..282                       [{start_tag, T1, A1, false} | Acc])
</span><span class="marked"><a name="line283"></a>..283     end;
</span><span class="marked"><a name="line284"></a>..284 to_tokens([{Tag0, [L | R1]} | Rest], Acc) when is_list(L) ->
</span><span class="marked"><a name="line285"></a>..285     %% List text
</span><span class="uncovered"><a name="line286"></a>..286     Tag = to_tag(Tag0),
</span><span class="uncovered"><a name="line287"></a>..287     to_tokens([{Tag, R1} | Rest], [{data, iolist_to_binary(L), false} | Acc]);
</span><span class="marked"><a name="line288"></a>..288 to_tokens([{Tag0, [B | R1]} | Rest], Acc) when is_binary(B) ->
</span><span class="marked"><a name="line289"></a>..289     %% Binary text
</span><span class="uncovered"><a name="line290"></a>..290     Tag = to_tag(Tag0),
</span><span class="uncovered"><a name="line291"></a>..291     to_tokens([{Tag, R1} | Rest], [{data, B, false} | Acc]).
</span><span class="marked"><a name="line292"></a>..292 
</span><span class="marked"><a name="line293"></a>..293 test_tokens() ->
</span><span class="marked"><a name="line294"></a>..294     [{start_tag, <<"foo">>, [{<<"bar">>, <<"baz">>},
</span><span class="marked"><a name="line295"></a>..295                              {<<"wibble">>, <<"wibble">>},
</span><span class="uncovered"><a name="line296"></a>..296                              {<<"alice">>, <<"bob">>}], true}] =
</span><span class="marked"><a name="line297"></a>..297         tokens(<<"<foo bar=baz wibble='wibble' alice=\"bob\"/>">>),
</span><span class="marked"><a name="line298"></a>..298     [{start_tag, <<"foo">>, [{<<"bar">>, <<"baz">>},
</span><span class="marked"><a name="line299"></a>..299                              {<<"wibble">>, <<"wibble">>},
</span><span class="uncovered"><a name="line300"></a>..300                              {<<"alice">>, <<"bob">>}], true}] =
</span><span class="marked"><a name="line301"></a>..301         tokens(<<"<foo bar=baz wibble='wibble' alice=bob/>">>),
</span><span class="uncovered"><a name="line302"></a>..302     [{comment, <<"[if lt IE 7]>\n<style type=\"text/css\">\n.no_ie { display: none; }\n</style>\n<![endif]">>}] =
</span><span class="marked"><a name="line303"></a>..303         tokens(<<"<!--[if lt IE 7]>\n<style type=\"text/css\">\n.no_ie { display: none; }\n</style>\n<![endif]-->">>),
</span><span class="marked"><a name="line304"></a>..304     [{start_tag, <<"script">>, [{<<"type">>, <<"text/javascript">>}], false},
</span><span class="marked"><a name="line305"></a>..305      {data, <<" A= B <= C ">>, false},
</span><span class="uncovered"><a name="line306"></a>..306      {end_tag, <<"script">>}] =
</span><span class="marked"><a name="line307"></a>..307         tokens(<<"<script type=\"text/javascript\"> A= B <= C </script>">>),
</span><span class="marked"><a name="line308"></a>..308     [{start_tag, <<"textarea">>, [], false},
</span><span class="marked"><a name="line309"></a>..309      {data, <<"<html></body>">>, false},
</span><span class="uncovered"><a name="line310"></a>..310      {end_tag, <<"textarea">>}] =
</span><span class="marked"><a name="line311"></a>..311         tokens(<<"<textarea><html></body></textarea>">>),
</span><span class="uncovered"><a name="line312"></a>..312     ok.
</span><span class="marked"><a name="line313"></a>..313 
</span><span class="marked"><a name="line314"></a>..314 tokens(B, S=#decoder{offset=O}, Acc) ->
</span><span class="uncovered"><a name="line315"></a>..315     case B of
</span><span class="marked"><a name="line316"></a>..316         <<_:O/binary>> ->
</span><span class="uncovered"><a name="line317"></a>..317             lists:reverse(Acc);
</span><span class="marked"><a name="line318"></a>..318         _ ->
</span><span class="uncovered"><a name="line319"></a>..319             {Tag, S1} = tokenize(B, S),
</span><span class="uncovered"><a name="line320"></a>..320             case parse_flag(Tag) of
</span><span class="marked"><a name="line321"></a>..321                 script ->
</span><span class="uncovered"><a name="line322"></a>..322                     {Tag2, S2} = tokenize_script(B, S1),
</span><span class="uncovered"><a name="line323"></a>..323                     tokens(B, S2, [Tag2, Tag | Acc]);
</span><span class="marked"><a name="line324"></a>..324                 textarea ->
</span><span class="uncovered"><a name="line325"></a>..325                     {Tag2, S2} = tokenize_textarea(B, S1),
</span><span class="uncovered"><a name="line326"></a>..326                     tokens(B, S2, [Tag2, Tag | Acc]);
</span><span class="marked"><a name="line327"></a>..327                 none ->
</span><span class="uncovered"><a name="line328"></a>..328                     tokens(B, S1, [Tag | Acc])
</span><span class="marked"><a name="line329"></a>..329             end
</span><span class="marked"><a name="line330"></a>..330     end.
</span><span class="marked"><a name="line331"></a>..331 
</span><span class="marked"><a name="line332"></a>..332 parse_flag({start_tag, B, _, false}) ->
</span><span class="uncovered"><a name="line333"></a>..333     case string:to_lower(binary_to_list(B)) of
</span><span class="marked"><a name="line334"></a>..334         "script" ->
</span><span class="uncovered"><a name="line335"></a>..335             script;
</span><span class="marked"><a name="line336"></a>..336         "textarea" ->
</span><span class="uncovered"><a name="line337"></a>..337             textarea;
</span><span class="marked"><a name="line338"></a>..338         _ ->
</span><span class="uncovered"><a name="line339"></a>..339             none
</span><span class="marked"><a name="line340"></a>..340     end;
</span><span class="marked"><a name="line341"></a>..341 parse_flag(_) ->
</span><span class="uncovered"><a name="line342"></a>..342     none.
</span><span class="marked"><a name="line343"></a>..343 
</span><span class="marked"><a name="line344"></a>..344 tokenize(B, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line345"></a>..345     case B of
</span><span class="marked"><a name="line346"></a>..346         <<_:O/binary, "<!--", _/binary>> ->
</span><span class="uncovered"><a name="line347"></a>..347             tokenize_comment(B, ?ADV_COL(S, 4));
</span><span class="marked"><a name="line348"></a>..348         <<_:O/binary, "<!DOCTYPE", _/binary>> ->
</span><span class="uncovered"><a name="line349"></a>..349             tokenize_doctype(B, ?ADV_COL(S, 10));
</span><span class="marked"><a name="line350"></a>..350         <<_:O/binary, "<![CDATA[", _/binary>> ->
</span><span class="uncovered"><a name="line351"></a>..351             tokenize_cdata(B, ?ADV_COL(S, 9));
</span><span class="marked"><a name="line352"></a>..352         <<_:O/binary, "<?", _/binary>> ->
</span><span class="uncovered"><a name="line353"></a>..353             {Tag, S1} = tokenize_literal(B, ?ADV_COL(S, 2)),
</span><span class="uncovered"><a name="line354"></a>..354             {Attrs, S2} = tokenize_attributes(B, S1),
</span><span class="uncovered"><a name="line355"></a>..355             S3 = find_qgt(B, S2),
</span><span class="uncovered"><a name="line356"></a>..356             {{pi, Tag, Attrs}, S3};
</span><span class="marked"><a name="line357"></a>..357         <<_:O/binary, "&", _/binary>> ->
</span><span class="uncovered"><a name="line358"></a>..358             tokenize_charref(B, ?INC_COL(S));
</span><span class="marked"><a name="line359"></a>..359         <<_:O/binary, "</", _/binary>> ->
</span><span class="uncovered"><a name="line360"></a>..360             {Tag, S1} = tokenize_literal(B, ?ADV_COL(S, 2)),
</span><span class="uncovered"><a name="line361"></a>..361             {S2, _} = find_gt(B, S1),
</span><span class="uncovered"><a name="line362"></a>..362             {{end_tag, Tag}, S2};
</span><span class="marked"><a name="line363"></a>..363         <<_:O/binary, "<", C, _/binary>> when ?IS_WHITESPACE(C) ->
</span><span class="marked"><a name="line364"></a>..364             %% This isn't really strict HTML
</span><span class="uncovered"><a name="line365"></a>..365             tokenize_data(B, ?INC_COL(S));
</span><span class="marked"><a name="line366"></a>..366         <<_:O/binary, "<", _/binary>> ->
</span><span class="uncovered"><a name="line367"></a>..367             {Tag, S1} = tokenize_literal(B, ?INC_COL(S)),
</span><span class="uncovered"><a name="line368"></a>..368             {Attrs, S2} = tokenize_attributes(B, S1),
</span><span class="uncovered"><a name="line369"></a>..369             {S3, HasSlash} = find_gt(B, S2),
</span><span class="uncovered"><a name="line370"></a>..370             Singleton = HasSlash orelse is_singleton(norm(binary_to_list(Tag))),
</span><span class="uncovered"><a name="line371"></a>..371             {{start_tag, Tag, Attrs, Singleton}, S3};
</span><span class="marked"><a name="line372"></a>..372         _ ->
</span><span class="uncovered"><a name="line373"></a>..373             tokenize_data(B, S)
</span><span class="marked"><a name="line374"></a>..374     end.
</span><span class="marked"><a name="line375"></a>..375 
</span><span class="marked"><a name="line376"></a>..376 test_parse() ->
</span><span class="uncovered"><a name="line377"></a>..377     D0 = <<"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">
</span><span class="marked"><a name="line378"></a>..378 <html>
</span><span class="marked"><a name="line379"></a>..379  <head>
</span><span class="marked"><a name="line380"></a>..380    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">
</span><span class="marked"><a name="line381"></a>..381    <title>Foo</title>
</span><span class="marked"><a name="line382"></a>..382    <link rel=\"stylesheet\" type=\"text/css\" href=\"/static/rel/dojo/resources/dojo.css\" media=\"screen\">
</span><span class="marked"><a name="line383"></a>..383    <link rel=\"stylesheet\" type=\"text/css\" href=\"/static/foo.css\" media=\"screen\">
</span><span class="marked"><a name="line384"></a>..384    <!--[if lt IE 7]>
</span><span class="marked"><a name="line385"></a>..385    <style type=\"text/css\">
</span><span class="marked"><a name="line386"></a>..386      .no_ie { display: none; }
</span><span class="marked"><a name="line387"></a>..387    </style>
</span><span class="marked"><a name="line388"></a>..388    <![endif]-->
</span><span class="marked"><a name="line389"></a>..389    <link rel=\"icon\" href=\"/static/images/favicon.ico\" type=\"image/x-icon\">
</span><span class="marked"><a name="line390"></a>..390    <link rel=\"shortcut icon\" href=\"/static/images/favicon.ico\" type=\"image/x-icon\">
</span><span class="marked"><a name="line391"></a>..391  </head>
</span><span class="marked"><a name="line392"></a>..392  <body id=\"home\" class=\"tundra\"><![CDATA[&lt;<this<!-- is -->CDATA>&gt;]]></body>
</span><span class="marked"><a name="line393"></a>..393 </html>">>,
</span><span class="uncovered"><a name="line394"></a>..394     Expect = {<<"html">>, [],
</span><span class="marked"><a name="line395"></a>..395               [{<<"head">>, [],
</span><span class="marked"><a name="line396"></a>..396                 [{<<"meta">>,
</span><span class="marked"><a name="line397"></a>..397                   [{<<"http-equiv">>,<<"Content-Type">>},
</span><span class="marked"><a name="line398"></a>..398                    {<<"content">>,<<"text/html; charset=UTF-8">>}],
</span><span class="marked"><a name="line399"></a>..399                   []},
</span><span class="marked"><a name="line400"></a>..400                  {<<"title">>,[],[<<"Foo">>]},
</span><span class="marked"><a name="line401"></a>..401                  {<<"link">>,
</span><span class="marked"><a name="line402"></a>..402                   [{<<"rel">>,<<"stylesheet">>},
</span><span class="marked"><a name="line403"></a>..403                    {<<"type">>,<<"text/css">>},
</span><span class="marked"><a name="line404"></a>..404                    {<<"href">>,<<"/static/rel/dojo/resources/dojo.css">>},
</span><span class="marked"><a name="line405"></a>..405                    {<<"media">>,<<"screen">>}],
</span><span class="marked"><a name="line406"></a>..406                   []},
</span><span class="marked"><a name="line407"></a>..407                  {<<"link">>,
</span><span class="marked"><a name="line408"></a>..408                   [{<<"rel">>,<<"stylesheet">>},
</span><span class="marked"><a name="line409"></a>..409                    {<<"type">>,<<"text/css">>},
</span><span class="marked"><a name="line410"></a>..410                    {<<"href">>,<<"/static/foo.css">>},
</span><span class="marked"><a name="line411"></a>..411                    {<<"media">>,<<"screen">>}],
</span><span class="marked"><a name="line412"></a>..412                   []},
</span><span class="marked"><a name="line413"></a>..413                  {comment,<<"[if lt IE 7]>\n   <style type=\"text/css\">\n     .no_ie { display: none; }\n   </style>\n   <![endif]">>},
</span><span class="marked"><a name="line414"></a>..414                  {<<"link">>,
</span><span class="marked"><a name="line415"></a>..415                   [{<<"rel">>,<<"icon">>},
</span><span class="marked"><a name="line416"></a>..416                    {<<"href">>,<<"/static/images/favicon.ico">>},
</span><span class="marked"><a name="line417"></a>..417                    {<<"type">>,<<"image/x-icon">>}],
</span><span class="marked"><a name="line418"></a>..418                   []},
</span><span class="marked"><a name="line419"></a>..419                  {<<"link">>,
</span><span class="marked"><a name="line420"></a>..420                   [{<<"rel">>,<<"shortcut icon">>},
</span><span class="marked"><a name="line421"></a>..421                    {<<"href">>,<<"/static/images/favicon.ico">>},
</span><span class="marked"><a name="line422"></a>..422                    {<<"type">>,<<"image/x-icon">>}],
</span><span class="marked"><a name="line423"></a>..423                   []}]},
</span><span class="marked"><a name="line424"></a>..424                {<<"body">>,
</span><span class="marked"><a name="line425"></a>..425                 [{<<"id">>,<<"home">>},
</span><span class="marked"><a name="line426"></a>..426                  {<<"class">>,<<"tundra">>}],
</span><span class="marked"><a name="line427"></a>..427                 [<<"&lt;<this<!-- is -->CDATA>&gt;">>]}]},
</span><span class="uncovered"><a name="line428"></a>..428     Expect = parse(D0),
</span><span class="uncovered"><a name="line429"></a>..429     ok.
</span><span class="marked"><a name="line430"></a>..430 
</span><span class="marked"><a name="line431"></a>..431 test_tokens2() ->
</span><span class="uncovered"><a name="line432"></a>..432     D0 = <<"<channel><title>from __future__ import *</title><link>http://bob.pythonmac.org</link><description>Bob's Rants</description></channel>">>,
</span><span class="uncovered"><a name="line433"></a>..433     Expect = [{start_tag,<<"channel">>,[],false},
</span><span class="marked"><a name="line434"></a>..434               {start_tag,<<"title">>,[],false},
</span><span class="marked"><a name="line435"></a>..435               {data,<<"from __future__ import *">>,false},
</span><span class="marked"><a name="line436"></a>..436               {end_tag,<<"title">>},
</span><span class="marked"><a name="line437"></a>..437               {start_tag,<<"link">>,[],true},
</span><span class="marked"><a name="line438"></a>..438               {data,<<"http://bob.pythonmac.org">>,false},
</span><span class="marked"><a name="line439"></a>..439               {end_tag,<<"link">>},
</span><span class="marked"><a name="line440"></a>..440               {start_tag,<<"description">>,[],false},
</span><span class="marked"><a name="line441"></a>..441               {data,<<"Bob's Rants">>,false},
</span><span class="marked"><a name="line442"></a>..442               {end_tag,<<"description">>},
</span><span class="marked"><a name="line443"></a>..443               {end_tag,<<"channel">>}],
</span><span class="uncovered"><a name="line444"></a>..444     Expect = tokens(D0),
</span><span class="uncovered"><a name="line445"></a>..445     ok.
</span><span class="marked"><a name="line446"></a>..446 
</span><span class="marked"><a name="line447"></a>..447 test_parse2() ->
</span><span class="uncovered"><a name="line448"></a>..448     D0 = <<"<channel><title>from __future__ import *</title><link>http://bob.pythonmac.org<br>foo</link><description>Bob's Rants</description></channel>">>,
</span><span class="uncovered"><a name="line449"></a>..449     Expect = {<<"channel">>,[],
</span><span class="marked"><a name="line450"></a>..450               [{<<"title">>,[],[<<"from __future__ import *">>]},
</span><span class="marked"><a name="line451"></a>..451                {<<"link">>,[],[
</span><span class="marked"><a name="line452"></a>..452                                <<"http://bob.pythonmac.org">>,
</span><span class="marked"><a name="line453"></a>..453                                {<<"br">>,[],[]},
</span><span class="marked"><a name="line454"></a>..454                                <<"foo">>]},
</span><span class="marked"><a name="line455"></a>..455                {<<"description">>,[],[<<"Bob's Rants">>]}]},
</span><span class="uncovered"><a name="line456"></a>..456     Expect = parse(D0),
</span><span class="uncovered"><a name="line457"></a>..457     ok.
</span><span class="marked"><a name="line458"></a>..458 
</span><span class="marked"><a name="line459"></a>..459 test_parse_tokens() ->
</span><span class="uncovered"><a name="line460"></a>..460     D0 = [{doctype,[<<"HTML">>,<<"PUBLIC">>,<<"-//W3C//DTD HTML 4.01 Transitional//EN">>]},
</span><span class="marked"><a name="line461"></a>..461           {data,<<"\n">>,true},
</span><span class="marked"><a name="line462"></a>..462           {start_tag,<<"html">>,[],false}],
</span><span class="uncovered"><a name="line463"></a>..463     {<<"html">>, [], []} = parse_tokens(D0),
</span><span class="uncovered"><a name="line464"></a>..464     D1 = D0 ++ [{end_tag, <<"html">>}],
</span><span class="uncovered"><a name="line465"></a>..465     {<<"html">>, [], []} = parse_tokens(D1),
</span><span class="uncovered"><a name="line466"></a>..466     D2 = D0 ++ [{start_tag, <<"body">>, [], false}],
</span><span class="uncovered"><a name="line467"></a>..467     {<<"html">>, [], [{<<"body">>, [], []}]} = parse_tokens(D2),
</span><span class="uncovered"><a name="line468"></a>..468     D3 = D0 ++ [{start_tag, <<"head">>, [], false},
</span><span class="marked"><a name="line469"></a>..469                 {end_tag, <<"head">>},
</span><span class="marked"><a name="line470"></a>..470                 {start_tag, <<"body">>, [], false}],
</span><span class="uncovered"><a name="line471"></a>..471     {<<"html">>, [], [{<<"head">>, [], []}, {<<"body">>, [], []}]} = parse_tokens(D3),
</span><span class="uncovered"><a name="line472"></a>..472     D4 = D3 ++ [{data,<<"\n">>,true},
</span><span class="marked"><a name="line473"></a>..473                 {start_tag,<<"div">>,[{<<"class">>,<<"a">>}],false},
</span><span class="marked"><a name="line474"></a>..474                 {start_tag,<<"a">>,[{<<"name">>,<<"#anchor">>}],false},
</span><span class="marked"><a name="line475"></a>..475                 {end_tag,<<"a">>},
</span><span class="marked"><a name="line476"></a>..476                 {end_tag,<<"div">>},
</span><span class="marked"><a name="line477"></a>..477                 {start_tag,<<"div">>,[{<<"class">>,<<"b">>}],false},
</span><span class="marked"><a name="line478"></a>..478                 {start_tag,<<"div">>,[{<<"class">>,<<"c">>}],false},
</span><span class="marked"><a name="line479"></a>..479                 {end_tag,<<"div">>},
</span><span class="marked"><a name="line480"></a>..480                 {end_tag,<<"div">>}],
</span><span class="marked"><a name="line481"></a>..481     {<<"html">>, [],
</span><span class="marked"><a name="line482"></a>..482      [{<<"head">>, [], []},
</span><span class="marked"><a name="line483"></a>..483       {<<"body">>, [],
</span><span class="marked"><a name="line484"></a>..484        [{<<"div">>, [{<<"class">>, <<"a">>}], [{<<"a">>, [{<<"name">>, <<"#anchor">>}], []}]},
</span><span class="marked"><a name="line485"></a>..485         {<<"div">>, [{<<"class">>, <<"b">>}], [{<<"div">>, [{<<"class">>, <<"c">>}], []}]}
</span><span class="uncovered"><a name="line486"></a>..486        ]}]} = parse_tokens(D4),
</span><span class="uncovered"><a name="line487"></a>..487     D5 = [{start_tag,<<"html">>,[],false},
</span><span class="marked"><a name="line488"></a>..488           {data,<<"\n">>,true},
</span><span class="marked"><a name="line489"></a>..489           {data,<<"boo">>,false},
</span><span class="marked"><a name="line490"></a>..490           {data,<<"hoo">>,false},
</span><span class="marked"><a name="line491"></a>..491           {data,<<"\n">>,true},
</span><span class="marked"><a name="line492"></a>..492           {end_tag,<<"html">>}],
</span><span class="uncovered"><a name="line493"></a>..493     {<<"html">>, [], [<<"\nboohoo\n">>]} = parse_tokens(D5),
</span><span class="uncovered"><a name="line494"></a>..494     D6 = [{start_tag,<<"html">>,[],false},
</span><span class="marked"><a name="line495"></a>..495           {data,<<"\n">>,true},
</span><span class="marked"><a name="line496"></a>..496           {data,<<"\n">>,true},
</span><span class="marked"><a name="line497"></a>..497           {end_tag,<<"html">>}],
</span><span class="uncovered"><a name="line498"></a>..498     {<<"html">>, [], []} = parse_tokens(D6),
</span><span class="uncovered"><a name="line499"></a>..499     D7 = [{start_tag,<<"html">>,[],false},
</span><span class="marked"><a name="line500"></a>..500           {start_tag,<<"ul">>,[],false},
</span><span class="marked"><a name="line501"></a>..501           {start_tag,<<"li">>,[],false},
</span><span class="marked"><a name="line502"></a>..502           {data,<<"word">>,false},
</span><span class="marked"><a name="line503"></a>..503           {start_tag,<<"li">>,[],false},
</span><span class="marked"><a name="line504"></a>..504           {data,<<"up">>,false},
</span><span class="marked"><a name="line505"></a>..505           {end_tag,<<"li">>},
</span><span class="marked"><a name="line506"></a>..506           {start_tag,<<"li">>,[],false},
</span><span class="marked"><a name="line507"></a>..507           {data,<<"fdsa">>,false},
</span><span class="marked"><a name="line508"></a>..508           {start_tag,<<"br">>,[],true},
</span><span class="marked"><a name="line509"></a>..509           {data,<<"asdf">>,false},
</span><span class="marked"><a name="line510"></a>..510           {end_tag,<<"ul">>},
</span><span class="marked"><a name="line511"></a>..511           {end_tag,<<"html">>}],
</span><span class="marked"><a name="line512"></a>..512     {<<"html">>, [],
</span><span class="marked"><a name="line513"></a>..513      [{<<"ul">>, [],
</span><span class="marked"><a name="line514"></a>..514        [{<<"li">>, [], [<<"word">>]},
</span><span class="marked"><a name="line515"></a>..515         {<<"li">>, [], [<<"up">>]},
</span><span class="uncovered"><a name="line516"></a>..516         {<<"li">>, [], [<<"fdsa">>,{<<"br">>, [], []}, <<"asdf">>]}]}]} = parse_tokens(D7),
</span><span class="uncovered"><a name="line517"></a>..517     ok.
</span><span class="marked"><a name="line518"></a>..518 
</span><span class="marked"><a name="line519"></a>..519 tree_data([{data, Data, Whitespace} | Rest], AllWhitespace, Acc) ->
</span><span class="uncovered"><a name="line520"></a>..520     tree_data(Rest, (Whitespace andalso AllWhitespace), [Data | Acc]);
</span><span class="marked"><a name="line521"></a>..521 tree_data(Rest, AllWhitespace, Acc) ->
</span><span class="uncovered"><a name="line522"></a>..522     {iolist_to_binary(lists:reverse(Acc)), AllWhitespace, Rest}.
</span><span class="marked"><a name="line523"></a>..523 
</span><span class="marked"><a name="line524"></a>..524 tree([], Stack) ->
</span><span class="uncovered"><a name="line525"></a>..525     {destack(Stack), []};
</span><span class="marked"><a name="line526"></a>..526 tree([{end_tag, Tag} | Rest], Stack) ->
</span><span class="uncovered"><a name="line527"></a>..527     case destack(norm(Tag), Stack) of
</span><span class="marked"><a name="line528"></a>..528         S when is_list(S) ->
</span><span class="uncovered"><a name="line529"></a>..529             tree(Rest, S);
</span><span class="marked"><a name="line530"></a>..530         Result ->
</span><span class="uncovered"><a name="line531"></a>..531             {Result, []}
</span><span class="marked"><a name="line532"></a>..532     end;
</span><span class="marked"><a name="line533"></a>..533 tree([{start_tag, Tag, Attrs, true} | Rest], S) ->
</span><span class="uncovered"><a name="line534"></a>..534     tree(Rest, append_stack_child(norm({Tag, Attrs}), S));
</span><span class="marked"><a name="line535"></a>..535 tree([{start_tag, Tag, Attrs, false} | Rest], S) ->
</span><span class="uncovered"><a name="line536"></a>..536     tree(Rest, stack(norm({Tag, Attrs}), S));
</span><span class="marked"><a name="line537"></a>..537 tree([T={pi, _Tag, _Attrs} | Rest], S) ->
</span><span class="uncovered"><a name="line538"></a>..538     tree(Rest, append_stack_child(T, S));
</span><span class="marked"><a name="line539"></a>..539 tree([T={comment, _Comment} | Rest], S) ->
</span><span class="uncovered"><a name="line540"></a>..540     tree(Rest, append_stack_child(T, S));
</span><span class="marked"><a name="line541"></a>..541 tree(L=[{data, _Data, _Whitespace} | _], S) ->
</span><span class="uncovered"><a name="line542"></a>..542     case tree_data(L, true, []) of
</span><span class="marked"><a name="line543"></a>..543         {_, true, Rest} -> 
</span><span class="uncovered"><a name="line544"></a>..544             tree(Rest, S);
</span><span class="marked"><a name="line545"></a>..545         {Data, false, Rest} ->
</span><span class="uncovered"><a name="line546"></a>..546             tree(Rest, append_stack_child(Data, S))
</span><span class="marked"><a name="line547"></a>..547     end.
</span><span class="marked"><a name="line548"></a>..548 
</span><span class="marked"><a name="line549"></a>..549 norm({Tag, Attrs}) ->
</span><span class="uncovered"><a name="line550"></a>..550     {norm(Tag), [{norm(K), iolist_to_binary(V)} || {K, V} <- Attrs], []};
</span><span class="marked"><a name="line551"></a>..551 norm(Tag) when is_binary(Tag) ->
</span><span class="uncovered"><a name="line552"></a>..552     Tag;
</span><span class="marked"><a name="line553"></a>..553 norm(Tag) ->
</span><span class="uncovered"><a name="line554"></a>..554     list_to_binary(string:to_lower(Tag)).
</span><span class="marked"><a name="line555"></a>..555 
</span><span class="marked"><a name="line556"></a>..556 test_destack() ->
</span><span class="uncovered"><a name="line557"></a>..557     {<<"a">>, [], []} =
</span><span class="marked"><a name="line558"></a>..558         destack([{<<"a">>, [], []}]),
</span><span class="uncovered"><a name="line559"></a>..559     {<<"a">>, [], [{<<"b">>, [], []}]} =
</span><span class="marked"><a name="line560"></a>..560         destack([{<<"b">>, [], []}, {<<"a">>, [], []}]),
</span><span class="uncovered"><a name="line561"></a>..561     {<<"a">>, [], [{<<"b">>, [], [{<<"c">>, [], []}]}]} =
</span><span class="marked"><a name="line562"></a>..562      destack([{<<"c">>, [], []}, {<<"b">>, [], []}, {<<"a">>, [], []}]),
</span><span class="uncovered"><a name="line563"></a>..563     [{<<"a">>, [], [{<<"b">>, [], [{<<"c">>, [], []}]}]}] =
</span><span class="marked"><a name="line564"></a>..564      destack(<<"b">>,
</span><span class="marked"><a name="line565"></a>..565              [{<<"c">>, [], []}, {<<"b">>, [], []}, {<<"a">>, [], []}]),
</span><span class="uncovered"><a name="line566"></a>..566     [{<<"b">>, [], [{<<"c">>, [], []}]}, {<<"a">>, [], []}] =
</span><span class="marked"><a name="line567"></a>..567      destack(<<"c">>,
</span><span class="marked"><a name="line568"></a>..568              [{<<"c">>, [], []}, {<<"b">>, [], []},{<<"a">>, [], []}]),
</span><span class="uncovered"><a name="line569"></a>..569     ok.
</span><span class="marked"><a name="line570"></a>..570 
</span><span class="marked"><a name="line571"></a>..571 stack(T1={TN, _, _}, Stack=[{TN, _, _} | _Rest])
</span><span class="marked"><a name="line572"></a>..572   when TN =:= <<"li">> orelse TN =:= <<"option">> ->
</span><span class="uncovered"><a name="line573"></a>..573     [T1 | destack(TN, Stack)];
</span><span class="marked"><a name="line574"></a>..574 stack(T1={TN0, _, _}, Stack=[{TN1, _, _} | _Rest])
</span><span class="marked"><a name="line575"></a>..575   when (TN0 =:= <<"dd">> orelse TN0 =:= <<"dt">>) andalso
</span><span class="marked"><a name="line576"></a>..576        (TN1 =:= <<"dd">> orelse TN1 =:= <<"dt">>) ->
</span><span class="uncovered"><a name="line577"></a>..577     [T1 | destack(TN1, Stack)];
</span><span class="marked"><a name="line578"></a>..578 stack(T1, Stack) ->
</span><span class="uncovered"><a name="line579"></a>..579     [T1 | Stack].
</span><span class="marked"><a name="line580"></a>..580 
</span><span class="marked"><a name="line581"></a>..581 append_stack_child(StartTag, [{Name, Attrs, Acc} | Stack]) ->
</span><span class="uncovered"><a name="line582"></a>..582     [{Name, Attrs, [StartTag | Acc]} | Stack].
</span><span class="marked"><a name="line583"></a>..583 
</span><span class="marked"><a name="line584"></a>..584 destack(TagName, Stack) when is_list(Stack) ->
</span><span class="uncovered"><a name="line585"></a>..585     F = fun (X) ->
</span><span class="uncovered"><a name="line586"></a>..586                 case X of
</span><span class="marked"><a name="line587"></a>..587                     {TagName, _, _} ->
</span><span class="uncovered"><a name="line588"></a>..588                         false;
</span><span class="marked"><a name="line589"></a>..589                     _ ->
</span><span class="uncovered"><a name="line590"></a>..590                         true
</span><span class="marked"><a name="line591"></a>..591                 end
</span><span class="marked"><a name="line592"></a>..592         end,
</span><span class="uncovered"><a name="line593"></a>..593     case lists:splitwith(F, Stack) of
</span><span class="marked"><a name="line594"></a>..594         {_, []} ->
</span><span class="marked"><a name="line595"></a>..595             %% If we're parsing something like XML we might find
</span><span class="marked"><a name="line596"></a>..596             %% a <link>tag</link> that is normally a singleton
</span><span class="marked"><a name="line597"></a>..597             %% in HTML but isn't here
</span><span class="uncovered"><a name="line598"></a>..598             case {is_singleton(TagName), Stack} of
</span><span class="marked"><a name="line599"></a>..599                 {true, [{T0, A0, Acc0} | Post0]} ->
</span><span class="uncovered"><a name="line600"></a>..600                     case lists:splitwith(F, Acc0) of
</span><span class="marked"><a name="line601"></a>..601                         {_, []} ->
</span><span class="marked"><a name="line602"></a>..602                             %% Actually was a singleton
</span><span class="uncovered"><a name="line603"></a>..603                             Stack;
</span><span class="marked"><a name="line604"></a>..604                         {Pre, [{T1, A1, []} | Post1]} ->
</span><span class="uncovered"><a name="line605"></a>..605                             [{T0, A0, [{T1, A1, lists:reverse(Pre)} | Post1]}
</span><span class="marked"><a name="line606"></a>..606                              | Post0]
</span><span class="marked"><a name="line607"></a>..607                     end;
</span><span class="marked"><a name="line608"></a>..608                 _ ->
</span><span class="marked"><a name="line609"></a>..609                     %% No match, no state change
</span><span class="uncovered"><a name="line610"></a>..610                     Stack
</span><span class="marked"><a name="line611"></a>..611             end;
</span><span class="marked"><a name="line612"></a>..612         {_Pre, [_T]} ->
</span><span class="marked"><a name="line613"></a>..613             %% Unfurl the whole stack, we're done
</span><span class="uncovered"><a name="line614"></a>..614             destack(Stack);
</span><span class="marked"><a name="line615"></a>..615         {Pre, [T, {T0, A0, Acc0} | Post]} ->
</span><span class="marked"><a name="line616"></a>..616             %% Unfurl up to the tag, then accumulate it
</span><span class="uncovered"><a name="line617"></a>..617             [{T0, A0, [destack(Pre ++ [T]) | Acc0]} | Post]
</span><span class="marked"><a name="line618"></a>..618     end.
</span><span class="marked"><a name="line619"></a>..619 
</span><span class="marked"><a name="line620"></a>..620 destack([{Tag, Attrs, Acc}]) ->
</span><span class="uncovered"><a name="line621"></a>..621     {Tag, Attrs, lists:reverse(Acc)};
</span><span class="marked"><a name="line622"></a>..622 destack([{T1, A1, Acc1}, {T0, A0, Acc0} | Rest]) ->
</span><span class="uncovered"><a name="line623"></a>..623     destack([{T0, A0, [{T1, A1, lists:reverse(Acc1)} | Acc0]} | Rest]).
</span><span class="marked"><a name="line624"></a>..624 
</span><span class="uncovered"><a name="line625"></a>..625 is_singleton(<<"br">>) -> true;
</span><span class="uncovered"><a name="line626"></a>..626 is_singleton(<<"hr">>) -> true;
</span><span class="uncovered"><a name="line627"></a>..627 is_singleton(<<"img">>) -> true;
</span><span class="uncovered"><a name="line628"></a>..628 is_singleton(<<"input">>) -> true;
</span><span class="uncovered"><a name="line629"></a>..629 is_singleton(<<"base">>) -> true;
</span><span class="uncovered"><a name="line630"></a>..630 is_singleton(<<"meta">>) -> true;
</span><span class="uncovered"><a name="line631"></a>..631 is_singleton(<<"link">>) -> true;
</span><span class="uncovered"><a name="line632"></a>..632 is_singleton(<<"area">>) -> true;
</span><span class="uncovered"><a name="line633"></a>..633 is_singleton(<<"param">>) -> true;
</span><span class="uncovered"><a name="line634"></a>..634 is_singleton(<<"col">>) -> true;
</span><span class="uncovered"><a name="line635"></a>..635 is_singleton(_) -> false.
</span><span class="marked"><a name="line636"></a>..636 
</span><span class="marked"><a name="line637"></a>..637 tokenize_data(B, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line638"></a>..638     tokenize_data(B, S, O, true).
</span><span class="marked"><a name="line639"></a>..639 
</span><span class="marked"><a name="line640"></a>..640 tokenize_data(B, S=#decoder{offset=O}, Start, Whitespace) ->
</span><span class="uncovered"><a name="line641"></a>..641     case B of
</span><span class="marked"><a name="line642"></a>..642         <<_:O/binary, C, _/binary>> when (C =/= $< andalso C =/= $&) ->
</span><span class="uncovered"><a name="line643"></a>..643             tokenize_data(B, ?INC_CHAR(S, C), Start,
</span><span class="uncovered"><a name="line644"></a>..644                           (Whitespace andalso ?IS_WHITESPACE(C)));
</span><span class="marked"><a name="line645"></a>..645         _ ->
</span><span class="uncovered"><a name="line646"></a>..646             Len = O - Start,
</span><span class="uncovered"><a name="line647"></a>..647             <<_:Start/binary, Data:Len/binary, _/binary>> = B,
</span><span class="uncovered"><a name="line648"></a>..648             {{data, Data, Whitespace}, S}
</span><span class="marked"><a name="line649"></a>..649     end.
</span><span class="marked"><a name="line650"></a>..650 
</span><span class="marked"><a name="line651"></a>..651 tokenize_attributes(B, S) ->
</span><span class="uncovered"><a name="line652"></a>..652     tokenize_attributes(B, S, []).
</span><span class="marked"><a name="line653"></a>..653 
</span><span class="marked"><a name="line654"></a>..654 tokenize_attributes(B, S=#decoder{offset=O}, Acc) ->
</span><span class="uncovered"><a name="line655"></a>..655     case B of
</span><span class="marked"><a name="line656"></a>..656         <<_:O/binary>> ->
</span><span class="uncovered"><a name="line657"></a>..657             {lists:reverse(Acc), S};
</span><span class="marked"><a name="line658"></a>..658         <<_:O/binary, C, _/binary>> when (C =:= $> orelse C =:= $/) ->
</span><span class="uncovered"><a name="line659"></a>..659             {lists:reverse(Acc), S};
</span><span class="marked"><a name="line660"></a>..660         <<_:O/binary, "?>", _/binary>> ->
</span><span class="uncovered"><a name="line661"></a>..661             {lists:reverse(Acc), S};
</span><span class="marked"><a name="line662"></a>..662         <<_:O/binary, C, _/binary>> when ?IS_WHITESPACE(C) ->
</span><span class="uncovered"><a name="line663"></a>..663             tokenize_attributes(B, ?INC_CHAR(S, C), Acc);
</span><span class="marked"><a name="line664"></a>..664         _ ->
</span><span class="uncovered"><a name="line665"></a>..665             {Attr, S1} = tokenize_literal(B, S),
</span><span class="uncovered"><a name="line666"></a>..666             {Value, S2} = tokenize_attr_value(Attr, B, S1),
</span><span class="uncovered"><a name="line667"></a>..667             tokenize_attributes(B, S2, [{Attr, Value} | Acc])
</span><span class="marked"><a name="line668"></a>..668     end.
</span><span class="marked"><a name="line669"></a>..669 
</span><span class="marked"><a name="line670"></a>..670 tokenize_attr_value(Attr, B, S) ->
</span><span class="uncovered"><a name="line671"></a>..671     S1 = skip_whitespace(B, S),
</span><span class="uncovered"><a name="line672"></a>..672     O = S1#decoder.offset,
</span><span class="uncovered"><a name="line673"></a>..673     case B of
</span><span class="marked"><a name="line674"></a>..674         <<_:O/binary, "=", _/binary>> ->
</span><span class="uncovered"><a name="line675"></a>..675             tokenize_word_or_literal(B, ?INC_COL(S1));
</span><span class="marked"><a name="line676"></a>..676         _ ->
</span><span class="uncovered"><a name="line677"></a>..677             {Attr, S1}
</span><span class="marked"><a name="line678"></a>..678     end.
</span><span class="marked"><a name="line679"></a>..679 
</span><span class="marked"><a name="line680"></a>..680 skip_whitespace(B, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line681"></a>..681     case B of
</span><span class="marked"><a name="line682"></a>..682         <<_:O/binary, C, _/binary>> when ?IS_WHITESPACE(C) ->
</span><span class="uncovered"><a name="line683"></a>..683             skip_whitespace(B, ?INC_CHAR(S, C));
</span><span class="marked"><a name="line684"></a>..684         _ ->
</span><span class="uncovered"><a name="line685"></a>..685             S
</span><span class="marked"><a name="line686"></a>..686     end.
</span><span class="marked"><a name="line687"></a>..687 
</span><span class="marked"><a name="line688"></a>..688 tokenize_literal(Bin, S) ->
</span><span class="uncovered"><a name="line689"></a>..689     tokenize_literal(Bin, S, []).
</span><span class="marked"><a name="line690"></a>..690 
</span><span class="marked"><a name="line691"></a>..691 tokenize_literal(Bin, S=#decoder{offset=O}, Acc) ->
</span><span class="uncovered"><a name="line692"></a>..692     case Bin of
</span><span class="marked"><a name="line693"></a>..693         <<_:O/binary, $&, _/binary>> ->
</span><span class="uncovered"><a name="line694"></a>..694             {{data, Data, false}, S1} = tokenize_charref(Bin, ?INC_COL(S)),
</span><span class="uncovered"><a name="line695"></a>..695             tokenize_literal(Bin, S1, [Data | Acc]);
</span><span class="marked"><a name="line696"></a>..696         <<_:O/binary, C, _/binary>> when not (?IS_WHITESPACE(C)
</span><span class="marked"><a name="line697"></a>..697                                               orelse C =:= $>
</span><span class="marked"><a name="line698"></a>..698                                               orelse C =:= $/
</span><span class="marked"><a name="line699"></a>..699                                               orelse C =:= $=) ->
</span><span class="uncovered"><a name="line700"></a>..700             tokenize_literal(Bin, ?INC_COL(S), [C | Acc]);
</span><span class="marked"><a name="line701"></a>..701         _ ->
</span><span class="uncovered"><a name="line702"></a>..702             {iolist_to_binary(lists:reverse(Acc)), S}
</span><span class="marked"><a name="line703"></a>..703     end.
</span><span class="marked"><a name="line704"></a>..704 
</span><span class="marked"><a name="line705"></a>..705 find_qgt(Bin, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line706"></a>..706     case Bin of
</span><span class="marked"><a name="line707"></a>..707         <<_:O/binary, "?>", _/binary>> ->
</span><span class="uncovered"><a name="line708"></a>..708             ?ADV_COL(S, 2);
</span><span class="marked"><a name="line709"></a>..709         <<_:O/binary, C, _/binary>> ->
</span><span class="uncovered"><a name="line710"></a>..710             find_qgt(Bin, ?INC_CHAR(S, C));
</span><span class="marked"><a name="line711"></a>..711         _ ->
</span><span class="uncovered"><a name="line712"></a>..712             S
</span><span class="marked"><a name="line713"></a>..713     end.
</span><span class="marked"><a name="line714"></a>..714 
</span><span class="marked"><a name="line715"></a>..715 find_gt(Bin, S) ->
</span><span class="uncovered"><a name="line716"></a>..716     find_gt(Bin, S, false).
</span><span class="marked"><a name="line717"></a>..717 
</span><span class="marked"><a name="line718"></a>..718 find_gt(Bin, S=#decoder{offset=O}, HasSlash) ->
</span><span class="uncovered"><a name="line719"></a>..719     case Bin of
</span><span class="marked"><a name="line720"></a>..720         <<_:O/binary, $/, _/binary>> ->
</span><span class="uncovered"><a name="line721"></a>..721             find_gt(Bin, ?INC_COL(S), true);
</span><span class="marked"><a name="line722"></a>..722         <<_:O/binary, $>, _/binary>> ->
</span><span class="uncovered"><a name="line723"></a>..723             {?INC_COL(S), HasSlash};
</span><span class="marked"><a name="line724"></a>..724         <<_:O/binary, C, _/binary>> ->
</span><span class="uncovered"><a name="line725"></a>..725             find_gt(Bin, ?INC_CHAR(S, C), HasSlash);
</span><span class="marked"><a name="line726"></a>..726         _ ->
</span><span class="uncovered"><a name="line727"></a>..727             {S, HasSlash}
</span><span class="marked"><a name="line728"></a>..728     end.
</span><span class="marked"><a name="line729"></a>..729 
</span><span class="marked"><a name="line730"></a>..730 tokenize_charref(Bin, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line731"></a>..731     tokenize_charref(Bin, S, O).
</span><span class="marked"><a name="line732"></a>..732 
</span><span class="marked"><a name="line733"></a>..733 tokenize_charref(Bin, S=#decoder{offset=O}, Start) ->
</span><span class="uncovered"><a name="line734"></a>..734     case Bin of
</span><span class="marked"><a name="line735"></a>..735         <<_:O/binary>> ->
</span><span class="uncovered"><a name="line736"></a>..736             <<_:Start/binary, Raw/binary>> = Bin,
</span><span class="uncovered"><a name="line737"></a>..737             {{data, Raw, false}, S};
</span><span class="marked"><a name="line738"></a>..738         <<_:O/binary, C, _/binary>> when ?IS_WHITESPACE(C)
</span><span class="marked"><a name="line739"></a>..739                                          orelse C =:= ?SQUOTE
</span><span class="marked"><a name="line740"></a>..740                                          orelse C =:= ?QUOTE
</span><span class="marked"><a name="line741"></a>..741                                          orelse C =:= $/
</span><span class="marked"><a name="line742"></a>..742                                          orelse C =:= $> ->
</span><span class="uncovered"><a name="line743"></a>..743             Len = O - Start,
</span><span class="uncovered"><a name="line744"></a>..744             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="uncovered"><a name="line745"></a>..745             {{data, Raw, false}, S};
</span><span class="marked"><a name="line746"></a>..746         <<_:O/binary, $;, _/binary>> ->
</span><span class="uncovered"><a name="line747"></a>..747             Len = O - Start,
</span><span class="uncovered"><a name="line748"></a>..748             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="uncovered"><a name="line749"></a>..749             Data = case mochiweb_charref:charref(Raw) of
</span><span class="marked"><a name="line750"></a>..750                        undefined ->
</span><span class="uncovered"><a name="line751"></a>..751                            Start1 = Start - 1,
</span><span class="uncovered"><a name="line752"></a>..752                            Len1 = Len + 2,
</span><span class="uncovered"><a name="line753"></a>..753                            <<_:Start1/binary, R:Len1/binary, _/binary>> = Bin,
</span><span class="uncovered"><a name="line754"></a>..754                            R;
</span><span class="marked"><a name="line755"></a>..755                        Unichar ->
</span><span class="uncovered"><a name="line756"></a>..756                            list_to_binary(xmerl_ucs:to_utf8(Unichar))
</span><span class="marked"><a name="line757"></a>..757                    end,
</span><span class="uncovered"><a name="line758"></a>..758             {{data, Data, false}, ?INC_COL(S)};
</span><span class="marked"><a name="line759"></a>..759         _ ->
</span><span class="uncovered"><a name="line760"></a>..760             tokenize_charref(Bin, ?INC_COL(S), Start)
</span><span class="marked"><a name="line761"></a>..761     end.
</span><span class="marked"><a name="line762"></a>..762 
</span><span class="marked"><a name="line763"></a>..763 tokenize_doctype(Bin, S) ->
</span><span class="uncovered"><a name="line764"></a>..764     tokenize_doctype(Bin, S, []).
</span><span class="marked"><a name="line765"></a>..765 
</span><span class="marked"><a name="line766"></a>..766 tokenize_doctype(Bin, S=#decoder{offset=O}, Acc) ->
</span><span class="uncovered"><a name="line767"></a>..767     case Bin of
</span><span class="marked"><a name="line768"></a>..768         <<_:O/binary>> ->
</span><span class="uncovered"><a name="line769"></a>..769             {{doctype, lists:reverse(Acc)}, S};
</span><span class="marked"><a name="line770"></a>..770         <<_:O/binary, $>, _/binary>> ->
</span><span class="uncovered"><a name="line771"></a>..771             {{doctype, lists:reverse(Acc)}, ?INC_COL(S)};
</span><span class="marked"><a name="line772"></a>..772         <<_:O/binary, C, _/binary>> when ?IS_WHITESPACE(C) ->
</span><span class="uncovered"><a name="line773"></a>..773             tokenize_doctype(Bin, ?INC_CHAR(S, C), Acc);
</span><span class="marked"><a name="line774"></a>..774         _ ->
</span><span class="uncovered"><a name="line775"></a>..775             {Word, S1} = tokenize_word_or_literal(Bin, S),
</span><span class="uncovered"><a name="line776"></a>..776             tokenize_doctype(Bin, S1, [Word | Acc])
</span><span class="marked"><a name="line777"></a>..777     end.
</span><span class="marked"><a name="line778"></a>..778 
</span><span class="marked"><a name="line779"></a>..779 tokenize_word_or_literal(Bin, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line780"></a>..780     case Bin of
</span><span class="marked"><a name="line781"></a>..781         <<_:O/binary, C, _/binary>> when ?IS_WHITESPACE(C) ->
</span><span class="uncovered"><a name="line782"></a>..782             {error, {whitespace, [C], S}};
</span><span class="marked"><a name="line783"></a>..783         <<_:O/binary, C, _/binary>> when C =:= ?QUOTE orelse C =:= ?SQUOTE ->
</span><span class="uncovered"><a name="line784"></a>..784             tokenize_word(Bin, ?INC_COL(S), C);
</span><span class="marked"><a name="line785"></a>..785         _ ->
</span><span class="uncovered"><a name="line786"></a>..786             tokenize_literal(Bin, S, [])
</span><span class="marked"><a name="line787"></a>..787     end.
</span><span class="marked"><a name="line788"></a>..788 
</span><span class="marked"><a name="line789"></a>..789 tokenize_word(Bin, S, Quote) ->
</span><span class="uncovered"><a name="line790"></a>..790     tokenize_word(Bin, S, Quote, []).
</span><span class="marked"><a name="line791"></a>..791 
</span><span class="marked"><a name="line792"></a>..792 tokenize_word(Bin, S=#decoder{offset=O}, Quote, Acc) ->
</span><span class="uncovered"><a name="line793"></a>..793     case Bin of
</span><span class="marked"><a name="line794"></a>..794         <<_:O/binary>> ->
</span><span class="uncovered"><a name="line795"></a>..795             {iolist_to_binary(lists:reverse(Acc)), S};
</span><span class="marked"><a name="line796"></a>..796         <<_:O/binary, Quote, _/binary>> ->
</span><span class="uncovered"><a name="line797"></a>..797             {iolist_to_binary(lists:reverse(Acc)), ?INC_COL(S)};
</span><span class="marked"><a name="line798"></a>..798         <<_:O/binary, $&, _/binary>> ->
</span><span class="uncovered"><a name="line799"></a>..799             {{data, Data, false}, S1} = tokenize_charref(Bin, ?INC_COL(S)),
</span><span class="uncovered"><a name="line800"></a>..800             tokenize_word(Bin, S1, Quote, [Data | Acc]);
</span><span class="marked"><a name="line801"></a>..801         <<_:O/binary, C, _/binary>> ->
</span><span class="uncovered"><a name="line802"></a>..802             tokenize_word(Bin, ?INC_CHAR(S, C), Quote, [C | Acc])
</span><span class="marked"><a name="line803"></a>..803     end.
</span><span class="marked"><a name="line804"></a>..804 
</span><span class="marked"><a name="line805"></a>..805 tokenize_cdata(Bin, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line806"></a>..806     tokenize_cdata(Bin, S, O).
</span><span class="marked"><a name="line807"></a>..807 
</span><span class="marked"><a name="line808"></a>..808 tokenize_cdata(Bin, S=#decoder{offset=O}, Start) ->
</span><span class="uncovered"><a name="line809"></a>..809     case Bin of
</span><span class="marked"><a name="line810"></a>..810         <<_:O/binary, "]]>", _/binary>> ->
</span><span class="uncovered"><a name="line811"></a>..811             Len = O - Start,
</span><span class="uncovered"><a name="line812"></a>..812             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="uncovered"><a name="line813"></a>..813             {{data, Raw, false}, ?ADV_COL(S, 3)};
</span><span class="marked"><a name="line814"></a>..814         <<_:O/binary, C, _/binary>> ->
</span><span class="uncovered"><a name="line815"></a>..815             tokenize_cdata(Bin, ?INC_CHAR(S, C), Start);
</span><span class="marked"><a name="line816"></a>..816         _ ->
</span><span class="uncovered"><a name="line817"></a>..817             <<_:O/binary, Raw/binary>> = Bin,
</span><span class="uncovered"><a name="line818"></a>..818             {{data, Raw, false}, S}
</span><span class="marked"><a name="line819"></a>..819     end.
</span><span class="marked"><a name="line820"></a>..820 
</span><span class="marked"><a name="line821"></a>..821 tokenize_comment(Bin, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line822"></a>..822     tokenize_comment(Bin, S, O).
</span><span class="marked"><a name="line823"></a>..823 
</span><span class="marked"><a name="line824"></a>..824 tokenize_comment(Bin, S=#decoder{offset=O}, Start) ->
</span><span class="uncovered"><a name="line825"></a>..825     case Bin of
</span><span class="marked"><a name="line826"></a>..826         <<_:O/binary, "-->", _/binary>> ->
</span><span class="uncovered"><a name="line827"></a>..827             Len = O - Start,
</span><span class="uncovered"><a name="line828"></a>..828             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="uncovered"><a name="line829"></a>..829             {{comment, Raw}, ?ADV_COL(S, 3)};
</span><span class="marked"><a name="line830"></a>..830         <<_:O/binary, C, _/binary>> ->
</span><span class="uncovered"><a name="line831"></a>..831             tokenize_comment(Bin, ?INC_CHAR(S, C), Start);
</span><span class="marked"><a name="line832"></a>..832         <<_:Start/binary, Raw/binary>> ->
</span><span class="uncovered"><a name="line833"></a>..833             {{comment, Raw}, S}
</span><span class="marked"><a name="line834"></a>..834     end.
</span><span class="marked"><a name="line835"></a>..835 
</span><span class="marked"><a name="line836"></a>..836 tokenize_script(Bin, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line837"></a>..837     tokenize_script(Bin, S, O).
</span><span class="marked"><a name="line838"></a>..838 
</span><span class="marked"><a name="line839"></a>..839 tokenize_script(Bin, S=#decoder{offset=O}, Start) ->
</span><span class="uncovered"><a name="line840"></a>..840     case Bin of
</span><span class="marked"><a name="line841"></a>..841         %% Just a look-ahead, we want the end_tag separately
</span><span class="marked"><a name="line842"></a>..842         <<_:O/binary, $<, $/, SS, CC, RR, II, PP, TT, _/binary>>
</span><span class="marked"><a name="line843"></a>..843         when (SS =:= $s orelse SS =:= $S) andalso
</span><span class="marked"><a name="line844"></a>..844              (CC =:= $c orelse CC =:= $C) andalso
</span><span class="marked"><a name="line845"></a>..845              (RR =:= $r orelse RR =:= $R) andalso
</span><span class="marked"><a name="line846"></a>..846              (II =:= $i orelse II =:= $I) andalso
</span><span class="marked"><a name="line847"></a>..847              (PP =:= $p orelse PP =:= $P) andalso
</span><span class="marked"><a name="line848"></a>..848              (TT=:= $t orelse TT =:= $T) ->
</span><span class="uncovered"><a name="line849"></a>..849             Len = O - Start,
</span><span class="uncovered"><a name="line850"></a>..850             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="uncovered"><a name="line851"></a>..851             {{data, Raw, false}, S};
</span><span class="marked"><a name="line852"></a>..852         <<_:O/binary, C, _/binary>> ->
</span><span class="uncovered"><a name="line853"></a>..853             tokenize_script(Bin, ?INC_CHAR(S, C), Start);
</span><span class="marked"><a name="line854"></a>..854         <<_:Start/binary, Raw/binary>> ->
</span><span class="uncovered"><a name="line855"></a>..855             {{data, Raw, false}, S}
</span><span class="marked"><a name="line856"></a>..856     end.
</span><span class="marked"><a name="line857"></a>..857 
</span><span class="marked"><a name="line858"></a>..858 tokenize_textarea(Bin, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line859"></a>..859     tokenize_textarea(Bin, S, O).
</span><span class="marked"><a name="line860"></a>..860 
</span><span class="marked"><a name="line861"></a>..861 tokenize_textarea(Bin, S=#decoder{offset=O}, Start) ->
</span><span class="uncovered"><a name="line862"></a>..862     case Bin of
</span><span class="marked"><a name="line863"></a>..863         %% Just a look-ahead, we want the end_tag separately
</span><span class="marked"><a name="line864"></a>..864         <<_:O/binary, $<, $/, TT, EE, XX, TT2, AA, RR, EE2, AA2, _/binary>>
</span><span class="marked"><a name="line865"></a>..865         when (TT =:= $t orelse TT =:= $T) andalso
</span><span class="marked"><a name="line866"></a>..866              (EE =:= $e orelse EE =:= $E) andalso
</span><span class="marked"><a name="line867"></a>..867              (XX =:= $x orelse XX =:= $X) andalso
</span><span class="marked"><a name="line868"></a>..868              (TT2 =:= $t orelse TT2 =:= $T) andalso
</span><span class="marked"><a name="line869"></a>..869              (AA =:= $a orelse AA =:= $A) andalso
</span><span class="marked"><a name="line870"></a>..870              (RR =:= $r orelse RR =:= $R) andalso
</span><span class="marked"><a name="line871"></a>..871              (EE2 =:= $e orelse EE2 =:= $E) andalso
</span><span class="marked"><a name="line872"></a>..872              (AA2 =:= $a orelse AA2 =:= $A) ->
</span><span class="uncovered"><a name="line873"></a>..873             Len = O - Start,
</span><span class="uncovered"><a name="line874"></a>..874             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="uncovered"><a name="line875"></a>..875             {{data, Raw, false}, S};
</span><span class="marked"><a name="line876"></a>..876         <<_:O/binary, C, _/binary>> ->
</span><span class="uncovered"><a name="line877"></a>..877             tokenize_textarea(Bin, ?INC_CHAR(S, C), Start);
</span><span class="marked"><a name="line878"></a>..878         <<_:Start/binary, Raw/binary>> ->
</span><span class="uncovered"><a name="line879"></a>..879             {{data, Raw, false}, S}
</span><span class="marked"><a name="line880"></a>..880     end.
</span></pre><hr /><p>Generated using <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.</p>
          </body>
        </html>
    