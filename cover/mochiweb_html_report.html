<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
          <head>
            <title>mochiweb_html - C0 code coverage information</title>
            <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
            <style type='text/css'>span.marked0 {
     background-color: rgb(185, 210, 200);
     display: block;
    }
    span.marked { display: block; background-color: #ffffff; }
    span.highlight { display: block; background-color: #fff9d7; }
    span.covered { display: block; background-color: #f7f7f7 ; }
    span.uncovered { display: block; background-color: #ffebe8 ; }
    span.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    div.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    body {
     font-family: verdana, arial, helvetica;
    }
    div.footer {
     font-size: 68%;
     margin-top: 1.5em;
    }
    h1, h2, h3, h4, h5, h6 {
     margin-bottom: 0.5em;
    }
    h5 {
     margin-top: 0.5em;
    }
    .hidden {
     display: none;
    }
    div.separator {
     height: 10px;
    }
    table.percent_graph {
     height: 12px;
     border: 1px solid #E2E6EF; 
     empty-cells: show;
    }
    table.percent_graph td.covered {
     height: 10px;
     background: #00f000;
    }
    table.percent_graph td.uncovered {
     height: 10px;
     background: #e00000;
    }
    table.percent_graph td.NA {
     height: 10px;
     background: #eaeaea;
    }
    table.report {
     border-collapse: collapse;
     width: 100%;
    }
    table.report td.heading {
     background: #dcecff;
     border: 1px solid #E2E6EF; 
     font-weight: bold;
     text-align: center;
    }
    table.report td.heading:hover {
     background: #c0ffc0;
    }
    table.report td.text {
     border: 1px solid #E2E6EF; 
    }
    table.report td.value {
     text-align: right;
     border: 1px solid #E2E6EF; 
    }
    table.report tr.light {
     background-color: rgb(240, 240, 245);
    }
    table.report tr.dark {
     background-color: rgb(230, 230, 235);
    }
    </style>
          </head>
          <body>
            <h3>C0 code coverage information</h3>
            <p>Generated on 2009-02-25 01:24:47 with <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.
            </p>            
        <table class='report'>
          <thead>
            <tr>
              <td class='heading'>Name</td>
              <td class='heading'>Total lines</td>
              <td class='heading'>Lines of code</td>
              <td class='heading'>Total coverage</td>
              <td class='heading'>Code coverage</td>
            </tr>
          </thead>
          <tbody>
            <tr class='light'>

              <td>
                <a href='mochiweb_html_report.html'>mochiweb_html</a>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td>
                <table cellspacing='0' cellpadding='0' align='right'>
                  <tr>
                    <td><tt>53%</tt>&nbsp;</td><td>
                      <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                      <tr><td class='covered' width='53' /><td class='uncovered' width='47' /></tr>
                      </table>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </tbody>
        </table><pre><span class="marked"><a name="line1"></a>....1 %% @author Bob Ippolito <bob@mochimedia.com>
</span><span class="marked"><a name="line2"></a>....2 %% @copyright 2007 Mochi Media, Inc.
</span><span class="marked"><a name="line3"></a>....3 
</span><span class="marked"><a name="line4"></a>....4 %% @doc Loosely tokenizes and generates parse trees for HTML 4.
</span><span class="marked"><a name="line5"></a>....5 -module(mochiweb_html).
</span><span class="marked"><a name="line6"></a>....6 -export([tokens/1, parse/1, parse_tokens/1, to_tokens/1, escape/1,
</span><span class="marked"><a name="line7"></a>....7          escape_attr/1, to_html/1]).
</span><span class="marked"><a name="line8"></a>....8 
</span><span class="marked"><a name="line9"></a>....9 % This is a macro to placate syntax highlighters..
</span><span class="marked"><a name="line10"></a>...10 -define(QUOTE, $\").
</span><span class="marked"><a name="line11"></a>...11 -define(SQUOTE, $\').
</span><span class="marked"><a name="line12"></a>...12 -define(ADV_COL(S, N),
</span><span class="marked"><a name="line13"></a>...13         S#decoder{column=N+S#decoder.column,
</span><span class="marked"><a name="line14"></a>...14                   offset=N+S#decoder.offset}).
</span><span class="marked"><a name="line15"></a>...15 -define(INC_COL(S),
</span><span class="marked"><a name="line16"></a>...16         S#decoder{column=1+S#decoder.column,
</span><span class="marked"><a name="line17"></a>...17                   offset=1+S#decoder.offset}).
</span><span class="marked"><a name="line18"></a>...18 -define(INC_LINE(S),
</span><span class="marked"><a name="line19"></a>...19         S#decoder{column=1,
</span><span class="marked"><a name="line20"></a>...20                   line=1+S#decoder.line,
</span><span class="marked"><a name="line21"></a>...21                   offset=1+S#decoder.offset}).
</span><span class="marked"><a name="line22"></a>...22 -define(INC_CHAR(S, C),
</span><span class="marked"><a name="line23"></a>...23         case C of
</span><span class="marked"><a name="line24"></a>...24             $\n ->
</span><span class="marked"><a name="line25"></a>...25                 S#decoder{column=1,
</span><span class="marked"><a name="line26"></a>...26                           line=1+S#decoder.line,
</span><span class="marked"><a name="line27"></a>...27                           offset=1+S#decoder.offset};
</span><span class="marked"><a name="line28"></a>...28             _ ->
</span><span class="marked"><a name="line29"></a>...29                 S#decoder{column=1+S#decoder.column,
</span><span class="marked"><a name="line30"></a>...30                           offset=1+S#decoder.offset}
</span><span class="marked"><a name="line31"></a>...31         end).
</span><span class="marked"><a name="line32"></a>...32 
</span><span class="marked"><a name="line33"></a>...33 -define(IS_WHITESPACE(C),
</span><span class="marked"><a name="line34"></a>...34         (C =:= $\s orelse C =:= $\t orelse C =:= $\r orelse C =:= $\n)).
</span><span class="marked"><a name="line35"></a>...35 -define(IS_LITERAL_SAFE(C),
</span><span class="marked"><a name="line36"></a>...36         ((C >= $A andalso C =< $Z) orelse (C >= $a andalso C =< $z)
</span><span class="marked"><a name="line37"></a>...37          orelse (C >= $0 andalso C =< $9))).
</span><span class="marked"><a name="line38"></a>...38 
</span><span class="marked"><a name="line39"></a>...39 -record(decoder, {line=1,
</span><span class="marked"><a name="line40"></a>...40                   column=1,
</span><span class="marked"><a name="line41"></a>...41                   offset=0}).
</span><span class="marked"><a name="line42"></a>...42 
</span><span class="marked"><a name="line43"></a>...43 %% @type html_node() = {string(), [html_attr()], [html_node() | string()]}
</span><span class="marked"><a name="line44"></a>...44 %% @type html_attr() = {string(), string()}
</span><span class="marked"><a name="line45"></a>...45 %% @type html_token() = html_data() | start_tag() | end_tag() | inline_html() | html_comment() | html_doctype()
</span><span class="marked"><a name="line46"></a>...46 %% @type html_data() = {data, string(), Whitespace::boolean()}
</span><span class="marked"><a name="line47"></a>...47 %% @type start_tag() = {start_tag, Name, [html_attr()], Singleton::boolean()}
</span><span class="marked"><a name="line48"></a>...48 %% @type end_tag() = {end_tag, Name}
</span><span class="marked"><a name="line49"></a>...49 %% @type html_comment() = {comment, Comment}
</span><span class="marked"><a name="line50"></a>...50 %% @type html_doctype() = {doctype, [Doctype]}
</span><span class="marked"><a name="line51"></a>...51 %% @type inline_html() = {'=', iolist()}
</span><span class="marked"><a name="line52"></a>...52 
</span><span class="marked"><a name="line53"></a>...53 %% External API.
</span><span class="marked"><a name="line54"></a>...54 
</span><span class="marked"><a name="line55"></a>...55 %% @spec parse(string() | binary()) -> html_node()
</span><span class="marked"><a name="line56"></a>...56 %% @doc tokenize and then transform the token stream into a HTML tree.
</span><span class="marked"><a name="line57"></a>...57 parse(Input) ->
</span><span class="uncovered"><a name="line58"></a>...58     parse_tokens(tokens(Input)).
</span><span class="marked"><a name="line59"></a>...59 
</span><span class="marked"><a name="line60"></a>...60 %% @spec parse_tokens([html_token()]) -> html_node()
</span><span class="marked"><a name="line61"></a>...61 %% @doc Transform the output of tokens(Doc) into a HTML tree.
</span><span class="marked"><a name="line62"></a>...62 parse_tokens(Tokens) when is_list(Tokens) ->
</span><span class="marked"><a name="line63"></a>...63     %% Skip over doctype, processing instructions
</span><span class="uncovered"><a name="line64"></a>...64     F = fun (X) ->
</span><span class="uncovered"><a name="line65"></a>...65                 case X of
</span><span class="marked"><a name="line66"></a>...66                     {start_tag, _, _, false} ->
</span><span class="uncovered"><a name="line67"></a>...67                         false;
</span><span class="marked"><a name="line68"></a>...68                     _ ->
</span><span class="uncovered"><a name="line69"></a>...69                         true
</span><span class="marked"><a name="line70"></a>...70                 end
</span><span class="marked"><a name="line71"></a>...71         end,
</span><span class="uncovered"><a name="line72"></a>...72     [{start_tag, Tag, Attrs, false} | Rest] = lists:dropwhile(F, Tokens),
</span><span class="uncovered"><a name="line73"></a>...73     {Tree, _} = tree(Rest, [norm({Tag, Attrs})]),
</span><span class="uncovered"><a name="line74"></a>...74     Tree.
</span><span class="marked"><a name="line75"></a>...75 
</span><span class="marked"><a name="line76"></a>...76 %% @spec tokens(StringOrBinary) -> [html_token()]
</span><span class="marked"><a name="line77"></a>...77 %% @doc Transform the input UTF-8 HTML into a token stream.
</span><span class="marked"><a name="line78"></a>...78 tokens(Input) ->
</span><span class="covered"><a name="line79"></a>...79     tokens(iolist_to_binary(Input), #decoder{}, []).
</span><span class="marked"><a name="line80"></a>...80 
</span><span class="marked"><a name="line81"></a>...81 %% @spec to_tokens(html_node()) -> [html_token()]
</span><span class="marked"><a name="line82"></a>...82 %% @doc Convert a html_node() tree to a list of tokens.
</span><span class="marked"><a name="line83"></a>...83 to_tokens({Tag0}) ->
</span><span class="uncovered"><a name="line84"></a>...84     to_tokens({Tag0, [], []});
</span><span class="marked"><a name="line85"></a>...85 to_tokens(T={'=', _}) ->
</span><span class="uncovered"><a name="line86"></a>...86     [T];
</span><span class="marked"><a name="line87"></a>...87 to_tokens(T={doctype, _}) ->
</span><span class="covered"><a name="line88"></a>...88     [T];
</span><span class="marked"><a name="line89"></a>...89 to_tokens(T={comment, _}) ->
</span><span class="uncovered"><a name="line90"></a>...90     [T];
</span><span class="marked"><a name="line91"></a>...91 to_tokens({Tag0, Acc}) ->
</span><span class="uncovered"><a name="line92"></a>...92     to_tokens({Tag0, [], Acc});
</span><span class="marked"><a name="line93"></a>...93 to_tokens({Tag0, Attrs, Acc}) ->
</span><span class="covered"><a name="line94"></a>...94     Tag = to_tag(Tag0),
</span><span class="covered"><a name="line95"></a>...95     to_tokens([{Tag, Acc}], [{start_tag, Tag, Attrs, is_singleton(Tag)}]).
</span><span class="marked"><a name="line96"></a>...96 
</span><span class="marked"><a name="line97"></a>...97 %% @spec to_html([html_token()] | html_node()) -> iolist()
</span><span class="marked"><a name="line98"></a>...98 %% @doc Convert a list of html_token() to a HTML document.
</span><span class="marked"><a name="line99"></a>...99 to_html(Node) when is_tuple(Node) ->
</span><span class="covered"><a name="line100"></a>..100     to_html(to_tokens(Node));
</span><span class="marked"><a name="line101"></a>..101 to_html(Tokens) when is_list(Tokens) ->
</span><span class="covered"><a name="line102"></a>..102     to_html(Tokens, []).
</span><span class="marked"><a name="line103"></a>..103 
</span><span class="marked"><a name="line104"></a>..104 %% @spec escape(string() | atom() | binary()) -> binary()
</span><span class="marked"><a name="line105"></a>..105 %% @doc Escape a string such that it's safe for HTML (amp; lt; gt;).
</span><span class="marked"><a name="line106"></a>..106 escape(B) when is_binary(B) ->
</span><span class="covered"><a name="line107"></a>..107     escape(binary_to_list(B), []);
</span><span class="marked"><a name="line108"></a>..108 escape(A) when is_atom(A) ->
</span><span class="covered"><a name="line109"></a>..109     escape(atom_to_list(A), []);
</span><span class="marked"><a name="line110"></a>..110 escape(S) when is_list(S) ->
</span><span class="uncovered"><a name="line111"></a>..111     escape(S, []).
</span><span class="marked"><a name="line112"></a>..112 
</span><span class="marked"><a name="line113"></a>..113 %% @spec escape_attr(string() | binary() | atom() | integer() | float()) -> binary()
</span><span class="marked"><a name="line114"></a>..114 %% @doc Escape a string such that it's safe for HTML attrs
</span><span class="marked"><a name="line115"></a>..115 %%      (amp; lt; gt; quot;).
</span><span class="marked"><a name="line116"></a>..116 escape_attr(B) when is_binary(B) ->
</span><span class="covered"><a name="line117"></a>..117     escape_attr(binary_to_list(B), []);
</span><span class="marked"><a name="line118"></a>..118 escape_attr(A) when is_atom(A) ->
</span><span class="covered"><a name="line119"></a>..119     escape_attr(atom_to_list(A), []);
</span><span class="marked"><a name="line120"></a>..120 escape_attr(S) when is_list(S) ->
</span><span class="uncovered"><a name="line121"></a>..121     escape_attr(S, []);
</span><span class="marked"><a name="line122"></a>..122 escape_attr(I) when is_integer(I) ->
</span><span class="uncovered"><a name="line123"></a>..123     escape_attr(integer_to_list(I), []);
</span><span class="marked"><a name="line124"></a>..124 escape_attr(F) when is_float(F) ->
</span><span class="uncovered"><a name="line125"></a>..125     escape_attr(mochinum:digits(F), []).
</span><span class="marked"><a name="line126"></a>..126 
</span><span class="marked"><a name="line127"></a>..127 to_html([], Acc) ->
</span><span class="covered"><a name="line128"></a>..128     lists:reverse(Acc);
</span><span class="marked"><a name="line129"></a>..129 to_html([{'=', Content} | Rest], Acc) ->
</span><span class="uncovered"><a name="line130"></a>..130     to_html(Rest, [Content | Acc]);
</span><span class="marked"><a name="line131"></a>..131 to_html([{pi, Tag, Attrs} | Rest], Acc) ->
</span><span class="uncovered"><a name="line132"></a>..132     Open = [<<"<?">>,
</span><span class="marked"><a name="line133"></a>..133             Tag,
</span><span class="marked"><a name="line134"></a>..134             attrs_to_html(Attrs, []),
</span><span class="marked"><a name="line135"></a>..135             <<"?>">>],
</span><span class="uncovered"><a name="line136"></a>..136     to_html(Rest, [Open | Acc]);
</span><span class="marked"><a name="line137"></a>..137 to_html([{comment, Comment} | Rest], Acc) ->
</span><span class="covered"><a name="line138"></a>..138     to_html(Rest, [[<<"<!--">>, Comment, <<"-->">>] | Acc]);
</span><span class="marked"><a name="line139"></a>..139 to_html([{doctype, Parts} | Rest], Acc) ->
</span><span class="covered"><a name="line140"></a>..140     Inside = doctype_to_html(Parts, Acc),
</span><span class="covered"><a name="line141"></a>..141     to_html(Rest, [[<<"<!DOCTYPE">>, Inside, <<">">>] | Acc]);
</span><span class="marked"><a name="line142"></a>..142 to_html([{data, Data, _Whitespace} | Rest], Acc) ->
</span><span class="covered"><a name="line143"></a>..143     to_html(Rest, [escape(Data) | Acc]);
</span><span class="marked"><a name="line144"></a>..144 to_html([{start_tag, Tag, Attrs, Singleton} | Rest], Acc) ->
</span><span class="covered"><a name="line145"></a>..145     Open = [<<"<">>,
</span><span class="marked"><a name="line146"></a>..146             Tag,
</span><span class="marked"><a name="line147"></a>..147             attrs_to_html(Attrs, []),
</span><span class="marked"><a name="line148"></a>..148             case Singleton of
</span><span class="covered"><a name="line149"></a>..149                 true -> <<" />">>;
</span><span class="covered"><a name="line150"></a>..150                 false -> <<">">>
</span><span class="marked"><a name="line151"></a>..151             end],
</span><span class="covered"><a name="line152"></a>..152     to_html(Rest, [Open | Acc]);
</span><span class="marked"><a name="line153"></a>..153 to_html([{end_tag, Tag} | Rest], Acc) ->
</span><span class="covered"><a name="line154"></a>..154     to_html(Rest, [[<<"</">>, Tag, <<">">>] | Acc]).
</span><span class="marked"><a name="line155"></a>..155 
</span><span class="marked"><a name="line156"></a>..156 doctype_to_html([], Acc) ->
</span><span class="covered"><a name="line157"></a>..157     lists:reverse(Acc);
</span><span class="marked"><a name="line158"></a>..158 doctype_to_html([Word | Rest], Acc) ->
</span><span class="covered"><a name="line159"></a>..159     case lists:all(fun (C) -> ?IS_LITERAL_SAFE(C) end,
</span><span class="marked"><a name="line160"></a>..160                    binary_to_list(iolist_to_binary(Word))) of
</span><span class="marked"><a name="line161"></a>..161         true ->
</span><span class="covered"><a name="line162"></a>..162             doctype_to_html(Rest, [[<<" ">>, Word] | Acc]);
</span><span class="marked"><a name="line163"></a>..163         false ->
</span><span class="covered"><a name="line164"></a>..164             doctype_to_html(Rest, [[<<" \"">>, escape_attr(Word), ?QUOTE] | Acc])
</span><span class="marked"><a name="line165"></a>..165     end.
</span><span class="marked"><a name="line166"></a>..166 
</span><span class="marked"><a name="line167"></a>..167 attrs_to_html([], Acc) ->
</span><span class="covered"><a name="line168"></a>..168     lists:reverse(Acc);
</span><span class="marked"><a name="line169"></a>..169 attrs_to_html([{K, V} | Rest], Acc) ->
</span><span class="covered"><a name="line170"></a>..170     attrs_to_html(Rest,
</span><span class="marked"><a name="line171"></a>..171                   [[<<" ">>, escape(K), <<"=\"">>,
</span><span class="marked"><a name="line172"></a>..172                     escape_attr(V), <<"\"">>] | Acc]).
</span><span class="marked"><a name="line173"></a>..173 
</span><span class="marked"><a name="line174"></a>..174 escape([], Acc) ->
</span><span class="covered"><a name="line175"></a>..175     list_to_binary(lists:reverse(Acc));
</span><span class="marked"><a name="line176"></a>..176 escape("<" ++ Rest, Acc) ->
</span><span class="covered"><a name="line177"></a>..177     escape(Rest, lists:reverse("&lt;", Acc));
</span><span class="marked"><a name="line178"></a>..178 escape(">" ++ Rest, Acc) ->
</span><span class="uncovered"><a name="line179"></a>..179     escape(Rest, lists:reverse("&gt;", Acc));
</span><span class="marked"><a name="line180"></a>..180 escape("&" ++ Rest, Acc) ->
</span><span class="covered"><a name="line181"></a>..181     escape(Rest, lists:reverse("&amp;", Acc));
</span><span class="marked"><a name="line182"></a>..182 escape([C | Rest], Acc) ->
</span><span class="covered"><a name="line183"></a>..183     escape(Rest, [C | Acc]).
</span><span class="marked"><a name="line184"></a>..184 
</span><span class="marked"><a name="line185"></a>..185 escape_attr([], Acc) ->
</span><span class="covered"><a name="line186"></a>..186     list_to_binary(lists:reverse(Acc));
</span><span class="marked"><a name="line187"></a>..187 escape_attr("<" ++ Rest, Acc) ->
</span><span class="covered"><a name="line188"></a>..188     escape_attr(Rest, lists:reverse("&lt;", Acc));
</span><span class="marked"><a name="line189"></a>..189 escape_attr(">" ++ Rest, Acc) ->
</span><span class="uncovered"><a name="line190"></a>..190     escape_attr(Rest, lists:reverse("&gt;", Acc));
</span><span class="marked"><a name="line191"></a>..191 escape_attr("&" ++ Rest, Acc) ->
</span><span class="covered"><a name="line192"></a>..192     escape_attr(Rest, lists:reverse("&amp;", Acc));
</span><span class="marked"><a name="line193"></a>..193 escape_attr([?QUOTE | Rest], Acc) ->
</span><span class="covered"><a name="line194"></a>..194     escape_attr(Rest, lists:reverse("&quot;", Acc));
</span><span class="marked"><a name="line195"></a>..195 escape_attr([C | Rest], Acc) ->
</span><span class="covered"><a name="line196"></a>..196     escape_attr(Rest, [C | Acc]).
</span><span class="marked"><a name="line197"></a>..197 
</span><span class="marked"><a name="line198"></a>..198 to_tag(A) when is_atom(A) ->
</span><span class="covered"><a name="line199"></a>..199     norm(atom_to_list(A));
</span><span class="marked"><a name="line200"></a>..200 to_tag(L) ->
</span><span class="covered"><a name="line201"></a>..201     norm(L).
</span><span class="marked"><a name="line202"></a>..202 
</span><span class="marked"><a name="line203"></a>..203 to_tokens([], Acc) ->
</span><span class="covered"><a name="line204"></a>..204     lists:reverse(Acc);
</span><span class="marked"><a name="line205"></a>..205 to_tokens([{Tag, []} | Rest], Acc) ->
</span><span class="covered"><a name="line206"></a>..206     to_tokens(Rest, [{end_tag, to_tag(Tag)} | Acc]);
</span><span class="marked"><a name="line207"></a>..207 to_tokens([{Tag0, [{T0} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line208"></a>..208     %% Allow {br}
</span><span class="covered"><a name="line209"></a>..209     to_tokens([{Tag0, [{T0, [], []} | R1]} | Rest], Acc);
</span><span class="marked"><a name="line210"></a>..210 to_tokens([{Tag0, [T0={'=', _C0} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line211"></a>..211     %% Allow {'=', iolist()}
</span><span class="uncovered"><a name="line212"></a>..212     to_tokens([{Tag0, R1} | Rest], [T0 | Acc]);
</span><span class="marked"><a name="line213"></a>..213 to_tokens([{Tag0, [T0={comment, _C0} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line214"></a>..214     %% Allow {comment, iolist()}
</span><span class="covered"><a name="line215"></a>..215     to_tokens([{Tag0, R1} | Rest], [T0 | Acc]);
</span><span class="marked"><a name="line216"></a>..216 to_tokens([{Tag0, [{T0, A0=[{_, _} | _]} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line217"></a>..217     %% Allow {p, [{"class", "foo"}]}
</span><span class="uncovered"><a name="line218"></a>..218     to_tokens([{Tag0, [{T0, A0, []} | R1]} | Rest], Acc);
</span><span class="marked"><a name="line219"></a>..219 to_tokens([{Tag0, [{T0, C0} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line220"></a>..220     %% Allow {p, "content"} and {p, <<"content">>}
</span><span class="covered"><a name="line221"></a>..221     to_tokens([{Tag0, [{T0, [], C0} | R1]} | Rest], Acc);
</span><span class="marked"><a name="line222"></a>..222 to_tokens([{Tag0, [{T0, A1, C0} | R1]} | Rest], Acc) when is_binary(C0) ->
</span><span class="marked"><a name="line223"></a>..223     %% Allow {"p", [{"class", "foo"}], <<"content">>}
</span><span class="covered"><a name="line224"></a>..224     to_tokens([{Tag0, [{T0, A1, binary_to_list(C0)} | R1]} | Rest], Acc);
</span><span class="marked"><a name="line225"></a>..225 to_tokens([{Tag0, [{T0, A1, C0=[C | _]} | R1]} | Rest], Acc)
</span><span class="marked"><a name="line226"></a>..226   when is_integer(C) ->
</span><span class="marked"><a name="line227"></a>..227     %% Allow {"p", [{"class", "foo"}], "content"}
</span><span class="covered"><a name="line228"></a>..228     to_tokens([{Tag0, [{T0, A1, [C0]} | R1]} | Rest], Acc);
</span><span class="marked"><a name="line229"></a>..229 to_tokens([{Tag0, [{T0, A1, C1} | R1]} | Rest], Acc) ->
</span><span class="marked"><a name="line230"></a>..230     %% Native {"p", [{"class", "foo"}], ["content"]}
</span><span class="covered"><a name="line231"></a>..231     Tag = to_tag(Tag0),
</span><span class="covered"><a name="line232"></a>..232     T1 = to_tag(T0),
</span><span class="covered"><a name="line233"></a>..233     case is_singleton(norm(T1)) of
</span><span class="marked"><a name="line234"></a>..234         true ->
</span><span class="covered"><a name="line235"></a>..235             to_tokens([{Tag, R1} | Rest], [{start_tag, T1, A1, true} | Acc]);
</span><span class="marked"><a name="line236"></a>..236         false ->
</span><span class="covered"><a name="line237"></a>..237             to_tokens([{T1, C1}, {Tag, R1} | Rest],
</span><span class="marked"><a name="line238"></a>..238                       [{start_tag, T1, A1, false} | Acc])
</span><span class="marked"><a name="line239"></a>..239     end;
</span><span class="marked"><a name="line240"></a>..240 to_tokens([{Tag0, [L | R1]} | Rest], Acc) when is_list(L) ->
</span><span class="marked"><a name="line241"></a>..241     %% List text
</span><span class="covered"><a name="line242"></a>..242     Tag = to_tag(Tag0),
</span><span class="covered"><a name="line243"></a>..243     to_tokens([{Tag, R1} | Rest], [{data, iolist_to_binary(L), false} | Acc]);
</span><span class="marked"><a name="line244"></a>..244 to_tokens([{Tag0, [B | R1]} | Rest], Acc) when is_binary(B) ->
</span><span class="marked"><a name="line245"></a>..245     %% Binary text
</span><span class="covered"><a name="line246"></a>..246     Tag = to_tag(Tag0),
</span><span class="covered"><a name="line247"></a>..247     to_tokens([{Tag, R1} | Rest], [{data, B, false} | Acc]).
</span><span class="marked"><a name="line248"></a>..248 
</span><span class="marked"><a name="line249"></a>..249 tokens(B, S=#decoder{offset=O}, Acc) ->
</span><span class="covered"><a name="line250"></a>..250     case B of
</span><span class="marked"><a name="line251"></a>..251         <<_:O/binary>> ->
</span><span class="covered"><a name="line252"></a>..252             lists:reverse(Acc);
</span><span class="marked"><a name="line253"></a>..253         _ ->
</span><span class="covered"><a name="line254"></a>..254             {Tag, S1} = tokenize(B, S),
</span><span class="covered"><a name="line255"></a>..255             case parse_flag(Tag) of
</span><span class="marked"><a name="line256"></a>..256                 script ->
</span><span class="covered"><a name="line257"></a>..257                     {Tag2, S2} = tokenize_script(B, S1),
</span><span class="covered"><a name="line258"></a>..258                     tokens(B, S2, [Tag2, Tag | Acc]);
</span><span class="marked"><a name="line259"></a>..259                 textarea ->
</span><span class="covered"><a name="line260"></a>..260                     {Tag2, S2} = tokenize_textarea(B, S1),
</span><span class="covered"><a name="line261"></a>..261                     tokens(B, S2, [Tag2, Tag | Acc]);
</span><span class="marked"><a name="line262"></a>..262                 none ->
</span><span class="covered"><a name="line263"></a>..263                     tokens(B, S1, [Tag | Acc])
</span><span class="marked"><a name="line264"></a>..264             end
</span><span class="marked"><a name="line265"></a>..265     end.
</span><span class="marked"><a name="line266"></a>..266 
</span><span class="marked"><a name="line267"></a>..267 parse_flag({start_tag, B, _, false}) ->
</span><span class="covered"><a name="line268"></a>..268     case string:to_lower(binary_to_list(B)) of
</span><span class="marked"><a name="line269"></a>..269         "script" ->
</span><span class="covered"><a name="line270"></a>..270             script;
</span><span class="marked"><a name="line271"></a>..271         "textarea" ->
</span><span class="covered"><a name="line272"></a>..272             textarea;
</span><span class="marked"><a name="line273"></a>..273         _ ->
</span><span class="covered"><a name="line274"></a>..274             none
</span><span class="marked"><a name="line275"></a>..275     end;
</span><span class="marked"><a name="line276"></a>..276 parse_flag(_) ->
</span><span class="covered"><a name="line277"></a>..277     none.
</span><span class="marked"><a name="line278"></a>..278 
</span><span class="marked"><a name="line279"></a>..279 tokenize(B, S=#decoder{offset=O}) ->
</span><span class="covered"><a name="line280"></a>..280     case B of
</span><span class="marked"><a name="line281"></a>..281         <<_:O/binary, "<!--", _/binary>> ->
</span><span class="covered"><a name="line282"></a>..282             tokenize_comment(B, ?ADV_COL(S, 4));
</span><span class="marked"><a name="line283"></a>..283         <<_:O/binary, "<!DOCTYPE", _/binary>> ->
</span><span class="uncovered"><a name="line284"></a>..284             tokenize_doctype(B, ?ADV_COL(S, 10));
</span><span class="marked"><a name="line285"></a>..285         <<_:O/binary, "<![CDATA[", _/binary>> ->
</span><span class="uncovered"><a name="line286"></a>..286             tokenize_cdata(B, ?ADV_COL(S, 9));
</span><span class="marked"><a name="line287"></a>..287         <<_:O/binary, "<?", _/binary>> ->
</span><span class="uncovered"><a name="line288"></a>..288             {Tag, S1} = tokenize_literal(B, ?ADV_COL(S, 2)),
</span><span class="uncovered"><a name="line289"></a>..289             {Attrs, S2} = tokenize_attributes(B, S1),
</span><span class="uncovered"><a name="line290"></a>..290             S3 = find_qgt(B, S2),
</span><span class="uncovered"><a name="line291"></a>..291             {{pi, Tag, Attrs}, S3};
</span><span class="marked"><a name="line292"></a>..292         <<_:O/binary, "&", _/binary>> ->
</span><span class="uncovered"><a name="line293"></a>..293             tokenize_charref(B, ?INC_COL(S));
</span><span class="marked"><a name="line294"></a>..294         <<_:O/binary, "</", _/binary>> ->
</span><span class="covered"><a name="line295"></a>..295             {Tag, S1} = tokenize_literal(B, ?ADV_COL(S, 2)),
</span><span class="covered"><a name="line296"></a>..296             {S2, _} = find_gt(B, S1),
</span><span class="covered"><a name="line297"></a>..297             {{end_tag, Tag}, S2};
</span><span class="marked"><a name="line298"></a>..298         <<_:O/binary, "<", C, _/binary>> when ?IS_WHITESPACE(C) ->
</span><span class="marked"><a name="line299"></a>..299             %% This isn't really strict HTML
</span><span class="uncovered"><a name="line300"></a>..300             tokenize_data(B, ?INC_COL(S));
</span><span class="marked"><a name="line301"></a>..301         <<_:O/binary, "<", _/binary>> ->
</span><span class="covered"><a name="line302"></a>..302             {Tag, S1} = tokenize_literal(B, ?INC_COL(S)),
</span><span class="covered"><a name="line303"></a>..303             {Attrs, S2} = tokenize_attributes(B, S1),
</span><span class="covered"><a name="line304"></a>..304             {S3, HasSlash} = find_gt(B, S2),
</span><span class="covered"><a name="line305"></a>..305             Singleton = HasSlash orelse is_singleton(norm(binary_to_list(Tag))),
</span><span class="covered"><a name="line306"></a>..306             {{start_tag, Tag, Attrs, Singleton}, S3};
</span><span class="marked"><a name="line307"></a>..307         _ ->
</span><span class="covered"><a name="line308"></a>..308             tokenize_data(B, S)
</span><span class="marked"><a name="line309"></a>..309     end.
</span><span class="marked"><a name="line310"></a>..310 
</span><span class="marked"><a name="line311"></a>..311 tree_data([{data, Data, Whitespace} | Rest], AllWhitespace, Acc) ->
</span><span class="uncovered"><a name="line312"></a>..312     tree_data(Rest, (Whitespace andalso AllWhitespace), [Data | Acc]);
</span><span class="marked"><a name="line313"></a>..313 tree_data(Rest, AllWhitespace, Acc) ->
</span><span class="uncovered"><a name="line314"></a>..314     {iolist_to_binary(lists:reverse(Acc)), AllWhitespace, Rest}.
</span><span class="marked"><a name="line315"></a>..315 
</span><span class="marked"><a name="line316"></a>..316 tree([], Stack) ->
</span><span class="uncovered"><a name="line317"></a>..317     {destack(Stack), []};
</span><span class="marked"><a name="line318"></a>..318 tree([{end_tag, Tag} | Rest], Stack) ->
</span><span class="uncovered"><a name="line319"></a>..319     case destack(norm(Tag), Stack) of
</span><span class="marked"><a name="line320"></a>..320         S when is_list(S) ->
</span><span class="uncovered"><a name="line321"></a>..321             tree(Rest, S);
</span><span class="marked"><a name="line322"></a>..322         Result ->
</span><span class="uncovered"><a name="line323"></a>..323             {Result, []}
</span><span class="marked"><a name="line324"></a>..324     end;
</span><span class="marked"><a name="line325"></a>..325 tree([{start_tag, Tag, Attrs, true} | Rest], S) ->
</span><span class="uncovered"><a name="line326"></a>..326     tree(Rest, append_stack_child(norm({Tag, Attrs}), S));
</span><span class="marked"><a name="line327"></a>..327 tree([{start_tag, Tag, Attrs, false} | Rest], S) ->
</span><span class="uncovered"><a name="line328"></a>..328     tree(Rest, stack(norm({Tag, Attrs}), S));
</span><span class="marked"><a name="line329"></a>..329 tree([T={pi, _Tag, _Attrs} | Rest], S) ->
</span><span class="uncovered"><a name="line330"></a>..330     tree(Rest, append_stack_child(T, S));
</span><span class="marked"><a name="line331"></a>..331 tree([T={comment, _Comment} | Rest], S) ->
</span><span class="uncovered"><a name="line332"></a>..332     tree(Rest, append_stack_child(T, S));
</span><span class="marked"><a name="line333"></a>..333 tree(L=[{data, _Data, _Whitespace} | _], S) ->
</span><span class="uncovered"><a name="line334"></a>..334     case tree_data(L, true, []) of
</span><span class="marked"><a name="line335"></a>..335         {_, true, Rest} -> 
</span><span class="uncovered"><a name="line336"></a>..336             tree(Rest, S);
</span><span class="marked"><a name="line337"></a>..337         {Data, false, Rest} ->
</span><span class="uncovered"><a name="line338"></a>..338             tree(Rest, append_stack_child(Data, S))
</span><span class="marked"><a name="line339"></a>..339     end.
</span><span class="marked"><a name="line340"></a>..340 
</span><span class="marked"><a name="line341"></a>..341 norm({Tag, Attrs}) ->
</span><span class="uncovered"><a name="line342"></a>..342     {norm(Tag), [{norm(K), iolist_to_binary(V)} || {K, V} <- Attrs], []};
</span><span class="marked"><a name="line343"></a>..343 norm(Tag) when is_binary(Tag) ->
</span><span class="covered"><a name="line344"></a>..344     Tag;
</span><span class="marked"><a name="line345"></a>..345 norm(Tag) ->
</span><span class="covered"><a name="line346"></a>..346     list_to_binary(string:to_lower(Tag)).
</span><span class="marked"><a name="line347"></a>..347 
</span><span class="marked"><a name="line348"></a>..348 stack(T1={TN, _, _}, Stack=[{TN, _, _} | _Rest])
</span><span class="marked"><a name="line349"></a>..349   when TN =:= <<"li">> orelse TN =:= <<"option">> ->
</span><span class="uncovered"><a name="line350"></a>..350     [T1 | destack(TN, Stack)];
</span><span class="marked"><a name="line351"></a>..351 stack(T1={TN0, _, _}, Stack=[{TN1, _, _} | _Rest])
</span><span class="marked"><a name="line352"></a>..352   when (TN0 =:= <<"dd">> orelse TN0 =:= <<"dt">>) andalso
</span><span class="marked"><a name="line353"></a>..353        (TN1 =:= <<"dd">> orelse TN1 =:= <<"dt">>) ->
</span><span class="uncovered"><a name="line354"></a>..354     [T1 | destack(TN1, Stack)];
</span><span class="marked"><a name="line355"></a>..355 stack(T1, Stack) ->
</span><span class="uncovered"><a name="line356"></a>..356     [T1 | Stack].
</span><span class="marked"><a name="line357"></a>..357 
</span><span class="marked"><a name="line358"></a>..358 append_stack_child(StartTag, [{Name, Attrs, Acc} | Stack]) ->
</span><span class="uncovered"><a name="line359"></a>..359     [{Name, Attrs, [StartTag | Acc]} | Stack].
</span><span class="marked"><a name="line360"></a>..360 
</span><span class="marked"><a name="line361"></a>..361 destack(TagName, Stack) when is_list(Stack) ->
</span><span class="uncovered"><a name="line362"></a>..362     F = fun (X) ->
</span><span class="uncovered"><a name="line363"></a>..363                 case X of
</span><span class="marked"><a name="line364"></a>..364                     {TagName, _, _} ->
</span><span class="uncovered"><a name="line365"></a>..365                         false;
</span><span class="marked"><a name="line366"></a>..366                     _ ->
</span><span class="uncovered"><a name="line367"></a>..367                         true
</span><span class="marked"><a name="line368"></a>..368                 end
</span><span class="marked"><a name="line369"></a>..369         end,
</span><span class="uncovered"><a name="line370"></a>..370     case lists:splitwith(F, Stack) of
</span><span class="marked"><a name="line371"></a>..371         {_, []} ->
</span><span class="marked"><a name="line372"></a>..372             %% If we're parsing something like XML we might find
</span><span class="marked"><a name="line373"></a>..373             %% a <link>tag</link> that is normally a singleton
</span><span class="marked"><a name="line374"></a>..374             %% in HTML but isn't here
</span><span class="uncovered"><a name="line375"></a>..375             case {is_singleton(TagName), Stack} of
</span><span class="marked"><a name="line376"></a>..376                 {true, [{T0, A0, Acc0} | Post0]} ->
</span><span class="uncovered"><a name="line377"></a>..377                     case lists:splitwith(F, Acc0) of
</span><span class="marked"><a name="line378"></a>..378                         {_, []} ->
</span><span class="marked"><a name="line379"></a>..379                             %% Actually was a singleton
</span><span class="uncovered"><a name="line380"></a>..380                             Stack;
</span><span class="marked"><a name="line381"></a>..381                         {Pre, [{T1, A1, []} | Post1]} ->
</span><span class="uncovered"><a name="line382"></a>..382                             [{T0, A0, [{T1, A1, lists:reverse(Pre)} | Post1]}
</span><span class="marked"><a name="line383"></a>..383                              | Post0]
</span><span class="marked"><a name="line384"></a>..384                     end;
</span><span class="marked"><a name="line385"></a>..385                 _ ->
</span><span class="marked"><a name="line386"></a>..386                     %% No match, no state change
</span><span class="uncovered"><a name="line387"></a>..387                     Stack
</span><span class="marked"><a name="line388"></a>..388             end;
</span><span class="marked"><a name="line389"></a>..389         {_Pre, [_T]} ->
</span><span class="marked"><a name="line390"></a>..390             %% Unfurl the whole stack, we're done
</span><span class="uncovered"><a name="line391"></a>..391             destack(Stack);
</span><span class="marked"><a name="line392"></a>..392         {Pre, [T, {T0, A0, Acc0} | Post]} ->
</span><span class="marked"><a name="line393"></a>..393             %% Unfurl up to the tag, then accumulate it
</span><span class="uncovered"><a name="line394"></a>..394             [{T0, A0, [destack(Pre ++ [T]) | Acc0]} | Post]
</span><span class="marked"><a name="line395"></a>..395     end.
</span><span class="marked"><a name="line396"></a>..396 
</span><span class="marked"><a name="line397"></a>..397 destack([{Tag, Attrs, Acc}]) ->
</span><span class="uncovered"><a name="line398"></a>..398     {Tag, Attrs, lists:reverse(Acc)};
</span><span class="marked"><a name="line399"></a>..399 destack([{T1, A1, Acc1}, {T0, A0, Acc0} | Rest]) ->
</span><span class="uncovered"><a name="line400"></a>..400     destack([{T0, A0, [{T1, A1, lists:reverse(Acc1)} | Acc0]} | Rest]).
</span><span class="marked"><a name="line401"></a>..401 
</span><span class="covered"><a name="line402"></a>..402 is_singleton(<<"br">>) -> true;
</span><span class="uncovered"><a name="line403"></a>..403 is_singleton(<<"hr">>) -> true;
</span><span class="uncovered"><a name="line404"></a>..404 is_singleton(<<"img">>) -> true;
</span><span class="uncovered"><a name="line405"></a>..405 is_singleton(<<"input">>) -> true;
</span><span class="uncovered"><a name="line406"></a>..406 is_singleton(<<"base">>) -> true;
</span><span class="uncovered"><a name="line407"></a>..407 is_singleton(<<"meta">>) -> true;
</span><span class="covered"><a name="line408"></a>..408 is_singleton(<<"link">>) -> true;
</span><span class="uncovered"><a name="line409"></a>..409 is_singleton(<<"area">>) -> true;
</span><span class="uncovered"><a name="line410"></a>..410 is_singleton(<<"param">>) -> true;
</span><span class="uncovered"><a name="line411"></a>..411 is_singleton(<<"col">>) -> true;
</span><span class="covered"><a name="line412"></a>..412 is_singleton(_) -> false.
</span><span class="marked"><a name="line413"></a>..413 
</span><span class="marked"><a name="line414"></a>..414 tokenize_data(B, S=#decoder{offset=O}) ->
</span><span class="covered"><a name="line415"></a>..415     tokenize_data(B, S, O, true).
</span><span class="marked"><a name="line416"></a>..416 
</span><span class="marked"><a name="line417"></a>..417 tokenize_data(B, S=#decoder{offset=O}, Start, Whitespace) ->
</span><span class="covered"><a name="line418"></a>..418     case B of
</span><span class="marked"><a name="line419"></a>..419         <<_:O/binary, C, _/binary>> when (C =/= $< andalso C =/= $&) ->
</span><span class="covered"><a name="line420"></a>..420             tokenize_data(B, ?INC_CHAR(S, C), Start,
</span><span class="covered"><a name="line421"></a>..421                           (Whitespace andalso ?IS_WHITESPACE(C)));
</span><span class="marked"><a name="line422"></a>..422         _ ->
</span><span class="covered"><a name="line423"></a>..423             Len = O - Start,
</span><span class="covered"><a name="line424"></a>..424             <<_:Start/binary, Data:Len/binary, _/binary>> = B,
</span><span class="covered"><a name="line425"></a>..425             {{data, Data, Whitespace}, S}
</span><span class="marked"><a name="line426"></a>..426     end.
</span><span class="marked"><a name="line427"></a>..427 
</span><span class="marked"><a name="line428"></a>..428 tokenize_attributes(B, S) ->
</span><span class="covered"><a name="line429"></a>..429     tokenize_attributes(B, S, []).
</span><span class="marked"><a name="line430"></a>..430 
</span><span class="marked"><a name="line431"></a>..431 tokenize_attributes(B, S=#decoder{offset=O}, Acc) ->
</span><span class="covered"><a name="line432"></a>..432     case B of
</span><span class="marked"><a name="line433"></a>..433         <<_:O/binary>> ->
</span><span class="uncovered"><a name="line434"></a>..434             {lists:reverse(Acc), S};
</span><span class="marked"><a name="line435"></a>..435         <<_:O/binary, C, _/binary>> when (C =:= $> orelse C =:= $/) ->
</span><span class="covered"><a name="line436"></a>..436             {lists:reverse(Acc), S};
</span><span class="marked"><a name="line437"></a>..437         <<_:O/binary, "?>", _/binary>> ->
</span><span class="uncovered"><a name="line438"></a>..438             {lists:reverse(Acc), S};
</span><span class="marked"><a name="line439"></a>..439         <<_:O/binary, C, _/binary>> when ?IS_WHITESPACE(C) ->
</span><span class="covered"><a name="line440"></a>..440             tokenize_attributes(B, ?INC_CHAR(S, C), Acc);
</span><span class="marked"><a name="line441"></a>..441         _ ->
</span><span class="covered"><a name="line442"></a>..442             {Attr, S1} = tokenize_literal(B, S),
</span><span class="covered"><a name="line443"></a>..443             {Value, S2} = tokenize_attr_value(Attr, B, S1),
</span><span class="covered"><a name="line444"></a>..444             tokenize_attributes(B, S2, [{Attr, Value} | Acc])
</span><span class="marked"><a name="line445"></a>..445     end.
</span><span class="marked"><a name="line446"></a>..446 
</span><span class="marked"><a name="line447"></a>..447 tokenize_attr_value(Attr, B, S) ->
</span><span class="covered"><a name="line448"></a>..448     S1 = skip_whitespace(B, S),
</span><span class="covered"><a name="line449"></a>..449     O = S1#decoder.offset,
</span><span class="covered"><a name="line450"></a>..450     case B of
</span><span class="marked"><a name="line451"></a>..451         <<_:O/binary, "=", _/binary>> ->
</span><span class="covered"><a name="line452"></a>..452             tokenize_word_or_literal(B, ?INC_COL(S1));
</span><span class="marked"><a name="line453"></a>..453         _ ->
</span><span class="uncovered"><a name="line454"></a>..454             {Attr, S1}
</span><span class="marked"><a name="line455"></a>..455     end.
</span><span class="marked"><a name="line456"></a>..456 
</span><span class="marked"><a name="line457"></a>..457 skip_whitespace(B, S=#decoder{offset=O}) ->
</span><span class="covered"><a name="line458"></a>..458     case B of
</span><span class="marked"><a name="line459"></a>..459         <<_:O/binary, C, _/binary>> when ?IS_WHITESPACE(C) ->
</span><span class="uncovered"><a name="line460"></a>..460             skip_whitespace(B, ?INC_CHAR(S, C));
</span><span class="marked"><a name="line461"></a>..461         _ ->
</span><span class="covered"><a name="line462"></a>..462             S
</span><span class="marked"><a name="line463"></a>..463     end.
</span><span class="marked"><a name="line464"></a>..464 
</span><span class="marked"><a name="line465"></a>..465 tokenize_literal(Bin, S) ->
</span><span class="covered"><a name="line466"></a>..466     tokenize_literal(Bin, S, []).
</span><span class="marked"><a name="line467"></a>..467 
</span><span class="marked"><a name="line468"></a>..468 tokenize_literal(Bin, S=#decoder{offset=O}, Acc) ->
</span><span class="covered"><a name="line469"></a>..469     case Bin of
</span><span class="marked"><a name="line470"></a>..470         <<_:O/binary, $&, _/binary>> ->
</span><span class="uncovered"><a name="line471"></a>..471             {{data, Data, false}, S1} = tokenize_charref(Bin, ?INC_COL(S)),
</span><span class="uncovered"><a name="line472"></a>..472             tokenize_literal(Bin, S1, [Data | Acc]);
</span><span class="marked"><a name="line473"></a>..473         <<_:O/binary, C, _/binary>> when not (?IS_WHITESPACE(C)
</span><span class="marked"><a name="line474"></a>..474                                               orelse C =:= $>
</span><span class="marked"><a name="line475"></a>..475                                               orelse C =:= $/
</span><span class="marked"><a name="line476"></a>..476                                               orelse C =:= $=) ->
</span><span class="covered"><a name="line477"></a>..477             tokenize_literal(Bin, ?INC_COL(S), [C | Acc]);
</span><span class="marked"><a name="line478"></a>..478         _ ->
</span><span class="covered"><a name="line479"></a>..479             {iolist_to_binary(lists:reverse(Acc)), S}
</span><span class="marked"><a name="line480"></a>..480     end.
</span><span class="marked"><a name="line481"></a>..481 
</span><span class="marked"><a name="line482"></a>..482 find_qgt(Bin, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line483"></a>..483     case Bin of
</span><span class="marked"><a name="line484"></a>..484         <<_:O/binary, "?>", _/binary>> ->
</span><span class="uncovered"><a name="line485"></a>..485             ?ADV_COL(S, 2);
</span><span class="marked"><a name="line486"></a>..486         <<_:O/binary, C, _/binary>> ->
</span><span class="uncovered"><a name="line487"></a>..487             find_qgt(Bin, ?INC_CHAR(S, C));
</span><span class="marked"><a name="line488"></a>..488         _ ->
</span><span class="uncovered"><a name="line489"></a>..489             S
</span><span class="marked"><a name="line490"></a>..490     end.
</span><span class="marked"><a name="line491"></a>..491 
</span><span class="marked"><a name="line492"></a>..492 find_gt(Bin, S) ->
</span><span class="covered"><a name="line493"></a>..493     find_gt(Bin, S, false).
</span><span class="marked"><a name="line494"></a>..494 
</span><span class="marked"><a name="line495"></a>..495 find_gt(Bin, S=#decoder{offset=O}, HasSlash) ->
</span><span class="covered"><a name="line496"></a>..496     case Bin of
</span><span class="marked"><a name="line497"></a>..497         <<_:O/binary, $/, _/binary>> ->
</span><span class="covered"><a name="line498"></a>..498             find_gt(Bin, ?INC_COL(S), true);
</span><span class="marked"><a name="line499"></a>..499         <<_:O/binary, $>, _/binary>> ->
</span><span class="covered"><a name="line500"></a>..500             {?INC_COL(S), HasSlash};
</span><span class="marked"><a name="line501"></a>..501         <<_:O/binary, C, _/binary>> ->
</span><span class="uncovered"><a name="line502"></a>..502             find_gt(Bin, ?INC_CHAR(S, C), HasSlash);
</span><span class="marked"><a name="line503"></a>..503         _ ->
</span><span class="uncovered"><a name="line504"></a>..504             {S, HasSlash}
</span><span class="marked"><a name="line505"></a>..505     end.
</span><span class="marked"><a name="line506"></a>..506 
</span><span class="marked"><a name="line507"></a>..507 tokenize_charref(Bin, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line508"></a>..508     tokenize_charref(Bin, S, O).
</span><span class="marked"><a name="line509"></a>..509 
</span><span class="marked"><a name="line510"></a>..510 tokenize_charref(Bin, S=#decoder{offset=O}, Start) ->
</span><span class="uncovered"><a name="line511"></a>..511     case Bin of
</span><span class="marked"><a name="line512"></a>..512         <<_:O/binary>> ->
</span><span class="uncovered"><a name="line513"></a>..513             <<_:Start/binary, Raw/binary>> = Bin,
</span><span class="uncovered"><a name="line514"></a>..514             {{data, Raw, false}, S};
</span><span class="marked"><a name="line515"></a>..515         <<_:O/binary, C, _/binary>> when ?IS_WHITESPACE(C)
</span><span class="marked"><a name="line516"></a>..516                                          orelse C =:= ?SQUOTE
</span><span class="marked"><a name="line517"></a>..517                                          orelse C =:= ?QUOTE
</span><span class="marked"><a name="line518"></a>..518                                          orelse C =:= $/
</span><span class="marked"><a name="line519"></a>..519                                          orelse C =:= $> ->
</span><span class="uncovered"><a name="line520"></a>..520             Len = O - Start,
</span><span class="uncovered"><a name="line521"></a>..521             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="uncovered"><a name="line522"></a>..522             {{data, Raw, false}, S};
</span><span class="marked"><a name="line523"></a>..523         <<_:O/binary, $;, _/binary>> ->
</span><span class="uncovered"><a name="line524"></a>..524             Len = O - Start,
</span><span class="uncovered"><a name="line525"></a>..525             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="uncovered"><a name="line526"></a>..526             Data = case mochiweb_charref:charref(Raw) of
</span><span class="marked"><a name="line527"></a>..527                        undefined ->
</span><span class="uncovered"><a name="line528"></a>..528                            Start1 = Start - 1,
</span><span class="uncovered"><a name="line529"></a>..529                            Len1 = Len + 2,
</span><span class="uncovered"><a name="line530"></a>..530                            <<_:Start1/binary, R:Len1/binary, _/binary>> = Bin,
</span><span class="uncovered"><a name="line531"></a>..531                            R;
</span><span class="marked"><a name="line532"></a>..532                        Unichar ->
</span><span class="uncovered"><a name="line533"></a>..533                            list_to_binary(xmerl_ucs:to_utf8(Unichar))
</span><span class="marked"><a name="line534"></a>..534                    end,
</span><span class="uncovered"><a name="line535"></a>..535             {{data, Data, false}, ?INC_COL(S)};
</span><span class="marked"><a name="line536"></a>..536         _ ->
</span><span class="uncovered"><a name="line537"></a>..537             tokenize_charref(Bin, ?INC_COL(S), Start)
</span><span class="marked"><a name="line538"></a>..538     end.
</span><span class="marked"><a name="line539"></a>..539 
</span><span class="marked"><a name="line540"></a>..540 tokenize_doctype(Bin, S) ->
</span><span class="uncovered"><a name="line541"></a>..541     tokenize_doctype(Bin, S, []).
</span><span class="marked"><a name="line542"></a>..542 
</span><span class="marked"><a name="line543"></a>..543 tokenize_doctype(Bin, S=#decoder{offset=O}, Acc) ->
</span><span class="uncovered"><a name="line544"></a>..544     case Bin of
</span><span class="marked"><a name="line545"></a>..545         <<_:O/binary>> ->
</span><span class="uncovered"><a name="line546"></a>..546             {{doctype, lists:reverse(Acc)}, S};
</span><span class="marked"><a name="line547"></a>..547         <<_:O/binary, $>, _/binary>> ->
</span><span class="uncovered"><a name="line548"></a>..548             {{doctype, lists:reverse(Acc)}, ?INC_COL(S)};
</span><span class="marked"><a name="line549"></a>..549         <<_:O/binary, C, _/binary>> when ?IS_WHITESPACE(C) ->
</span><span class="uncovered"><a name="line550"></a>..550             tokenize_doctype(Bin, ?INC_CHAR(S, C), Acc);
</span><span class="marked"><a name="line551"></a>..551         _ ->
</span><span class="uncovered"><a name="line552"></a>..552             {Word, S1} = tokenize_word_or_literal(Bin, S),
</span><span class="uncovered"><a name="line553"></a>..553             tokenize_doctype(Bin, S1, [Word | Acc])
</span><span class="marked"><a name="line554"></a>..554     end.
</span><span class="marked"><a name="line555"></a>..555 
</span><span class="marked"><a name="line556"></a>..556 tokenize_word_or_literal(Bin, S=#decoder{offset=O}) ->
</span><span class="covered"><a name="line557"></a>..557     case Bin of
</span><span class="marked"><a name="line558"></a>..558         <<_:O/binary, C, _/binary>> when ?IS_WHITESPACE(C) ->
</span><span class="uncovered"><a name="line559"></a>..559             {error, {whitespace, [C], S}};
</span><span class="marked"><a name="line560"></a>..560         <<_:O/binary, C, _/binary>> when C =:= ?QUOTE orelse C =:= ?SQUOTE ->
</span><span class="covered"><a name="line561"></a>..561             tokenize_word(Bin, ?INC_COL(S), C);
</span><span class="marked"><a name="line562"></a>..562         _ ->
</span><span class="covered"><a name="line563"></a>..563             tokenize_literal(Bin, S, [])
</span><span class="marked"><a name="line564"></a>..564     end.
</span><span class="marked"><a name="line565"></a>..565 
</span><span class="marked"><a name="line566"></a>..566 tokenize_word(Bin, S, Quote) ->
</span><span class="covered"><a name="line567"></a>..567     tokenize_word(Bin, S, Quote, []).
</span><span class="marked"><a name="line568"></a>..568 
</span><span class="marked"><a name="line569"></a>..569 tokenize_word(Bin, S=#decoder{offset=O}, Quote, Acc) ->
</span><span class="covered"><a name="line570"></a>..570     case Bin of
</span><span class="marked"><a name="line571"></a>..571         <<_:O/binary>> ->
</span><span class="uncovered"><a name="line572"></a>..572             {iolist_to_binary(lists:reverse(Acc)), S};
</span><span class="marked"><a name="line573"></a>..573         <<_:O/binary, Quote, _/binary>> ->
</span><span class="covered"><a name="line574"></a>..574             {iolist_to_binary(lists:reverse(Acc)), ?INC_COL(S)};
</span><span class="marked"><a name="line575"></a>..575         <<_:O/binary, $&, _/binary>> ->
</span><span class="uncovered"><a name="line576"></a>..576             {{data, Data, false}, S1} = tokenize_charref(Bin, ?INC_COL(S)),
</span><span class="uncovered"><a name="line577"></a>..577             tokenize_word(Bin, S1, Quote, [Data | Acc]);
</span><span class="marked"><a name="line578"></a>..578         <<_:O/binary, C, _/binary>> ->
</span><span class="covered"><a name="line579"></a>..579             tokenize_word(Bin, ?INC_CHAR(S, C), Quote, [C | Acc])
</span><span class="marked"><a name="line580"></a>..580     end.
</span><span class="marked"><a name="line581"></a>..581 
</span><span class="marked"><a name="line582"></a>..582 tokenize_cdata(Bin, S=#decoder{offset=O}) ->
</span><span class="uncovered"><a name="line583"></a>..583     tokenize_cdata(Bin, S, O).
</span><span class="marked"><a name="line584"></a>..584 
</span><span class="marked"><a name="line585"></a>..585 tokenize_cdata(Bin, S=#decoder{offset=O}, Start) ->
</span><span class="uncovered"><a name="line586"></a>..586     case Bin of
</span><span class="marked"><a name="line587"></a>..587         <<_:O/binary, "]]>", _/binary>> ->
</span><span class="uncovered"><a name="line588"></a>..588             Len = O - Start,
</span><span class="uncovered"><a name="line589"></a>..589             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="uncovered"><a name="line590"></a>..590             {{data, Raw, false}, ?ADV_COL(S, 3)};
</span><span class="marked"><a name="line591"></a>..591         <<_:O/binary, C, _/binary>> ->
</span><span class="uncovered"><a name="line592"></a>..592             tokenize_cdata(Bin, ?INC_CHAR(S, C), Start);
</span><span class="marked"><a name="line593"></a>..593         _ ->
</span><span class="uncovered"><a name="line594"></a>..594             <<_:O/binary, Raw/binary>> = Bin,
</span><span class="uncovered"><a name="line595"></a>..595             {{data, Raw, false}, S}
</span><span class="marked"><a name="line596"></a>..596     end.
</span><span class="marked"><a name="line597"></a>..597 
</span><span class="marked"><a name="line598"></a>..598 tokenize_comment(Bin, S=#decoder{offset=O}) ->
</span><span class="covered"><a name="line599"></a>..599     tokenize_comment(Bin, S, O).
</span><span class="marked"><a name="line600"></a>..600 
</span><span class="marked"><a name="line601"></a>..601 tokenize_comment(Bin, S=#decoder{offset=O}, Start) ->
</span><span class="covered"><a name="line602"></a>..602     case Bin of
</span><span class="marked"><a name="line603"></a>..603         <<_:O/binary, "-->", _/binary>> ->
</span><span class="covered"><a name="line604"></a>..604             Len = O - Start,
</span><span class="covered"><a name="line605"></a>..605             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="covered"><a name="line606"></a>..606             {{comment, Raw}, ?ADV_COL(S, 3)};
</span><span class="marked"><a name="line607"></a>..607         <<_:O/binary, C, _/binary>> ->
</span><span class="covered"><a name="line608"></a>..608             tokenize_comment(Bin, ?INC_CHAR(S, C), Start);
</span><span class="marked"><a name="line609"></a>..609         <<_:Start/binary, Raw/binary>> ->
</span><span class="uncovered"><a name="line610"></a>..610             {{comment, Raw}, S}
</span><span class="marked"><a name="line611"></a>..611     end.
</span><span class="marked"><a name="line612"></a>..612 
</span><span class="marked"><a name="line613"></a>..613 tokenize_script(Bin, S=#decoder{offset=O}) ->
</span><span class="covered"><a name="line614"></a>..614     tokenize_script(Bin, S, O).
</span><span class="marked"><a name="line615"></a>..615 
</span><span class="marked"><a name="line616"></a>..616 tokenize_script(Bin, S=#decoder{offset=O}, Start) ->
</span><span class="covered"><a name="line617"></a>..617     case Bin of
</span><span class="marked"><a name="line618"></a>..618         %% Just a look-ahead, we want the end_tag separately
</span><span class="marked"><a name="line619"></a>..619         <<_:O/binary, $<, $/, SS, CC, RR, II, PP, TT, _/binary>>
</span><span class="marked"><a name="line620"></a>..620         when (SS =:= $s orelse SS =:= $S) andalso
</span><span class="marked"><a name="line621"></a>..621              (CC =:= $c orelse CC =:= $C) andalso
</span><span class="marked"><a name="line622"></a>..622              (RR =:= $r orelse RR =:= $R) andalso
</span><span class="marked"><a name="line623"></a>..623              (II =:= $i orelse II =:= $I) andalso
</span><span class="marked"><a name="line624"></a>..624              (PP =:= $p orelse PP =:= $P) andalso
</span><span class="marked"><a name="line625"></a>..625              (TT=:= $t orelse TT =:= $T) ->
</span><span class="covered"><a name="line626"></a>..626             Len = O - Start,
</span><span class="covered"><a name="line627"></a>..627             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="covered"><a name="line628"></a>..628             {{data, Raw, false}, S};
</span><span class="marked"><a name="line629"></a>..629         <<_:O/binary, C, _/binary>> ->
</span><span class="covered"><a name="line630"></a>..630             tokenize_script(Bin, ?INC_CHAR(S, C), Start);
</span><span class="marked"><a name="line631"></a>..631         <<_:Start/binary, Raw/binary>> ->
</span><span class="uncovered"><a name="line632"></a>..632             {{data, Raw, false}, S}
</span><span class="marked"><a name="line633"></a>..633     end.
</span><span class="marked"><a name="line634"></a>..634 
</span><span class="marked"><a name="line635"></a>..635 tokenize_textarea(Bin, S=#decoder{offset=O}) ->
</span><span class="covered"><a name="line636"></a>..636     tokenize_textarea(Bin, S, O).
</span><span class="marked"><a name="line637"></a>..637 
</span><span class="marked"><a name="line638"></a>..638 tokenize_textarea(Bin, S=#decoder{offset=O}, Start) ->
</span><span class="covered"><a name="line639"></a>..639     case Bin of
</span><span class="marked"><a name="line640"></a>..640         %% Just a look-ahead, we want the end_tag separately
</span><span class="marked"><a name="line641"></a>..641         <<_:O/binary, $<, $/, TT, EE, XX, TT2, AA, RR, EE2, AA2, _/binary>>
</span><span class="marked"><a name="line642"></a>..642         when (TT =:= $t orelse TT =:= $T) andalso
</span><span class="marked"><a name="line643"></a>..643              (EE =:= $e orelse EE =:= $E) andalso
</span><span class="marked"><a name="line644"></a>..644              (XX =:= $x orelse XX =:= $X) andalso
</span><span class="marked"><a name="line645"></a>..645              (TT2 =:= $t orelse TT2 =:= $T) andalso
</span><span class="marked"><a name="line646"></a>..646              (AA =:= $a orelse AA =:= $A) andalso
</span><span class="marked"><a name="line647"></a>..647              (RR =:= $r orelse RR =:= $R) andalso
</span><span class="marked"><a name="line648"></a>..648              (EE2 =:= $e orelse EE2 =:= $E) andalso
</span><span class="marked"><a name="line649"></a>..649              (AA2 =:= $a orelse AA2 =:= $A) ->
</span><span class="covered"><a name="line650"></a>..650             Len = O - Start,
</span><span class="covered"><a name="line651"></a>..651             <<_:Start/binary, Raw:Len/binary, _/binary>> = Bin,
</span><span class="covered"><a name="line652"></a>..652             {{data, Raw, false}, S};
</span><span class="marked"><a name="line653"></a>..653         <<_:O/binary, C, _/binary>> ->
</span><span class="covered"><a name="line654"></a>..654             tokenize_textarea(Bin, ?INC_CHAR(S, C), Start);
</span><span class="marked"><a name="line655"></a>..655         <<_:Start/binary, Raw/binary>> ->
</span><span class="uncovered"><a name="line656"></a>..656             {{data, Raw, false}, S}
</span><span class="marked"><a name="line657"></a>..657     end.
</span></pre><hr /><p>Generated using <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.</p>
          </body>
        </html>
    