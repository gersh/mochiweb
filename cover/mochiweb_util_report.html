<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
          <head>
            <title>mochiweb_util - C0 code coverage information</title>
            <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
            <style type='text/css'>span.marked0 {
     background-color: rgb(185, 210, 200);
     display: block;
    }
    span.marked { display: block; background-color: #ffffff; }
    span.highlight { display: block; background-color: #fff9d7; }
    span.covered { display: block; background-color: #f7f7f7 ; }
    span.uncovered { display: block; background-color: #ffebe8 ; }
    span.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    div.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    body {
     font-family: verdana, arial, helvetica;
    }
    div.footer {
     font-size: 68%;
     margin-top: 1.5em;
    }
    h1, h2, h3, h4, h5, h6 {
     margin-bottom: 0.5em;
    }
    h5 {
     margin-top: 0.5em;
    }
    .hidden {
     display: none;
    }
    div.separator {
     height: 10px;
    }
    table.percent_graph {
     height: 12px;
     border: 1px solid #E2E6EF; 
     empty-cells: show;
    }
    table.percent_graph td.covered {
     height: 10px;
     background: #00f000;
    }
    table.percent_graph td.uncovered {
     height: 10px;
     background: #e00000;
    }
    table.percent_graph td.NA {
     height: 10px;
     background: #eaeaea;
    }
    table.report {
     border-collapse: collapse;
     width: 100%;
    }
    table.report td.heading {
     background: #dcecff;
     border: 1px solid #E2E6EF; 
     font-weight: bold;
     text-align: center;
    }
    table.report td.heading:hover {
     background: #c0ffc0;
    }
    table.report td.text {
     border: 1px solid #E2E6EF; 
    }
    table.report td.value {
     text-align: right;
     border: 1px solid #E2E6EF; 
    }
    table.report tr.light {
     background-color: rgb(240, 240, 245);
    }
    table.report tr.dark {
     background-color: rgb(230, 230, 235);
    }
    </style>
          </head>
          <body>
            <h3>C0 code coverage information</h3>
            <p>Generated on 2009-02-25 01:24:47 with <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.
            </p>            
        <table class='report'>
          <thead>
            <tr>
              <td class='heading'>Name</td>
              <td class='heading'>Total lines</td>
              <td class='heading'>Lines of code</td>
              <td class='heading'>Total coverage</td>
              <td class='heading'>Code coverage</td>
            </tr>
          </thead>
          <tbody>
            <tr class='light'>

              <td>
                <a href='mochiweb_util_report.html'>mochiweb_util</a>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td>
                <table cellspacing='0' cellpadding='0' align='right'>
                  <tr>
                    <td><tt>70%</tt>&nbsp;</td><td>
                      <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                      <tr><td class='covered' width='70' /><td class='uncovered' width='30' /></tr>
                      </table>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </tbody>
        </table><pre><span class="marked"><a name="line1"></a>....1 %% @author Bob Ippolito <bob@mochimedia.com>
</span><span class="marked"><a name="line2"></a>....2 %% @copyright 2007 Mochi Media, Inc.
</span><span class="marked"><a name="line3"></a>....3 
</span><span class="marked"><a name="line4"></a>....4 %% @doc Utilities for parsing and quoting.
</span><span class="marked"><a name="line5"></a>....5 
</span><span class="marked"><a name="line6"></a>....6 -module(mochiweb_util).
</span><span class="marked"><a name="line7"></a>....7 -author('bob@mochimedia.com').
</span><span class="marked"><a name="line8"></a>....8 -export([join/2, quote_plus/1, urlencode/1, parse_qs/1, unquote/1]).
</span><span class="marked"><a name="line9"></a>....9 -export([path_split/1]).
</span><span class="marked"><a name="line10"></a>...10 -export([urlsplit/1, urlsplit_path/1, urlunsplit/1, urlunsplit_path/1]).
</span><span class="marked"><a name="line11"></a>...11 -export([guess_mime/1, parse_header/1]).
</span><span class="marked"><a name="line12"></a>...12 -export([shell_quote/1, cmd/1, cmd_string/1, cmd_port/2]).
</span><span class="marked"><a name="line13"></a>...13 -export([record_to_proplist/2, record_to_proplist/3]).
</span><span class="marked"><a name="line14"></a>...14 -export([safe_relative_path/1, partition/2]).
</span><span class="marked"><a name="line15"></a>...15 -export([is_atleast_version/1]).
</span><span class="marked"><a name="line16"></a>...16 
</span><span class="marked"><a name="line17"></a>...17 -define(PERCENT, 37).  % $\%
</span><span class="marked"><a name="line18"></a>...18 -define(FULLSTOP, 46). % $\.
</span><span class="marked"><a name="line19"></a>...19 -define(IS_HEX(C), ((C >= $0 andalso C =< $9) orelse
</span><span class="marked"><a name="line20"></a>...20                     (C >= $a andalso C =< $f) orelse
</span><span class="marked"><a name="line21"></a>...21                     (C >= $A andalso C =< $F))).
</span><span class="marked"><a name="line22"></a>...22 -define(QS_SAFE(C), ((C >= $a andalso C =< $z) orelse
</span><span class="marked"><a name="line23"></a>...23                      (C >= $A andalso C =< $Z) orelse
</span><span class="marked"><a name="line24"></a>...24                      (C >= $0 andalso C =< $9) orelse
</span><span class="marked"><a name="line25"></a>...25                      (C =:= ?FULLSTOP orelse C =:= $- orelse C =:= $~ orelse
</span><span class="marked"><a name="line26"></a>...26                       C =:= $_))).
</span><span class="marked"><a name="line27"></a>...27 
</span><span class="covered"><a name="line28"></a>...28 hexdigit(C) when C < 10 -> $0 + C;
</span><span class="covered"><a name="line29"></a>...29 hexdigit(C) when C < 16 -> $A + (C - 10).
</span><span class="marked"><a name="line30"></a>...30 
</span><span class="covered"><a name="line31"></a>...31 unhexdigit(C) when C >= $0, C =< $9 -> C - $0;
</span><span class="uncovered"><a name="line32"></a>...32 unhexdigit(C) when C >= $a, C =< $f -> C - $a + 10;
</span><span class="covered"><a name="line33"></a>...33 unhexdigit(C) when C >= $A, C =< $F -> C - $A + 10.
</span><span class="marked"><a name="line34"></a>...34 
</span><span class="marked"><a name="line35"></a>...35 %% @spec partition(String, Sep) -> {String, [], []} | {Prefix, Sep, Postfix}
</span><span class="marked"><a name="line36"></a>...36 %% @doc Inspired by Python 2.5's str.partition:
</span><span class="marked"><a name="line37"></a>...37 %%      partition("foo/bar", "/") = {"foo", "/", "bar"},
</span><span class="marked"><a name="line38"></a>...38 %%      partition("foo", "/") = {"foo", "", ""}.
</span><span class="marked"><a name="line39"></a>...39 partition(String, Sep) ->
</span><span class="covered"><a name="line40"></a>...40     case partition(String, Sep, []) of
</span><span class="marked"><a name="line41"></a>...41         undefined ->
</span><span class="covered"><a name="line42"></a>...42             {String, "", ""};
</span><span class="marked"><a name="line43"></a>...43         Result ->
</span><span class="covered"><a name="line44"></a>...44             Result
</span><span class="marked"><a name="line45"></a>...45     end.
</span><span class="marked"><a name="line46"></a>...46 
</span><span class="marked"><a name="line47"></a>...47 partition("", _Sep, _Acc) ->
</span><span class="covered"><a name="line48"></a>...48     undefined;
</span><span class="marked"><a name="line49"></a>...49 partition(S, Sep, Acc) ->
</span><span class="covered"><a name="line50"></a>...50     case partition2(S, Sep) of
</span><span class="marked"><a name="line51"></a>...51         undefined ->
</span><span class="covered"><a name="line52"></a>...52             [C | Rest] = S,
</span><span class="covered"><a name="line53"></a>...53             partition(Rest, Sep, [C | Acc]);
</span><span class="marked"><a name="line54"></a>...54         Rest ->
</span><span class="covered"><a name="line55"></a>...55             {lists:reverse(Acc), Sep, Rest}
</span><span class="marked"><a name="line56"></a>...56     end.
</span><span class="marked"><a name="line57"></a>...57 
</span><span class="marked"><a name="line58"></a>...58 partition2(Rest, "") ->
</span><span class="covered"><a name="line59"></a>...59     Rest;
</span><span class="marked"><a name="line60"></a>...60 partition2([C | R1], [C | R2]) ->
</span><span class="covered"><a name="line61"></a>...61     partition2(R1, R2);
</span><span class="marked"><a name="line62"></a>...62 partition2(_S, _Sep) ->
</span><span class="covered"><a name="line63"></a>...63     undefined.
</span><span class="marked"><a name="line64"></a>...64 
</span><span class="marked"><a name="line65"></a>...65 
</span><span class="marked"><a name="line66"></a>...66 
</span><span class="marked"><a name="line67"></a>...67 %% @spec safe_relative_path(string()) -> string() | undefined
</span><span class="marked"><a name="line68"></a>...68 %% @doc Return the reduced version of a relative path or undefined if it
</span><span class="marked"><a name="line69"></a>...69 %%      is not safe. safe relative paths can be joined with an absolute path
</span><span class="marked"><a name="line70"></a>...70 %%      and will result in a subdirectory of the absolute path.
</span><span class="marked"><a name="line71"></a>...71 safe_relative_path("/" ++ _) ->
</span><span class="covered"><a name="line72"></a>...72     undefined;
</span><span class="marked"><a name="line73"></a>...73 safe_relative_path(P) ->
</span><span class="covered"><a name="line74"></a>...74     safe_relative_path(P, []).
</span><span class="marked"><a name="line75"></a>...75 
</span><span class="marked"><a name="line76"></a>...76 safe_relative_path("", Acc) ->
</span><span class="covered"><a name="line77"></a>...77     case Acc of
</span><span class="marked"><a name="line78"></a>...78         [] ->
</span><span class="covered"><a name="line79"></a>...79             "";
</span><span class="marked"><a name="line80"></a>...80         _ ->
</span><span class="covered"><a name="line81"></a>...81           PathList = lists:reverse(Acc),
</span><span class="covered"><a name="line82"></a>...82           case is_atleast_version({5,6}) of
</span><span class="covered"><a name="line83"></a>...83             true -> string:join(PathList, "/");
</span><span class="uncovered"><a name="line84"></a>...84             false -> hd(PathList) ++ lists:concat(["/" ++ X || X <- tl(PathList)])
</span><span class="marked"><a name="line85"></a>...85           end
</span><span class="marked"><a name="line86"></a>...86     end;
</span><span class="marked"><a name="line87"></a>...87 safe_relative_path(P, Acc) ->
</span><span class="covered"><a name="line88"></a>...88     case partition(P, "/") of
</span><span class="marked"><a name="line89"></a>...89         {"", "/", _} ->
</span><span class="marked"><a name="line90"></a>...90             %% /foo or foo//bar
</span><span class="covered"><a name="line91"></a>...91             undefined;
</span><span class="marked"><a name="line92"></a>...92         {"..", _, _} when Acc =:= [] ->
</span><span class="covered"><a name="line93"></a>...93             undefined;
</span><span class="marked"><a name="line94"></a>...94         {"..", _, Rest} ->
</span><span class="covered"><a name="line95"></a>...95             safe_relative_path(Rest, tl(Acc));
</span><span class="marked"><a name="line96"></a>...96         {Part, "/", ""} ->
</span><span class="covered"><a name="line97"></a>...97             safe_relative_path("", ["", Part | Acc]);
</span><span class="marked"><a name="line98"></a>...98         {Part, _, Rest} ->
</span><span class="covered"><a name="line99"></a>...99             safe_relative_path(Rest, [Part | Acc])
</span><span class="marked"><a name="line100"></a>..100     end.
</span><span class="marked"><a name="line101"></a>..101 
</span><span class="marked"><a name="line102"></a>..102 %% @spec shell_quote(string()) -> string()
</span><span class="marked"><a name="line103"></a>..103 %% @doc Quote a string according to UNIX shell quoting rules, returns a string
</span><span class="marked"><a name="line104"></a>..104 %%      surrounded by double quotes.
</span><span class="marked"><a name="line105"></a>..105 shell_quote(L) ->
</span><span class="covered"><a name="line106"></a>..106     shell_quote(L, [$\"]).
</span><span class="marked"><a name="line107"></a>..107 
</span><span class="marked"><a name="line108"></a>..108 %% @spec cmd_port([string()], Options) -> port()
</span><span class="marked"><a name="line109"></a>..109 %% @doc open_port({spawn, mochiweb_util:cmd_string(Argv)}, Options).
</span><span class="marked"><a name="line110"></a>..110 cmd_port(Argv, Options) ->
</span><span class="uncovered"><a name="line111"></a>..111     open_port({spawn, cmd_string(Argv)}, Options).
</span><span class="marked"><a name="line112"></a>..112 
</span><span class="marked"><a name="line113"></a>..113 %% @spec cmd([string()]) -> string()
</span><span class="marked"><a name="line114"></a>..114 %% @doc os:cmd(cmd_string(Argv)).
</span><span class="marked"><a name="line115"></a>..115 cmd(Argv) ->
</span><span class="covered"><a name="line116"></a>..116     os:cmd(cmd_string(Argv)).
</span><span class="marked"><a name="line117"></a>..117 
</span><span class="marked"><a name="line118"></a>..118 %% @spec cmd_string([string()]) -> string()
</span><span class="marked"><a name="line119"></a>..119 %% @doc Create a shell quoted command string from a list of arguments.
</span><span class="marked"><a name="line120"></a>..120 cmd_string(Argv) ->
</span><span class="covered"><a name="line121"></a>..121     join([shell_quote(X) || X <- Argv], " ").
</span><span class="marked"><a name="line122"></a>..122 
</span><span class="marked"><a name="line123"></a>..123 %% @spec join([string()], Separator) -> string()
</span><span class="marked"><a name="line124"></a>..124 %% @doc Join a list of strings together with the given separator
</span><span class="marked"><a name="line125"></a>..125 %%      string or char.
</span><span class="marked"><a name="line126"></a>..126 join([], _Separator) ->
</span><span class="uncovered"><a name="line127"></a>..127     [];
</span><span class="marked"><a name="line128"></a>..128 join([S], _Separator) ->
</span><span class="covered"><a name="line129"></a>..129     lists:flatten(S);
</span><span class="marked"><a name="line130"></a>..130 join(Strings, Separator) ->
</span><span class="covered"><a name="line131"></a>..131     lists:flatten(revjoin(lists:reverse(Strings), Separator, [])).
</span><span class="marked"><a name="line132"></a>..132 
</span><span class="marked"><a name="line133"></a>..133 revjoin([], _Separator, Acc) ->
</span><span class="covered"><a name="line134"></a>..134     Acc;
</span><span class="marked"><a name="line135"></a>..135 revjoin([S | Rest], Separator, []) ->
</span><span class="covered"><a name="line136"></a>..136     revjoin(Rest, Separator, [S]);
</span><span class="marked"><a name="line137"></a>..137 revjoin([S | Rest], Separator, Acc) ->
</span><span class="covered"><a name="line138"></a>..138     revjoin(Rest, Separator, [S, Separator | Acc]).
</span><span class="marked"><a name="line139"></a>..139 
</span><span class="marked"><a name="line140"></a>..140 %% @spec quote_plus(atom() | integer() | float() | string() | binary()) -> string()
</span><span class="marked"><a name="line141"></a>..141 %% @doc URL safe encoding of the given term.
</span><span class="marked"><a name="line142"></a>..142 quote_plus(Atom) when is_atom(Atom) ->
</span><span class="covered"><a name="line143"></a>..143     quote_plus(atom_to_list(Atom));
</span><span class="marked"><a name="line144"></a>..144 quote_plus(Int) when is_integer(Int) ->
</span><span class="covered"><a name="line145"></a>..145     quote_plus(integer_to_list(Int));
</span><span class="marked"><a name="line146"></a>..146 quote_plus(Binary) when is_binary(Binary) ->
</span><span class="uncovered"><a name="line147"></a>..147     quote_plus(binary_to_list(Binary));
</span><span class="marked"><a name="line148"></a>..148 quote_plus(Float) when is_float(Float) ->
</span><span class="covered"><a name="line149"></a>..149     quote_plus(mochinum:digits(Float));
</span><span class="marked"><a name="line150"></a>..150 quote_plus(String) ->
</span><span class="covered"><a name="line151"></a>..151     quote_plus(String, []).
</span><span class="marked"><a name="line152"></a>..152 
</span><span class="marked"><a name="line153"></a>..153 quote_plus([], Acc) ->
</span><span class="covered"><a name="line154"></a>..154     lists:reverse(Acc);
</span><span class="marked"><a name="line155"></a>..155 quote_plus([C | Rest], Acc) when ?QS_SAFE(C) ->
</span><span class="covered"><a name="line156"></a>..156     quote_plus(Rest, [C | Acc]);
</span><span class="marked"><a name="line157"></a>..157 quote_plus([$\s | Rest], Acc) ->
</span><span class="covered"><a name="line158"></a>..158     quote_plus(Rest, [$+ | Acc]);
</span><span class="marked"><a name="line159"></a>..159 quote_plus([C | Rest], Acc) ->
</span><span class="covered"><a name="line160"></a>..160     <<Hi:4, Lo:4>> = <<C>>,
</span><span class="covered"><a name="line161"></a>..161     quote_plus(Rest, [hexdigit(Lo), hexdigit(Hi), ?PERCENT | Acc]).
</span><span class="marked"><a name="line162"></a>..162 
</span><span class="marked"><a name="line163"></a>..163 %% @spec urlencode([{Key, Value}]) -> string()
</span><span class="marked"><a name="line164"></a>..164 %% @doc URL encode the property list.
</span><span class="marked"><a name="line165"></a>..165 urlencode(Props) ->
</span><span class="covered"><a name="line166"></a>..166     RevPairs = lists:foldl(fun ({K, V}, Acc) ->
</span><span class="covered"><a name="line167"></a>..167                                    [[quote_plus(K), $=, quote_plus(V)] | Acc]
</span><span class="marked"><a name="line168"></a>..168                            end, [], Props),
</span><span class="covered"><a name="line169"></a>..169     lists:flatten(revjoin(RevPairs, $&, [])).
</span><span class="marked"><a name="line170"></a>..170 
</span><span class="marked"><a name="line171"></a>..171 %% @spec parse_qs(string() | binary()) -> [{Key, Value}]
</span><span class="marked"><a name="line172"></a>..172 %% @doc Parse a query string or application/x-www-form-urlencoded.
</span><span class="marked"><a name="line173"></a>..173 parse_qs(Binary) when is_binary(Binary) ->
</span><span class="uncovered"><a name="line174"></a>..174     parse_qs(binary_to_list(Binary));
</span><span class="marked"><a name="line175"></a>..175 parse_qs(String) ->
</span><span class="covered"><a name="line176"></a>..176     parse_qs(String, []).
</span><span class="marked"><a name="line177"></a>..177 
</span><span class="marked"><a name="line178"></a>..178 parse_qs([], Acc) ->
</span><span class="covered"><a name="line179"></a>..179     lists:reverse(Acc);
</span><span class="marked"><a name="line180"></a>..180 parse_qs(String, Acc) ->
</span><span class="covered"><a name="line181"></a>..181     {Key, Rest} = parse_qs_key(String),
</span><span class="covered"><a name="line182"></a>..182     {Value, Rest1} = parse_qs_value(Rest),
</span><span class="covered"><a name="line183"></a>..183     parse_qs(Rest1, [{Key, Value} | Acc]).
</span><span class="marked"><a name="line184"></a>..184 
</span><span class="marked"><a name="line185"></a>..185 parse_qs_key(String) ->
</span><span class="covered"><a name="line186"></a>..186     parse_qs_key(String, []).
</span><span class="marked"><a name="line187"></a>..187 
</span><span class="marked"><a name="line188"></a>..188 parse_qs_key([], Acc) ->
</span><span class="uncovered"><a name="line189"></a>..189     {qs_revdecode(Acc), ""};
</span><span class="marked"><a name="line190"></a>..190 parse_qs_key([$= | Rest], Acc) ->
</span><span class="covered"><a name="line191"></a>..191     {qs_revdecode(Acc), Rest};
</span><span class="marked"><a name="line192"></a>..192 parse_qs_key(Rest=[$; | _], Acc) ->
</span><span class="uncovered"><a name="line193"></a>..193     {qs_revdecode(Acc), Rest};
</span><span class="marked"><a name="line194"></a>..194 parse_qs_key(Rest=[$& | _], Acc) ->
</span><span class="uncovered"><a name="line195"></a>..195     {qs_revdecode(Acc), Rest};
</span><span class="marked"><a name="line196"></a>..196 parse_qs_key([C | Rest], Acc) ->
</span><span class="covered"><a name="line197"></a>..197     parse_qs_key(Rest, [C | Acc]).
</span><span class="marked"><a name="line198"></a>..198 
</span><span class="marked"><a name="line199"></a>..199 parse_qs_value(String) ->
</span><span class="covered"><a name="line200"></a>..200     parse_qs_value(String, []).
</span><span class="marked"><a name="line201"></a>..201 
</span><span class="marked"><a name="line202"></a>..202 parse_qs_value([], Acc) ->
</span><span class="covered"><a name="line203"></a>..203     {qs_revdecode(Acc), ""};
</span><span class="marked"><a name="line204"></a>..204 parse_qs_value([$; | Rest], Acc) ->
</span><span class="uncovered"><a name="line205"></a>..205     {qs_revdecode(Acc), Rest};
</span><span class="marked"><a name="line206"></a>..206 parse_qs_value([$& | Rest], Acc) ->
</span><span class="covered"><a name="line207"></a>..207     {qs_revdecode(Acc), Rest};
</span><span class="marked"><a name="line208"></a>..208 parse_qs_value([C | Rest], Acc) ->
</span><span class="covered"><a name="line209"></a>..209     parse_qs_value(Rest, [C | Acc]).
</span><span class="marked"><a name="line210"></a>..210 
</span><span class="marked"><a name="line211"></a>..211 %% @spec unquote(string() | binary()) -> string()
</span><span class="marked"><a name="line212"></a>..212 %% @doc Unquote a URL encoded string.
</span><span class="marked"><a name="line213"></a>..213 unquote(Binary) when is_binary(Binary) ->
</span><span class="uncovered"><a name="line214"></a>..214     unquote(binary_to_list(Binary));
</span><span class="marked"><a name="line215"></a>..215 unquote(String) ->
</span><span class="covered"><a name="line216"></a>..216     qs_revdecode(lists:reverse(String)).
</span><span class="marked"><a name="line217"></a>..217 
</span><span class="marked"><a name="line218"></a>..218 qs_revdecode(S) ->
</span><span class="covered"><a name="line219"></a>..219     qs_revdecode(S, []).
</span><span class="marked"><a name="line220"></a>..220 
</span><span class="marked"><a name="line221"></a>..221 qs_revdecode([], Acc) ->
</span><span class="covered"><a name="line222"></a>..222     Acc;
</span><span class="marked"><a name="line223"></a>..223 qs_revdecode([$+ | Rest], Acc) ->
</span><span class="covered"><a name="line224"></a>..224     qs_revdecode(Rest, [$\s | Acc]);
</span><span class="marked"><a name="line225"></a>..225 qs_revdecode([Lo, Hi, ?PERCENT | Rest], Acc) when ?IS_HEX(Lo), ?IS_HEX(Hi) ->
</span><span class="covered"><a name="line226"></a>..226     qs_revdecode(Rest, [(unhexdigit(Lo) bor (unhexdigit(Hi) bsl 4)) | Acc]);
</span><span class="marked"><a name="line227"></a>..227 qs_revdecode([C | Rest], Acc) ->
</span><span class="covered"><a name="line228"></a>..228     qs_revdecode(Rest, [C | Acc]).
</span><span class="marked"><a name="line229"></a>..229 
</span><span class="marked"><a name="line230"></a>..230 %% @spec urlsplit(Url) -> {Scheme, Netloc, Path, Query, Fragment}
</span><span class="marked"><a name="line231"></a>..231 %% @doc Return a 5-tuple, does not expand % escapes. Only supports HTTP style
</span><span class="marked"><a name="line232"></a>..232 %%      URLs.
</span><span class="marked"><a name="line233"></a>..233 urlsplit(Url) ->
</span><span class="covered"><a name="line234"></a>..234     {Scheme, Url1} = urlsplit_scheme(Url),
</span><span class="covered"><a name="line235"></a>..235     {Netloc, Url2} = urlsplit_netloc(Url1),
</span><span class="covered"><a name="line236"></a>..236     {Path, Query, Fragment} = urlsplit_path(Url2),
</span><span class="covered"><a name="line237"></a>..237     {Scheme, Netloc, Path, Query, Fragment}.
</span><span class="marked"><a name="line238"></a>..238 
</span><span class="marked"><a name="line239"></a>..239 urlsplit_scheme(Url) ->
</span><span class="covered"><a name="line240"></a>..240     urlsplit_scheme(Url, []).
</span><span class="marked"><a name="line241"></a>..241 
</span><span class="marked"><a name="line242"></a>..242 urlsplit_scheme([], Acc) ->
</span><span class="covered"><a name="line243"></a>..243     {"", lists:reverse(Acc)};
</span><span class="marked"><a name="line244"></a>..244 urlsplit_scheme(":" ++ Rest, Acc) ->
</span><span class="covered"><a name="line245"></a>..245     {string:to_lower(lists:reverse(Acc)), Rest};
</span><span class="marked"><a name="line246"></a>..246 urlsplit_scheme([C | Rest], Acc) ->
</span><span class="covered"><a name="line247"></a>..247     urlsplit_scheme(Rest, [C | Acc]).
</span><span class="marked"><a name="line248"></a>..248 
</span><span class="marked"><a name="line249"></a>..249 urlsplit_netloc("//" ++ Rest) ->
</span><span class="covered"><a name="line250"></a>..250     urlsplit_netloc(Rest, []);
</span><span class="marked"><a name="line251"></a>..251 urlsplit_netloc(Path) ->
</span><span class="covered"><a name="line252"></a>..252     {"", Path}.
</span><span class="marked"><a name="line253"></a>..253 
</span><span class="marked"><a name="line254"></a>..254 urlsplit_netloc(Rest=[C | _], Acc) when C =:= $/; C =:= $?; C =:= $# ->
</span><span class="covered"><a name="line255"></a>..255     {lists:reverse(Acc), Rest};
</span><span class="marked"><a name="line256"></a>..256 urlsplit_netloc([C | Rest], Acc) ->
</span><span class="covered"><a name="line257"></a>..257     urlsplit_netloc(Rest, [C | Acc]).
</span><span class="marked"><a name="line258"></a>..258 
</span><span class="marked"><a name="line259"></a>..259 
</span><span class="marked"><a name="line260"></a>..260 %% @spec path_split(string()) -> {Part, Rest}
</span><span class="marked"><a name="line261"></a>..261 %% @doc Split a path starting from the left, as in URL traversal.
</span><span class="marked"><a name="line262"></a>..262 %%      path_split("foo/bar") = {"foo", "bar"},
</span><span class="marked"><a name="line263"></a>..263 %%      path_split("/foo/bar") = {"", "foo/bar"}.
</span><span class="marked"><a name="line264"></a>..264 path_split(S) ->
</span><span class="covered"><a name="line265"></a>..265     path_split(S, []).
</span><span class="marked"><a name="line266"></a>..266 
</span><span class="marked"><a name="line267"></a>..267 path_split("", Acc) ->
</span><span class="covered"><a name="line268"></a>..268     {lists:reverse(Acc), ""};
</span><span class="marked"><a name="line269"></a>..269 path_split("/" ++ Rest, Acc) ->
</span><span class="covered"><a name="line270"></a>..270     {lists:reverse(Acc), Rest};
</span><span class="marked"><a name="line271"></a>..271 path_split([C | Rest], Acc) ->
</span><span class="covered"><a name="line272"></a>..272     path_split(Rest, [C | Acc]).
</span><span class="marked"><a name="line273"></a>..273 
</span><span class="marked"><a name="line274"></a>..274 
</span><span class="marked"><a name="line275"></a>..275 %% @spec urlunsplit({Scheme, Netloc, Path, Query, Fragment}) -> string()
</span><span class="marked"><a name="line276"></a>..276 %% @doc Assemble a URL from the 5-tuple. Path must be absolute.
</span><span class="marked"><a name="line277"></a>..277 urlunsplit({Scheme, Netloc, Path, Query, Fragment}) ->
</span><span class="covered"><a name="line278"></a>..278     lists:flatten([case Scheme of "" -> "";  _ -> [Scheme, "://"] end,
</span><span class="marked"><a name="line279"></a>..279                    Netloc,
</span><span class="marked"><a name="line280"></a>..280                    urlunsplit_path({Path, Query, Fragment})]).
</span><span class="marked"><a name="line281"></a>..281 
</span><span class="marked"><a name="line282"></a>..282 %% @spec urlunsplit_path({Path, Query, Fragment}) -> string()
</span><span class="marked"><a name="line283"></a>..283 %% @doc Assemble a URL path from the 3-tuple.
</span><span class="marked"><a name="line284"></a>..284 urlunsplit_path({Path, Query, Fragment}) ->
</span><span class="covered"><a name="line285"></a>..285     lists:flatten([Path,
</span><span class="covered"><a name="line286"></a>..286                    case Query of "" -> ""; _ -> [$? | Query] end,
</span><span class="covered"><a name="line287"></a>..287                    case Fragment of "" -> ""; _ -> [$# | Fragment] end]).
</span><span class="marked"><a name="line288"></a>..288 
</span><span class="marked"><a name="line289"></a>..289 %% @spec urlsplit_path(Url) -> {Path, Query, Fragment}
</span><span class="marked"><a name="line290"></a>..290 %% @doc Return a 3-tuple, does not expand % escapes. Only supports HTTP style
</span><span class="marked"><a name="line291"></a>..291 %%      paths.
</span><span class="marked"><a name="line292"></a>..292 urlsplit_path(Path) ->
</span><span class="covered"><a name="line293"></a>..293     urlsplit_path(Path, []).
</span><span class="marked"><a name="line294"></a>..294 
</span><span class="marked"><a name="line295"></a>..295 urlsplit_path("", Acc) ->
</span><span class="covered"><a name="line296"></a>..296     {lists:reverse(Acc), "", ""};
</span><span class="marked"><a name="line297"></a>..297 urlsplit_path("?" ++ Rest, Acc) ->
</span><span class="covered"><a name="line298"></a>..298     {Query, Fragment} = urlsplit_query(Rest),
</span><span class="covered"><a name="line299"></a>..299     {lists:reverse(Acc), Query, Fragment};
</span><span class="marked"><a name="line300"></a>..300 urlsplit_path("#" ++ Rest, Acc) ->
</span><span class="covered"><a name="line301"></a>..301     {lists:reverse(Acc), "", Rest};
</span><span class="marked"><a name="line302"></a>..302 urlsplit_path([C | Rest], Acc) ->
</span><span class="covered"><a name="line303"></a>..303     urlsplit_path(Rest, [C | Acc]).
</span><span class="marked"><a name="line304"></a>..304 
</span><span class="marked"><a name="line305"></a>..305 urlsplit_query(Query) ->
</span><span class="covered"><a name="line306"></a>..306     urlsplit_query(Query, []).
</span><span class="marked"><a name="line307"></a>..307 
</span><span class="marked"><a name="line308"></a>..308 urlsplit_query("", Acc) ->
</span><span class="covered"><a name="line309"></a>..309     {lists:reverse(Acc), ""};
</span><span class="marked"><a name="line310"></a>..310 urlsplit_query("#" ++ Rest, Acc) ->
</span><span class="covered"><a name="line311"></a>..311     {lists:reverse(Acc), Rest};
</span><span class="marked"><a name="line312"></a>..312 urlsplit_query([C | Rest], Acc) ->
</span><span class="covered"><a name="line313"></a>..313     urlsplit_query(Rest, [C | Acc]).
</span><span class="marked"><a name="line314"></a>..314 
</span><span class="marked"><a name="line315"></a>..315 %% @spec guess_mime(string()) -> string()
</span><span class="marked"><a name="line316"></a>..316 %% @doc  Guess the mime type of a file by the extension of its filename.
</span><span class="marked"><a name="line317"></a>..317 guess_mime(File) ->
</span><span class="covered"><a name="line318"></a>..318     case filename:extension(File) of
</span><span class="marked"><a name="line319"></a>..319         ".html" ->
</span><span class="covered"><a name="line320"></a>..320             "text/html";
</span><span class="marked"><a name="line321"></a>..321         ".xhtml" ->
</span><span class="covered"><a name="line322"></a>..322             "application/xhtml+xml";
</span><span class="marked"><a name="line323"></a>..323         ".xml" ->
</span><span class="uncovered"><a name="line324"></a>..324             "application/xml";
</span><span class="marked"><a name="line325"></a>..325         ".css" ->
</span><span class="uncovered"><a name="line326"></a>..326             "text/css";
</span><span class="marked"><a name="line327"></a>..327         ".js" ->
</span><span class="uncovered"><a name="line328"></a>..328             "application/x-javascript";
</span><span class="marked"><a name="line329"></a>..329         ".jpg" ->
</span><span class="uncovered"><a name="line330"></a>..330             "image/jpeg";
</span><span class="marked"><a name="line331"></a>..331         ".gif" ->
</span><span class="uncovered"><a name="line332"></a>..332             "image/gif";
</span><span class="marked"><a name="line333"></a>..333         ".png" ->
</span><span class="uncovered"><a name="line334"></a>..334             "image/png";
</span><span class="marked"><a name="line335"></a>..335         ".swf" ->
</span><span class="uncovered"><a name="line336"></a>..336             "application/x-shockwave-flash";
</span><span class="marked"><a name="line337"></a>..337         ".zip" ->
</span><span class="covered"><a name="line338"></a>..338             "application/zip";
</span><span class="marked"><a name="line339"></a>..339         ".bz2" ->
</span><span class="uncovered"><a name="line340"></a>..340             "application/x-bzip2";
</span><span class="marked"><a name="line341"></a>..341         ".gz" ->
</span><span class="uncovered"><a name="line342"></a>..342             "application/x-gzip";
</span><span class="marked"><a name="line343"></a>..343         ".tar" ->
</span><span class="uncovered"><a name="line344"></a>..344             "application/x-tar";
</span><span class="marked"><a name="line345"></a>..345         ".tgz" ->
</span><span class="uncovered"><a name="line346"></a>..346             "application/x-gzip";
</span><span class="marked"><a name="line347"></a>..347         ".txt" ->
</span><span class="uncovered"><a name="line348"></a>..348             "text/plain";
</span><span class="marked"><a name="line349"></a>..349         ".doc" ->
</span><span class="uncovered"><a name="line350"></a>..350             "application/msword";
</span><span class="marked"><a name="line351"></a>..351         ".pdf" ->
</span><span class="uncovered"><a name="line352"></a>..352             "application/pdf";
</span><span class="marked"><a name="line353"></a>..353         ".xls" ->
</span><span class="uncovered"><a name="line354"></a>..354             "application/vnd.ms-excel";
</span><span class="marked"><a name="line355"></a>..355         ".rtf" ->
</span><span class="uncovered"><a name="line356"></a>..356             "application/rtf";
</span><span class="marked"><a name="line357"></a>..357         ".mov" ->
</span><span class="uncovered"><a name="line358"></a>..358             "video/quicktime";
</span><span class="marked"><a name="line359"></a>..359         ".mp3" ->
</span><span class="uncovered"><a name="line360"></a>..360             "audio/mpeg";
</span><span class="marked"><a name="line361"></a>..361         ".z" ->
</span><span class="uncovered"><a name="line362"></a>..362             "application/x-compress";
</span><span class="marked"><a name="line363"></a>..363         ".wav" ->
</span><span class="uncovered"><a name="line364"></a>..364             "audio/x-wav";
</span><span class="marked"><a name="line365"></a>..365         ".ico" ->
</span><span class="uncovered"><a name="line366"></a>..366             "image/x-icon";
</span><span class="marked"><a name="line367"></a>..367         ".bmp" ->
</span><span class="uncovered"><a name="line368"></a>..368             "image/bmp";
</span><span class="marked"><a name="line369"></a>..369         ".m4a" ->
</span><span class="uncovered"><a name="line370"></a>..370             "audio/mpeg";
</span><span class="marked"><a name="line371"></a>..371         ".m3u" ->
</span><span class="uncovered"><a name="line372"></a>..372             "audio/x-mpegurl";
</span><span class="marked"><a name="line373"></a>..373         ".exe" ->
</span><span class="uncovered"><a name="line374"></a>..374             "application/octet-stream";
</span><span class="marked"><a name="line375"></a>..375         ".csv" ->
</span><span class="uncovered"><a name="line376"></a>..376             "text/csv";
</span><span class="marked"><a name="line377"></a>..377         _ ->
</span><span class="covered"><a name="line378"></a>..378             "text/plain"
</span><span class="marked"><a name="line379"></a>..379     end.
</span><span class="marked"><a name="line380"></a>..380 
</span><span class="marked"><a name="line381"></a>..381 %% @spec parse_header(string()) -> {Type, [{K, V}]}
</span><span class="marked"><a name="line382"></a>..382 %% @doc  Parse a Content-Type like header, return the main Content-Type
</span><span class="marked"><a name="line383"></a>..383 %%       and a property list of options.
</span><span class="marked"><a name="line384"></a>..384 parse_header(String) ->
</span><span class="marked"><a name="line385"></a>..385     %% TODO: This is exactly as broken as Python's cgi module.
</span><span class="marked"><a name="line386"></a>..386     %%       Should parse properly like mochiweb_cookies.
</span><span class="covered"><a name="line387"></a>..387     [Type | Parts] = [string:strip(S) || S <- string:tokens(String, ";")],
</span><span class="covered"><a name="line388"></a>..388     F = fun (S, Acc) ->
</span><span class="covered"><a name="line389"></a>..389                 case lists:splitwith(fun (C) -> C =/= $= end, S) of
</span><span class="marked"><a name="line390"></a>..390                     {"", _} ->
</span><span class="marked"><a name="line391"></a>..391                         %% Skip anything with no name
</span><span class="uncovered"><a name="line392"></a>..392                         Acc;
</span><span class="marked"><a name="line393"></a>..393                     {_, ""} ->
</span><span class="marked"><a name="line394"></a>..394                         %% Skip anything with no value
</span><span class="uncovered"><a name="line395"></a>..395                         Acc;
</span><span class="marked"><a name="line396"></a>..396                     {Name, [$\= | Value]} ->
</span><span class="covered"><a name="line397"></a>..397                         [{string:to_lower(string:strip(Name)),
</span><span class="marked"><a name="line398"></a>..398                           unquote_header(string:strip(Value))} | Acc]
</span><span class="marked"><a name="line399"></a>..399                 end
</span><span class="marked"><a name="line400"></a>..400         end,
</span><span class="covered"><a name="line401"></a>..401     {string:to_lower(Type),
</span><span class="marked"><a name="line402"></a>..402      lists:foldr(F, [], Parts)}.
</span><span class="marked"><a name="line403"></a>..403 
</span><span class="marked"><a name="line404"></a>..404 unquote_header("\"" ++ Rest) ->
</span><span class="covered"><a name="line405"></a>..405     unquote_header(Rest, []);
</span><span class="marked"><a name="line406"></a>..406 unquote_header(S) ->
</span><span class="covered"><a name="line407"></a>..407     S.
</span><span class="marked"><a name="line408"></a>..408 
</span><span class="marked"><a name="line409"></a>..409 unquote_header("", Acc) ->
</span><span class="uncovered"><a name="line410"></a>..410     lists:reverse(Acc);
</span><span class="marked"><a name="line411"></a>..411 unquote_header("\"", Acc) ->
</span><span class="covered"><a name="line412"></a>..412     lists:reverse(Acc);
</span><span class="marked"><a name="line413"></a>..413 unquote_header([$\\, C | Rest], Acc) ->
</span><span class="uncovered"><a name="line414"></a>..414     unquote_header(Rest, [C | Acc]);
</span><span class="marked"><a name="line415"></a>..415 unquote_header([C | Rest], Acc) ->
</span><span class="covered"><a name="line416"></a>..416     unquote_header(Rest, [C | Acc]).
</span><span class="marked"><a name="line417"></a>..417 
</span><span class="marked"><a name="line418"></a>..418 %% @spec record_to_proplist(Record, Fields) -> proplist()
</span><span class="marked"><a name="line419"></a>..419 %% @doc calls record_to_proplist/3 with a default TypeKey of '__record'
</span><span class="marked"><a name="line420"></a>..420 record_to_proplist(Record, Fields) ->
</span><span class="uncovered"><a name="line421"></a>..421     record_to_proplist(Record, Fields, '__record').
</span><span class="marked"><a name="line422"></a>..422 
</span><span class="marked"><a name="line423"></a>..423 %% @spec record_to_proplist(Record, Fields, TypeKey) -> proplist()
</span><span class="marked"><a name="line424"></a>..424 %% @doc Return a proplist of the given Record with each field in the 
</span><span class="marked"><a name="line425"></a>..425 %%      Fields list set as a key with the corresponding value in the Record.
</span><span class="marked"><a name="line426"></a>..426 %%      TypeKey is the key that is used to store the record type
</span><span class="marked"><a name="line427"></a>..427 %%      Fields should be obtained by calling record_info(fields, record_type)
</span><span class="marked"><a name="line428"></a>..428 %%      where record_type is the record type of Record
</span><span class="marked"><a name="line429"></a>..429 record_to_proplist(Record, Fields, TypeKey)
</span><span class="marked"><a name="line430"></a>..430   when is_tuple(Record),
</span><span class="marked"><a name="line431"></a>..431        is_list(Fields),
</span><span class="marked"><a name="line432"></a>..432        size(Record) - 1 =:= length(Fields) ->
</span><span class="uncovered"><a name="line433"></a>..433     lists:zip([TypeKey | Fields], tuple_to_list(Record)).
</span><span class="marked"><a name="line434"></a>..434 
</span><span class="marked"><a name="line435"></a>..435 
</span><span class="marked"><a name="line436"></a>..436 shell_quote([], Acc) ->
</span><span class="covered"><a name="line437"></a>..437     lists:reverse([$\" | Acc]);
</span><span class="marked"><a name="line438"></a>..438 shell_quote([C | Rest], Acc) when C =:= $\" orelse C =:= $\` orelse
</span><span class="marked"><a name="line439"></a>..439                                   C =:= $\\ orelse C =:= $\$ ->
</span><span class="covered"><a name="line440"></a>..440     shell_quote(Rest, [C, $\\ | Acc]);
</span><span class="marked"><a name="line441"></a>..441 shell_quote([C | Rest], Acc) ->
</span><span class="covered"><a name="line442"></a>..442     shell_quote(Rest, [C | Acc]).
</span><span class="marked"><a name="line443"></a>..443 
</span><span class="uncovered"><a name="line444"></a>..444 is_atleast_version(Major1) when is_integer(Major1) -> is_atleast_version({Major1, 0, 0});
</span><span class="covered"><a name="line445"></a>..445 is_atleast_version({Major1, Minor1}) -> is_atleast_version({Major1, Minor1, 0});
</span><span class="marked"><a name="line446"></a>..446 is_atleast_version({Major1, Minor1, Tiny1}) ->
</span><span class="covered"><a name="line447"></a>..447   try
</span><span class="marked"><a name="line448"></a>..448     case regexp:split(erlang:system_info(version), "\\.") of
</span><span class="marked"><a name="line449"></a>..449       {ok, List} when length(List) =:= 3 ->
</span><span class="covered"><a name="line450"></a>..450         [Major2, Minor2, Tiny2] = [list_to_integer(X) || X <- List],
</span><span class="marked"><a name="line451"></a>..451         
</span><span class="covered"><a name="line452"></a>..452         if
</span><span class="uncovered"><a name="line453"></a>..453           Major2 > Major1 -> true;
</span><span class="marked"><a name="line454"></a>..454           Major2 =:= Major1 ->
</span><span class="covered"><a name="line455"></a>..455             if
</span><span class="uncovered"><a name="line456"></a>..456               Minor2 > Minor1 -> true;
</span><span class="marked"><a name="line457"></a>..457               Minor2 =:= Minor1 ->
</span><span class="covered"><a name="line458"></a>..458                 if
</span><span class="covered"><a name="line459"></a>..459                   Tiny2 >= Tiny1 -> true;
</span><span class="uncovered"><a name="line460"></a>..460                   true -> false
</span><span class="marked"><a name="line461"></a>..461                 end;
</span><span class="uncovered"><a name="line462"></a>..462               true -> false
</span><span class="marked"><a name="line463"></a>..463             end;
</span><span class="uncovered"><a name="line464"></a>..464           true -> false
</span><span class="marked"><a name="line465"></a>..465         end;
</span><span class="uncovered"><a name="line466"></a>..466       _ -> false
</span><span class="marked"><a name="line467"></a>..467     end
</span><span class="marked"><a name="line468"></a>..468   catch
</span><span class="uncovered"><a name="line469"></a>..469     _:_ -> false
</span><span class="marked"><a name="line470"></a>..470   end.
</span></pre><hr /><p>Generated using <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.</p>
          </body>
        </html>
    