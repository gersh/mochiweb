<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
          <head>
            <title>json - C0 code coverage information</title>
            <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
            <style type='text/css'>span.marked0 {
     background-color: rgb(185, 210, 200);
     display: block;
    }
    span.marked { display: block; background-color: #ffffff; }
    span.highlight { display: block; background-color: #fff9d7; }
    span.covered { display: block; background-color: #f7f7f7 ; }
    span.uncovered { display: block; background-color: #ffebe8 ; }
    span.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    div.overview {
     border-bottom: 1px solid #E2E6EF; 
    }
    body {
     font-family: verdana, arial, helvetica;
    }
    div.footer {
     font-size: 68%;
     margin-top: 1.5em;
    }
    h1, h2, h3, h4, h5, h6 {
     margin-bottom: 0.5em;
    }
    h5 {
     margin-top: 0.5em;
    }
    .hidden {
     display: none;
    }
    div.separator {
     height: 10px;
    }
    table.percent_graph {
     height: 12px;
     border: 1px solid #E2E6EF; 
     empty-cells: show;
    }
    table.percent_graph td.covered {
     height: 10px;
     background: #00f000;
    }
    table.percent_graph td.uncovered {
     height: 10px;
     background: #e00000;
    }
    table.percent_graph td.NA {
     height: 10px;
     background: #eaeaea;
    }
    table.report {
     border-collapse: collapse;
     width: 100%;
    }
    table.report td.heading {
     background: #dcecff;
     border: 1px solid #E2E6EF; 
     font-weight: bold;
     text-align: center;
    }
    table.report td.heading:hover {
     background: #c0ffc0;
    }
    table.report td.text {
     border: 1px solid #E2E6EF; 
    }
    table.report td.value {
     text-align: right;
     border: 1px solid #E2E6EF; 
    }
    table.report tr.light {
     background-color: rgb(240, 240, 245);
    }
    table.report tr.dark {
     background-color: rgb(230, 230, 235);
    }
    </style>
          </head>
          <body>
            <h3>C0 code coverage information</h3>
            <p>Generated on 2009-02-25 00:22:45 with <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.
            </p>            
        <table class='report'>
          <thead>
            <tr>
              <td class='heading'>Name</td>
              <td class='heading'>Total lines</td>
              <td class='heading'>Lines of code</td>
              <td class='heading'>Total coverage</td>
              <td class='heading'>Code coverage</td>
            </tr>
          </thead>
          <tbody>
            <tr class='light'>

              <td>
                <a href='json_report.html'>json</a>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td class='value'>
                <tt>??</tt>
              </td>
              <td>
                <table cellspacing='0' cellpadding='0' align='right'>
                  <tr>
                    <td><tt>0%</tt>&nbsp;</td><td>
                      <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                      <tr><td class='covered' width='0' /><td class='uncovered' width='100' /></tr>
                      </table>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </tbody>
        </table><pre><span class="marked"><a name="line1"></a>....1 %(%% Copyright (c) 2005-2006, A2Z Development USA, Inc.  All Rights Reserved.
</span><span class="marked"><a name="line2"></a>....2 %%%
</span><span class="marked"><a name="line3"></a>....3 %%% The contents of this file are subject to the Erlang Public License,
</span><span class="marked"><a name="line4"></a>....4 %%% Version 1.1, (the "License"); you may not use this file except in
</span><span class="marked"><a name="line5"></a>....5 %%% compliance with the License. You should have received a copy of the
</span><span class="marked"><a name="line6"></a>....6 %%% Erlang Public License along with this software. If not, it can be
</span><span class="marked"><a name="line7"></a>....7 %%% retrieved via the world wide web at http://www.erlang.org/.
</span><span class="marked"><a name="line8"></a>....8 %%% 
</span><span class="marked"><a name="line9"></a>....9 %%% Software distributed under the License is distributed on an "AS IS"
</span><span class="marked"><a name="line10"></a>...10 %%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
</span><span class="marked"><a name="line11"></a>...11 %%% the License for the specific language governing rights and limitations
</span><span class="marked"><a name="line12"></a>...12 %%% under the License.
</span><span class="marked"><a name="line13"></a>...13 %%% 
</span><span class="marked"><a name="line14"></a>...14 %%% The Initial Developer of the Original Code is A2Z Development USA, Inc.
</span><span class="marked"><a name="line15"></a>...15 %%% All Rights Reserved.
</span><span class="marked"><a name="line16"></a>...16 
</span><span class="marked"><a name="line17"></a>...17 -module(json).
</span><span class="marked"><a name="line18"></a>...18 -export([encode/1, decode_string/1, decode/2]).
</span><span class="marked"><a name="line19"></a>...19 -export([is_obj/1, obj_new/0, obj_fetch/2, obj_find/2, obj_is_key/2]).
</span><span class="marked"><a name="line20"></a>...20 -export([obj_store/3, obj_from_list/1, obj_fold/3]).
</span><span class="marked"><a name="line21"></a>...21 -export([test/0]).
</span><span class="marked"><a name="line22"></a>...22 -author("Jim Larson <jalarson@amazon.com>, Robert Wai-Chi Chu <robchu@amazon.com>").
</span><span class="marked"><a name="line23"></a>...23 -author("Gaspar Chilingarov <nm@web.am>, Gurgen Tumanyan <barbarian@armkb.com>").
</span><span class="marked"><a name="line24"></a>...24 -vsn("2").
</span><span class="marked"><a name="line25"></a>...25 
</span><span class="marked"><a name="line26"></a>...26 %%% JavaScript Object Notation ("JSON", http://www.json.org) is a simple
</span><span class="marked"><a name="line27"></a>...27 %%% data syntax meant as a lightweight alternative to other representations,
</span><span class="marked"><a name="line28"></a>...28 %%% such as XML.  JSON is natively supported by JavaScript, but many
</span><span class="marked"><a name="line29"></a>...29 %%% other languages have conversion libraries available.
</span><span class="marked"><a name="line30"></a>...30 %%%
</span><span class="marked"><a name="line31"></a>...31 %%% This module translates JSON types into the following Erlang types:
</span><span class="marked"><a name="line32"></a>...32 %%%
</span><span class="marked"><a name="line33"></a>...33 %%%	JSON			Erlang
</span><span class="marked"><a name="line34"></a>...34 %%%	----			------
</span><span class="marked"><a name="line35"></a>...35 %%%	number			number
</span><span class="marked"><a name="line36"></a>...36 %%%	string			string
</span><span class="marked"><a name="line37"></a>...37 %%%	array			{array, ElementList}
</span><span class="marked"><a name="line38"></a>...38 %%%	object			tagged proplist with string (or atom) keys (i.e. {struct, PropList} )
</span><span class="marked"><a name="line39"></a>...39 %%%	true, false, null	atoms 'true', 'false', and 'null'
</span><span class="marked"><a name="line40"></a>...40 %%%
</span><span class="marked"><a name="line41"></a>...41 %%% Character Sets: the external representation, and the internal
</span><span class="marked"><a name="line42"></a>...42 %%% representation of strings, are lists of UTF-16 code units.
</span><span class="marked"><a name="line43"></a>...43 %%% The encoding of supplementary characters, as well as
</span><span class="marked"><a name="line44"></a>...44 %%% transcoding to other schemes, such as UTF-8, can be provided
</span><span class="marked"><a name="line45"></a>...45 %%% by other modules.  (See discussion at
</span><span class="marked"><a name="line46"></a>...46 %%% http://groups.yahoo.com/group/json/message/52)
</span><span class="marked"><a name="line47"></a>...47 %%%
</span><span class="marked"><a name="line48"></a>...48 %%%###################################################################### 
</span><span class="marked"><a name="line49"></a>...49 %%% UPD by Gaspar: for this moment utf-8 encoding inplemented by default
</span><span class="marked"><a name="line50"></a>...50 %%%                if incoming character list have symbols with codes
</span><span class="marked"><a name="line51"></a>...51 %%%                > 255
</span><span class="marked"><a name="line52"></a>...52 %%%###################################################################### 
</span><span class="marked"><a name="line53"></a>...53 %%%
</span><span class="marked"><a name="line54"></a>...54 %%% Numbers: Thanks to Erlang's bignums, JSON-encoded integers of any
</span><span class="marked"><a name="line55"></a>...55 %%% size can be parsed.  Conversely, extremely large integers may
</span><span class="marked"><a name="line56"></a>...56 %%% be JSON-encoded.  This may cause problems for interoperability
</span><span class="marked"><a name="line57"></a>...57 %%% with JSON parsers which can't handle arbitrary-sized integers.
</span><span class="marked"><a name="line58"></a>...58 %%% Erlang's floats are of fixed precision and limited range, so
</span><span class="marked"><a name="line59"></a>...59 %%% syntactically valid JSON floating-point numbers could silently
</span><span class="marked"><a name="line60"></a>...60 %%% lose precision or noisily cause an overflow.  However, most
</span><span class="marked"><a name="line61"></a>...61 %%% other JSON libraries are likely to behave in the same way.
</span><span class="marked"><a name="line62"></a>...62 %%% The encoding precision defaults to 6 digits.
</span><span class="marked"><a name="line63"></a>...63 %%%
</span><span class="marked"><a name="line64"></a>...64 %%% Strings: If we represented JSON string data as Erlang binaries,
</span><span class="marked"><a name="line65"></a>...65 %%% we would have to choose a particular unicode format.  Instead,
</span><span class="marked"><a name="line66"></a>...66 %%% we use lists of UTF-16 code units, which applications may then
</span><span class="marked"><a name="line67"></a>...67 %%% change to binaries in their application-preferred manner.
</span><span class="marked"><a name="line68"></a>...68 %%%
</span><span class="marked"><a name="line69"></a>...69 %%% Arrays: Because of the string decision above, and Erlang's
</span><span class="marked"><a name="line70"></a>...70 %%% lack of a distinguished string datatype, JSON arrays map
</span><span class="marked"><a name="line71"></a>...71 %%% to Erlang tuples.  Consider utilities like tuple_fold/3
</span><span class="marked"><a name="line72"></a>...72 %%% to deal with tuples in their native form.
</span><span class="marked"><a name="line73"></a>...73 %%%###################################################################### 
</span><span class="marked"><a name="line74"></a>...74 %%% UPD by Gaspar: array changed to {array, ArrayElementList}
</span><span class="marked"><a name="line75"></a>...75 %%%                ArrayElementList -> list
</span><span class="marked"><a name="line76"></a>...76 %%%                to provide compatibility to xmlrpc module
</span><span class="marked"><a name="line77"></a>...77 %%%###################################################################### 
</span><span class="marked"><a name="line78"></a>...78 %%%
</span><span class="marked"><a name="line79"></a>...79 %%% Objects: Though not explicitly stated in the JSON "spec",
</span><span class="marked"><a name="line80"></a>...80 %%% JSON's JavaScript heritage mandates that member names must
</span><span class="marked"><a name="line81"></a>...81 %%% be unique within an object.  The object/tuple ambiguity is
</span><span class="marked"><a name="line82"></a>...82 %%% not a problem, since the atom 'struct' is not an
</span><span class="marked"><a name="line83"></a>...83 %%% allowable value.  Object keys may be atoms or strings on
</span><span class="marked"><a name="line84"></a>...84 %%% encoding but are always decoded as strings.
</span><span class="marked"><a name="line85"></a>...85 %%%
</span><span class="marked"><a name="line86"></a>...86 %%%###################################################################### 
</span><span class="marked"><a name="line87"></a>...87 %%% UPD by Gaspar: struct changed to {array, PropList}
</span><span class="marked"><a name="line88"></a>...88 %%%                object keys always decoded to atoms to 
</span><span class="marked"><a name="line89"></a>...89 %%%                provide full compatility with xmlrpc module
</span><span class="marked"><a name="line90"></a>...90 %%%###################################################################### 
</span><span class="marked"><a name="line91"></a>...91 %%%
</span><span class="marked"><a name="line92"></a>...92 
</span><span class="marked"><a name="line93"></a>...93 %%% ENCODING
</span><span class="marked"><a name="line94"></a>...94 
</span><span class="marked"><a name="line95"></a>...95 %% Encode an erlang number, string, tuple, or object to JSON syntax, as a
</span><span class="marked"><a name="line96"></a>...96 %% possibly deep list of UTF-16 code units, throwing a runtime error in the
</span><span class="marked"><a name="line97"></a>...97 %% case of un-convertible input.
</span><span class="marked"><a name="line98"></a>...98 %% Note: object keys may be either strings or atoms.
</span><span class="marked"><a name="line99"></a>...99 
</span><span class="uncovered"><a name="line100"></a>..100 encode(true) -> "true";
</span><span class="uncovered"><a name="line101"></a>..101 encode(false) -> "false";
</span><span class="uncovered"><a name="line102"></a>..102 encode(null) -> "null";
</span><span class="uncovered"><a name="line103"></a>..103 encode(undefined) -> "null";
</span><span class="uncovered"><a name="line104"></a>..104 encode(I) when is_integer(I) -> integer_to_list(I);
</span><span class="uncovered"><a name="line105"></a>..105 encode(B) when is_binary(B) -> encode(binary_to_list(B));
</span><span class="uncovered"><a name="line106"></a>..106 encode(F) when is_float(F) -> io_lib:format("~g", [F]);
</span><span class="marked"><a name="line107"></a>..107 encode(L) when is_list(L) ->
</span><span class="uncovered"><a name="line108"></a>..108     case is_string(L) of
</span><span class="uncovered"><a name="line109"></a>..109 	yes -> encode_string(L);
</span><span class="uncovered"><a name="line110"></a>..110 	unicode -> encode_string(xmerl_ucs:to_utf8(L));
</span><span class="uncovered"><a name="line111"></a>..111 	no -> exit({json_encode, {not_string, L}})
</span><span class="marked"><a name="line112"></a>..112     end;
</span><span class="uncovered"><a name="line113"></a>..113 encode({array, Props}) when is_list(Props) -> encode_array(Props);
</span><span class="uncovered"><a name="line114"></a>..114 encode({struct, Props} = T) when is_list(Props) -> encode_object(T);
</span><span class="uncovered"><a name="line115"></a>..115 encode({raw, Bin}) when is_binary(Bin) -> binary_to_list(Bin);
</span><span class="uncovered"><a name="line116"></a>..116 encode({raw, List}) when is_list(List) -> List;
</span><span class="uncovered"><a name="line117"></a>..117 encode(Bad) -> exit({json_encode, {bad_term, Bad}}).
</span><span class="marked"><a name="line118"></a>..118 
</span><span class="marked"><a name="line119"></a>..119 %% Encode an Erlang string to JSON.
</span><span class="marked"><a name="line120"></a>..120 %% Accumulate strings in reverse.
</span><span class="marked"><a name="line121"></a>..121 
</span><span class="uncovered"><a name="line122"></a>..122 encode_string(S) -> encode_string(S, [$"]).			 % " fix highlight for vim :)
</span><span class="marked"><a name="line123"></a>..123 
</span><span class="uncovered"><a name="line124"></a>..124 encode_string([], Acc) -> lists:reverse([$" | Acc]); % " fix highlight for vim :)
</span><span class="marked"><a name="line125"></a>..125 encode_string([C | Cs], Acc) ->
</span><span class="uncovered"><a name="line126"></a>..126     case C of
</span><span class="uncovered"><a name="line127"></a>..127 	$" -> encode_string(Cs, [$", $\\ | Acc]);
</span><span class="marked"><a name="line128"></a>..128 	% (don't escape solidus on encode)
</span><span class="uncovered"><a name="line129"></a>..129 	$\\ -> encode_string(Cs, [$\\, $\\ | Acc]);
</span><span class="uncovered"><a name="line130"></a>..130 	$\b -> encode_string(Cs, [$b, $\\ | Acc]);	% note missing \
</span><span class="uncovered"><a name="line131"></a>..131 	$\f -> encode_string(Cs, [$f, $\\ | Acc]);
</span><span class="uncovered"><a name="line132"></a>..132 	$\n -> encode_string(Cs, [$n, $\\ | Acc]);
</span><span class="uncovered"><a name="line133"></a>..133 	$\r -> encode_string(Cs, [$r, $\\ | Acc]);
</span><span class="uncovered"><a name="line134"></a>..134 	$\t -> encode_string(Cs, [$t, $\\ | Acc]);
</span><span class="marked"><a name="line135"></a>..135         C when C >= 0, C < $\s ->
</span><span class="marked"><a name="line136"></a>..136             % Control characters must be unicode-encoded.
</span><span class="uncovered"><a name="line137"></a>..137             Hex = lists:flatten(io_lib:format("~4.16.0b", [C])),
</span><span class="uncovered"><a name="line138"></a>..138             encode_string(Cs, lists:reverse(Hex) ++ "u\\" ++ Acc); 		% "
</span><span class="uncovered"><a name="line139"></a>..139         C when C =< 16#FFFF -> encode_string(Cs, [C | Acc]);
</span><span class="uncovered"><a name="line140"></a>..140         _ -> exit({json_encode, {bad_char, C}})
</span><span class="marked"><a name="line141"></a>..141     end.
</span><span class="marked"><a name="line142"></a>..142 
</span><span class="marked"><a name="line143"></a>..143 %% Encode an Erlang object as a JSON object, allowing string or atom keys.
</span><span class="marked"><a name="line144"></a>..144 %% Note that order is irrelevant in both internal and external object
</span><span class="marked"><a name="line145"></a>..145 %% representations.  Nevertheless, the output will respect the order
</span><span class="marked"><a name="line146"></a>..146 %% of the input.
</span><span class="marked"><a name="line147"></a>..147 
</span><span class="marked"><a name="line148"></a>..148 encode_object({struct, _Props} = Obj) ->
</span><span class="uncovered"><a name="line149"></a>..149     M = obj_fold(fun({Key, Value}, Acc) ->
</span><span class="uncovered"><a name="line150"></a>..150 	S = case Key of
</span><span class="uncovered"><a name="line151"></a>..151 	    L when is_list(L) -> encode_string(L);
</span><span class="uncovered"><a name="line152"></a>..152 	    A when is_atom(A) -> encode_string(atom_to_list(A));
</span><span class="uncovered"><a name="line153"></a>..153             _ -> exit({json_encode, {bad_key, Key}})
</span><span class="marked"><a name="line154"></a>..154 	end,
</span><span class="uncovered"><a name="line155"></a>..155 	V = encode(Value),
</span><span class="uncovered"><a name="line156"></a>..156 	case Acc of
</span><span class="uncovered"><a name="line157"></a>..157 	    [] -> [S, $:, V];
</span><span class="uncovered"><a name="line158"></a>..158 	    _ -> [Acc, $,, S, $:, V]
</span><span class="marked"><a name="line159"></a>..159 	end
</span><span class="marked"><a name="line160"></a>..160     end, [], Obj),
</span><span class="uncovered"><a name="line161"></a>..161     [${, M, $}].
</span><span class="marked"><a name="line162"></a>..162 
</span><span class="marked"><a name="line163"></a>..163 %% Encode an Erlang tuple as a JSON array.
</span><span class="marked"><a name="line164"></a>..164 %% Order *is* significant in a JSON array!
</span><span class="marked"><a name="line165"></a>..165 
</span><span class="marked"><a name="line166"></a>..166 encode_array(T) ->
</span><span class="uncovered"><a name="line167"></a>..167     M = lists:foldl(fun(E, Acc) ->
</span><span class="uncovered"><a name="line168"></a>..168 	V = encode(E),
</span><span class="uncovered"><a name="line169"></a>..169 	case Acc of
</span><span class="uncovered"><a name="line170"></a>..170 	    [] -> V;
</span><span class="uncovered"><a name="line171"></a>..171 	    _ -> [Acc, $,, V]
</span><span class="marked"><a name="line172"></a>..172 	end
</span><span class="marked"><a name="line173"></a>..173     end, [], T),
</span><span class="uncovered"><a name="line174"></a>..174     [$[, M, $]].
</span><span class="marked"><a name="line175"></a>..175 
</span><span class="marked"><a name="line176"></a>..176 %%% SCANNING
</span><span class="marked"><a name="line177"></a>..177 %%%
</span><span class="marked"><a name="line178"></a>..178 %%% Scanning funs return either:
</span><span class="marked"><a name="line179"></a>..179 %%%    {done, Result, LeftOverChars}
</span><span class="marked"><a name="line180"></a>..180 %%% if a complete token is recognized, or
</span><span class="marked"><a name="line181"></a>..181 %%%    {more, Continuation}
</span><span class="marked"><a name="line182"></a>..182 %%% if more input is needed.
</span><span class="marked"><a name="line183"></a>..183 %%% Result is {ok, Term}, 'eof', or {error, Reason}.
</span><span class="marked"><a name="line184"></a>..184 %%% Here, the Continuation is a simple Erlang string.
</span><span class="marked"><a name="line185"></a>..185 %%%
</span><span class="marked"><a name="line186"></a>..186 %%% Currently, error handling is rather crude - errors are recognized
</span><span class="marked"><a name="line187"></a>..187 %%% by match failures.  EOF is handled only by number scanning, where
</span><span class="marked"><a name="line188"></a>..188 %%% it can delimit a number, and otherwise causes a match failure.
</span><span class="marked"><a name="line189"></a>..189 %%%
</span><span class="marked"><a name="line190"></a>..190 %%% Tokens are one of the following
</span><span class="marked"><a name="line191"></a>..191 %%% JSON string -> erlang string
</span><span class="marked"><a name="line192"></a>..192 %%% JSON number -> erlang number
</span><span class="marked"><a name="line193"></a>..193 %%% true, false, null -> erlang atoms
</span><span class="marked"><a name="line194"></a>..194 %%% { } [ ] : , -> lcbrace rcbrace lsbrace rsbrace colon comma
</span><span class="marked"><a name="line195"></a>..195 
</span><span class="uncovered"><a name="line196"></a>..196 token([]) -> {more, []};
</span><span class="uncovered"><a name="line197"></a>..197 token(eof) -> {done, eof, []};
</span><span class="marked"><a name="line198"></a>..198 
</span><span class="uncovered"><a name="line199"></a>..199 token("true" ++ Rest) -> {done, {ok, true}, Rest};
</span><span class="uncovered"><a name="line200"></a>..200 token("tru")	-> {more, "tru"};
</span><span class="uncovered"><a name="line201"></a>..201 token("tr")	-> {more, "tr"};
</span><span class="uncovered"><a name="line202"></a>..202 token("t")	-> {more, "t"};
</span><span class="marked"><a name="line203"></a>..203 
</span><span class="uncovered"><a name="line204"></a>..204 token("false" ++ Rest) -> {done, {ok, false}, Rest};
</span><span class="uncovered"><a name="line205"></a>..205 token("fals")	-> {more, "fals"};
</span><span class="uncovered"><a name="line206"></a>..206 token("fal")	-> {more, "fal"};
</span><span class="uncovered"><a name="line207"></a>..207 token("fa")	-> {more, "fa"};
</span><span class="uncovered"><a name="line208"></a>..208 token("f")	-> {more, "f"};
</span><span class="marked"><a name="line209"></a>..209 
</span><span class="uncovered"><a name="line210"></a>..210 token("null" ++ Rest) -> {done, {ok, null}, Rest};
</span><span class="uncovered"><a name="line211"></a>..211 token("nul")	-> {more, "nul"};
</span><span class="uncovered"><a name="line212"></a>..212 token("nu")	-> {more, "nu"};
</span><span class="uncovered"><a name="line213"></a>..213 token("n")	-> {more, "n"};
</span><span class="marked"><a name="line214"></a>..214 
</span><span class="marked"><a name="line215"></a>..215 token([C | Cs] = Input) ->
</span><span class="uncovered"><a name="line216"></a>..216     case C of
</span><span class="uncovered"><a name="line217"></a>..217 	$\s -> token(Cs);	% eat whitespace
</span><span class="uncovered"><a name="line218"></a>..218 	$\t -> token(Cs);	% eat whitespace
</span><span class="uncovered"><a name="line219"></a>..219 	$\n -> token(Cs);	% eat whitespace
</span><span class="uncovered"><a name="line220"></a>..220 	$\r -> token(Cs);	% eat whitespace
</span><span class="uncovered"><a name="line221"></a>..221 	$" -> scan_string(Input);
</span><span class="uncovered"><a name="line222"></a>..222 	$- -> scan_number(Input);
</span><span class="uncovered"><a name="line223"></a>..223 	D when D >= $0, D =< $9-> scan_number(Input);
</span><span class="uncovered"><a name="line224"></a>..224 	${ -> {done, {ok, lcbrace}, Cs};
</span><span class="uncovered"><a name="line225"></a>..225 	$} -> {done, {ok, rcbrace}, Cs};
</span><span class="uncovered"><a name="line226"></a>..226 	$[ -> {done, {ok, lsbrace}, Cs};
</span><span class="uncovered"><a name="line227"></a>..227 	$] -> {done, {ok, rsbrace}, Cs};
</span><span class="uncovered"><a name="line228"></a>..228 	$: -> {done, {ok, colon}, Cs};
</span><span class="uncovered"><a name="line229"></a>..229 	$, -> {done, {ok, comma}, Cs};
</span><span class="uncovered"><a name="line230"></a>..230 	$/ -> case scan_comment(Cs) of
</span><span class="uncovered"><a name="line231"></a>..231 	    {more, X} -> {more, X};
</span><span class="uncovered"><a name="line232"></a>..232 	    {done, _, Chars} -> token(Chars)
</span><span class="marked"><a name="line233"></a>..233 	end;
</span><span class="uncovered"><a name="line234"></a>..234         _ -> {done, {error, {bad_char, C}}, Cs}
</span><span class="marked"><a name="line235"></a>..235     end.
</span><span class="marked"><a name="line236"></a>..236 
</span><span class="marked"><a name="line237"></a>..237 scan_string([$" | Cs] = Input) ->
</span><span class="uncovered"><a name="line238"></a>..238     scan_string(Cs, [], Input).
</span><span class="marked"><a name="line239"></a>..239 
</span><span class="marked"><a name="line240"></a>..240 %% Accumulate in reverse order, save original start-of-string for continuation.
</span><span class="marked"><a name="line241"></a>..241 
</span><span class="uncovered"><a name="line242"></a>..242 scan_string([], _, X) -> {more, X};
</span><span class="uncovered"><a name="line243"></a>..243 scan_string(eof, _, X) -> {done, {error, missing_close_quote}, X};
</span><span class="uncovered"><a name="line244"></a>..244 scan_string([$" | Rest], A, _) -> {done, {ok, lists:reverse(A)}, Rest};
</span><span class="uncovered"><a name="line245"></a>..245 scan_string([$\\], _, X) -> {more, X};
</span><span class="marked"><a name="line246"></a>..246 scan_string([$\\, $u, U1, U2, U3, U4 | Rest], A, X) ->
</span><span class="uncovered"><a name="line247"></a>..247     scan_string(Rest, [uni_char([U1, U2, U3, U4]) | A], X);
</span><span class="uncovered"><a name="line248"></a>..248 scan_string([$\\, $u | _], _, X) -> {more, X};
</span><span class="marked"><a name="line249"></a>..249 scan_string([$\\, C | Rest], A, X) ->
</span><span class="uncovered"><a name="line250"></a>..250     scan_string(Rest, [esc_to_char(C) | A], X);
</span><span class="marked"><a name="line251"></a>..251 scan_string([C | Rest], A, X) ->
</span><span class="uncovered"><a name="line252"></a>..252     scan_string(Rest, [C | A], X).
</span><span class="marked"><a name="line253"></a>..253 
</span><span class="marked"><a name="line254"></a>..254 %% Given a list of hex characters, convert to the corresponding integer.
</span><span class="marked"><a name="line255"></a>..255 
</span><span class="marked"><a name="line256"></a>..256 uni_char(HexList) ->
</span><span class="uncovered"><a name="line257"></a>..257     erlang:list_to_integer(HexList, 16).
</span><span class="marked"><a name="line258"></a>..258 
</span><span class="uncovered"><a name="line259"></a>..259 esc_to_char($") -> $";
</span><span class="uncovered"><a name="line260"></a>..260 esc_to_char($/) -> $/;
</span><span class="uncovered"><a name="line261"></a>..261 esc_to_char($\\) -> $\\;
</span><span class="uncovered"><a name="line262"></a>..262 esc_to_char($b) -> $\b;
</span><span class="uncovered"><a name="line263"></a>..263 esc_to_char($f) -> $\f;
</span><span class="uncovered"><a name="line264"></a>..264 esc_to_char($n) -> $\n;
</span><span class="uncovered"><a name="line265"></a>..265 esc_to_char($r) -> $\r;
</span><span class="uncovered"><a name="line266"></a>..266 esc_to_char($t) -> $\t.
</span><span class="marked"><a name="line267"></a>..267 
</span><span class="uncovered"><a name="line268"></a>..268 scan_number([]) -> {more, []};
</span><span class="uncovered"><a name="line269"></a>..269 scan_number(eof) -> {done, {error, incomplete_number}, []};
</span><span class="uncovered"><a name="line270"></a>..270 scan_number([$-, $- | _Ds]) -> {done, {error, invalid_number}, []};
</span><span class="marked"><a name="line271"></a>..271 scan_number([$- | Ds] = Input) ->
</span><span class="uncovered"><a name="line272"></a>..272     case scan_number(Ds) of
</span><span class="uncovered"><a name="line273"></a>..273 	{more, _Cont} -> {more, Input};
</span><span class="uncovered"><a name="line274"></a>..274 	{done, {ok, N}, CharList} -> {done, {ok, -1 * N}, CharList};
</span><span class="uncovered"><a name="line275"></a>..275         {done, Other, Chars} -> {done, Other, Chars}
</span><span class="marked"><a name="line276"></a>..276     end;
</span><span class="marked"><a name="line277"></a>..277 scan_number([D | Ds] = Input) when D >= $0, D =< $9 ->
</span><span class="uncovered"><a name="line278"></a>..278     scan_number(Ds, D - $0, Input).
</span><span class="marked"><a name="line279"></a>..279 
</span><span class="marked"><a name="line280"></a>..280 %% Numbers don't have a terminator, so stop at the first non-digit,
</span><span class="marked"><a name="line281"></a>..281 %% and ask for more if we run out.
</span><span class="marked"><a name="line282"></a>..282 
</span><span class="uncovered"><a name="line283"></a>..283 scan_number([], _A, X) -> {more, X};
</span><span class="uncovered"><a name="line284"></a>..284 scan_number(eof, A, _X) -> {done, {ok, A}, eof};
</span><span class="uncovered"><a name="line285"></a>..285 scan_number([$.], _A, X) -> {more, X};
</span><span class="marked"><a name="line286"></a>..286 scan_number([$., D | Ds], A, X) when D >= $0, D =< $9 ->
</span><span class="uncovered"><a name="line287"></a>..287     scan_fraction([D | Ds], A, X);
</span><span class="marked"><a name="line288"></a>..288 scan_number([D | Ds], A, X) when A > 0, D >= $0, D =< $9 ->
</span><span class="marked"><a name="line289"></a>..289     % Note that nonzero numbers can't start with "0".
</span><span class="uncovered"><a name="line290"></a>..290     scan_number(Ds, 10 * A + (D - $0), X);
</span><span class="marked"><a name="line291"></a>..291 scan_number([D | Ds], A, X) when D == $E; D == $e ->
</span><span class="uncovered"><a name="line292"></a>..292     scan_exponent_begin(Ds, float(A), X);
</span><span class="marked"><a name="line293"></a>..293 scan_number([D | _] = Ds, A, _X) when D < $0; D > $9 ->
</span><span class="uncovered"><a name="line294"></a>..294     {done, {ok, A}, Ds}.
</span><span class="marked"><a name="line295"></a>..295 
</span><span class="uncovered"><a name="line296"></a>..296 scan_fraction(Ds, I, X) -> scan_fraction(Ds, [], I, X).
</span><span class="marked"><a name="line297"></a>..297 
</span><span class="uncovered"><a name="line298"></a>..298 scan_fraction([], _Fs, _I, X) -> {more, X};
</span><span class="marked"><a name="line299"></a>..299 scan_fraction(eof, Fs, I, _X) ->
</span><span class="uncovered"><a name="line300"></a>..300     R = I + list_to_float("0." ++ lists:reverse(Fs)),
</span><span class="uncovered"><a name="line301"></a>..301     {done, {ok, R}, eof};
</span><span class="marked"><a name="line302"></a>..302 scan_fraction([D | Ds], Fs, I, X) when D >= $0, D =< $9 ->
</span><span class="uncovered"><a name="line303"></a>..303     scan_fraction(Ds, [D | Fs], I, X);
</span><span class="marked"><a name="line304"></a>..304 scan_fraction([D | Ds], Fs, I, X) when D == $E; D == $e ->
</span><span class="uncovered"><a name="line305"></a>..305     R = I + list_to_float("0." ++ lists:reverse(Fs)),
</span><span class="uncovered"><a name="line306"></a>..306     scan_exponent_begin(Ds, R, X);
</span><span class="marked"><a name="line307"></a>..307 scan_fraction(Rest, Fs, I, _X) ->
</span><span class="uncovered"><a name="line308"></a>..308     R = I + list_to_float("0." ++ lists:reverse(Fs)),
</span><span class="uncovered"><a name="line309"></a>..309     {done, {ok, R}, Rest}.
</span><span class="marked"><a name="line310"></a>..310 
</span><span class="marked"><a name="line311"></a>..311 scan_exponent_begin(Ds, R, X) ->
</span><span class="uncovered"><a name="line312"></a>..312     scan_exponent_begin(Ds, [], R, X).
</span><span class="marked"><a name="line313"></a>..313 
</span><span class="uncovered"><a name="line314"></a>..314 scan_exponent_begin([], _Es, _R, X) -> {more, X};
</span><span class="uncovered"><a name="line315"></a>..315 scan_exponent_begin(eof, _Es, _R, X) -> {done, {error, missing_exponent}, X};
</span><span class="marked"><a name="line316"></a>..316 scan_exponent_begin([D | Ds], Es, R, X) when D == $-;
</span><span class="marked"><a name="line317"></a>..317                                              D == $+;
</span><span class="marked"><a name="line318"></a>..318                                              D >= $0, D =< $9 ->
</span><span class="uncovered"><a name="line319"></a>..319     scan_exponent(Ds, [D | Es], R, X). 
</span><span class="marked"><a name="line320"></a>..320 
</span><span class="uncovered"><a name="line321"></a>..321 scan_exponent([], _Es, _R, X) -> {more, X};
</span><span class="marked"><a name="line322"></a>..322 scan_exponent(eof, Es, R, _X) ->
</span><span class="uncovered"><a name="line323"></a>..323     X = R * math:pow(10, list_to_integer(lists:reverse(Es))),
</span><span class="uncovered"><a name="line324"></a>..324     {done, {ok, X}, eof};
</span><span class="marked"><a name="line325"></a>..325 scan_exponent([D | Ds], Es, R, X) when D >= $0, D =< $9 ->
</span><span class="uncovered"><a name="line326"></a>..326     scan_exponent(Ds, [D | Es], R, X);
</span><span class="marked"><a name="line327"></a>..327 scan_exponent(Rest, Es, R, _X) ->
</span><span class="uncovered"><a name="line328"></a>..328     X = R * math:pow(10, list_to_integer(lists:reverse(Es))),
</span><span class="uncovered"><a name="line329"></a>..329     {done, {ok, X}, Rest}.
</span><span class="marked"><a name="line330"></a>..330 
</span><span class="uncovered"><a name="line331"></a>..331 scan_comment([]) -> {more, "/"};
</span><span class="uncovered"><a name="line332"></a>..332 scan_comment(eof) -> {done, eof, []};
</span><span class="uncovered"><a name="line333"></a>..333 scan_comment([$/ | Rest]) -> scan_cpp_comment(Rest);
</span><span class="uncovered"><a name="line334"></a>..334 scan_comment([$* | Rest]) -> scan_c_comment(Rest).
</span><span class="marked"><a name="line335"></a>..335 
</span><span class="marked"><a name="line336"></a>..336 %% Ignore up to next CR or LF.  If the line ends in CRLF,
</span><span class="marked"><a name="line337"></a>..337 %% the LF will be treated as separate whitespace, which is
</span><span class="marked"><a name="line338"></a>..338 %% okay since it will also be ignored.
</span><span class="marked"><a name="line339"></a>..339 
</span><span class="uncovered"><a name="line340"></a>..340 scan_cpp_comment([]) -> {more, "//"};
</span><span class="uncovered"><a name="line341"></a>..341 scan_cpp_comment(eof) -> {done, eof, []};
</span><span class="uncovered"><a name="line342"></a>..342 scan_cpp_comment([$\r | Rest]) -> {done, [], Rest};
</span><span class="uncovered"><a name="line343"></a>..343 scan_cpp_comment([$\n | Rest]) -> {done, [], Rest};
</span><span class="uncovered"><a name="line344"></a>..344 scan_cpp_comment([_ | Rest]) -> scan_cpp_comment(Rest).
</span><span class="marked"><a name="line345"></a>..345 
</span><span class="uncovered"><a name="line346"></a>..346 scan_c_comment([]) -> {more, "/*"};
</span><span class="uncovered"><a name="line347"></a>..347 scan_c_comment(eof) -> {done, eof, []};
</span><span class="uncovered"><a name="line348"></a>..348 scan_c_comment([$*]) -> {more, "/**"};
</span><span class="uncovered"><a name="line349"></a>..349 scan_c_comment([$*, $/ | Rest]) -> {done, [], Rest};
</span><span class="uncovered"><a name="line350"></a>..350 scan_c_comment([_ | Rest]) -> scan_c_comment(Rest).
</span><span class="marked"><a name="line351"></a>..351 
</span><span class="marked"><a name="line352"></a>..352 %%% PARSING
</span><span class="marked"><a name="line353"></a>..353 %%%
</span><span class="marked"><a name="line354"></a>..354 %%% The decode function takes a char list as input, but
</span><span class="marked"><a name="line355"></a>..355 %%% interprets the end of the list as only an end to the available
</span><span class="marked"><a name="line356"></a>..356 %%% input, and returns a "continuation" requesting more input.
</span><span class="marked"><a name="line357"></a>..357 %%% When additional characters are available, they, and the
</span><span class="marked"><a name="line358"></a>..358 %%% continuation, are fed into decode/2.  You can use the atom 'eof'
</span><span class="marked"><a name="line359"></a>..359 %%% as a character to signal a true end to the input stream, and
</span><span class="marked"><a name="line360"></a>..360 %%% possibly flush out an unfinished number.  The decode_string/1
</span><span class="marked"><a name="line361"></a>..361 %%% function appends 'eof' to its input and calls decode/1.
</span><span class="marked"><a name="line362"></a>..362 %%%
</span><span class="marked"><a name="line363"></a>..363 %%% Parsing and scanning errors are handled only by match failures.
</span><span class="marked"><a name="line364"></a>..364 %%% The external caller must take care to wrap the call in a "catch"
</span><span class="marked"><a name="line365"></a>..365 %%% or "try" if better error-handling is desired.  Eventually parse
</span><span class="marked"><a name="line366"></a>..366 %%% or scan errors will be returned explicitly with a description,
</span><span class="marked"><a name="line367"></a>..367 %%% and someday with line numbers too.
</span><span class="marked"><a name="line368"></a>..368 %%%
</span><span class="marked"><a name="line369"></a>..369 %%% The parsing code uses a continuation-passing style to allow
</span><span class="marked"><a name="line370"></a>..370 %%% for the parsing to suspend at any point and be resumed when
</span><span class="marked"><a name="line371"></a>..371 %%% more input is available.
</span><span class="marked"><a name="line372"></a>..372 %%% See http://en.wikipedia.org/wiki/Continuation_passing_style
</span><span class="marked"><a name="line373"></a>..373 
</span><span class="marked"><a name="line374"></a>..374 %% Return the first JSON value decoded from the input string.
</span><span class="marked"><a name="line375"></a>..375 %% The string must contain at least one complete JSON value.
</span><span class="marked"><a name="line376"></a>..376 
</span><span class="marked"><a name="line377"></a>..377 decode_string(CharList) ->
</span><span class="uncovered"><a name="line378"></a>..378     {done, V, _} = decode([], CharList ++ eof),
</span><span class="uncovered"><a name="line379"></a>..379     V.
</span><span class="marked"><a name="line380"></a>..380 
</span><span class="marked"><a name="line381"></a>..381 %% Attempt to decode a JSON value from the input string
</span><span class="marked"><a name="line382"></a>..382 %% and continuation, using empty list for the initial continuation.
</span><span class="marked"><a name="line383"></a>..383 %% Return {done, Result, LeftoverChars} if a value is recognized,
</span><span class="marked"><a name="line384"></a>..384 %% or {more, Continuation} if more input characters are needed.
</span><span class="marked"><a name="line385"></a>..385 %% The Result can be {ok, Value}, eof, or {error, Reason}.
</span><span class="marked"><a name="line386"></a>..386 %% The Continuation is then fed as an argument to decode/2 when
</span><span class="marked"><a name="line387"></a>..387 %% more input is available.
</span><span class="marked"><a name="line388"></a>..388 %% Use the atom 'eof' instead of a char list to signal
</span><span class="marked"><a name="line389"></a>..389 %% a true end to the input, and may flush a final number.
</span><span class="marked"><a name="line390"></a>..390 
</span><span class="marked"><a name="line391"></a>..391 decode([], CharList) ->
</span><span class="uncovered"><a name="line392"></a>..392     decode(first_continuation(), CharList);
</span><span class="marked"><a name="line393"></a>..393 
</span><span class="marked"><a name="line394"></a>..394 decode(Continuation, CharList) ->
</span><span class="uncovered"><a name="line395"></a>..395     {OldChars, Kt} = Continuation,
</span><span class="uncovered"><a name="line396"></a>..396     get_token(OldChars ++ CharList, Kt).
</span><span class="marked"><a name="line397"></a>..397 
</span><span class="marked"><a name="line398"></a>..398 first_continuation() ->
</span><span class="uncovered"><a name="line399"></a>..399     {[], fun
</span><span class="marked"><a name="line400"></a>..400         (eof, Cs) ->
</span><span class="uncovered"><a name="line401"></a>..401                 {done, eof, Cs};
</span><span class="marked"><a name="line402"></a>..402         (T, Cs) ->
</span><span class="uncovered"><a name="line403"></a>..403             parse_value(T, Cs, fun(V, C2) ->
</span><span class="uncovered"><a name="line404"></a>..404                 {done, {ok, V}, C2}
</span><span class="marked"><a name="line405"></a>..405 	    end)
</span><span class="marked"><a name="line406"></a>..406     end}.
</span><span class="marked"><a name="line407"></a>..407 
</span><span class="marked"><a name="line408"></a>..408 %% Continuation Kt must accept (TokenOrEof, Chars)
</span><span class="marked"><a name="line409"></a>..409 
</span><span class="marked"><a name="line410"></a>..410 get_token(Chars, Kt) ->
</span><span class="uncovered"><a name="line411"></a>..411     case token(Chars) of
</span><span class="uncovered"><a name="line412"></a>..412 	{done, {ok, T}, Rest} -> Kt(T, Rest);
</span><span class="uncovered"><a name="line413"></a>..413 	{done, eof, Rest} -> Kt(eof, Rest);
</span><span class="uncovered"><a name="line414"></a>..414 	{done, {error, Reason}, Rest} -> {done, {error, Reason}, Rest};
</span><span class="uncovered"><a name="line415"></a>..415         {more, X} -> {more, {X, Kt}}
</span><span class="marked"><a name="line416"></a>..416     end.
</span><span class="marked"><a name="line417"></a>..417 
</span><span class="marked"><a name="line418"></a>..418 %% Continuation Kv must accept (Value, Chars)
</span><span class="marked"><a name="line419"></a>..419 
</span><span class="uncovered"><a name="line420"></a>..420 parse_value(eof, C, _Kv) -> {done, {error, premature_eof}, C};
</span><span class="uncovered"><a name="line421"></a>..421 parse_value(true, C, Kv) -> Kv(true, C);
</span><span class="uncovered"><a name="line422"></a>..422 parse_value(false, C, Kv) -> Kv(false, C);
</span><span class="uncovered"><a name="line423"></a>..423 parse_value(null, C, Kv) -> Kv(null, C);
</span><span class="uncovered"><a name="line424"></a>..424 parse_value(S, C, Kv) when is_list(S) -> Kv(S, C);
</span><span class="uncovered"><a name="line425"></a>..425 parse_value(N, C, Kv) when is_number(N) -> Kv(N, C);
</span><span class="uncovered"><a name="line426"></a>..426 parse_value(lcbrace, C, Kv) -> parse_object(C, Kv);
</span><span class="uncovered"><a name="line427"></a>..427 parse_value(lsbrace, C, Kv) -> parse_array(C, Kv);
</span><span class="uncovered"><a name="line428"></a>..428 parse_value(_, C, _Kv) -> {done, {error, syntax_error}, C}.
</span><span class="marked"><a name="line429"></a>..429 
</span><span class="marked"><a name="line430"></a>..430 %% Continuation Kv must accept (Value, Chars)
</span><span class="marked"><a name="line431"></a>..431 
</span><span class="marked"><a name="line432"></a>..432 parse_object(Chars, Kv) ->
</span><span class="uncovered"><a name="line433"></a>..433     get_token(Chars, fun(T, C2) ->
</span><span class="uncovered"><a name="line434"></a>..434 	Obj = obj_new(),
</span><span class="uncovered"><a name="line435"></a>..435 	case T of
</span><span class="uncovered"><a name="line436"></a>..436 	    rcbrace -> Kv(Obj, C2);		% empty object
</span><span class="uncovered"><a name="line437"></a>..437 	    _ -> parse_object(Obj, T, C2, Kv)	% token must be string
</span><span class="marked"><a name="line438"></a>..438 	end
</span><span class="marked"><a name="line439"></a>..439     end).
</span><span class="marked"><a name="line440"></a>..440 
</span><span class="marked"><a name="line441"></a>..441 parse_object(_Obj, eof, C, _Kv) ->
</span><span class="uncovered"><a name="line442"></a>..442     {done, {error, premature_eof}, C};
</span><span class="marked"><a name="line443"></a>..443 
</span><span class="marked"><a name="line444"></a>..444 parse_object(Obj, S, C, Kv) when is_list(S) ->    % S is member name
</span><span class="uncovered"><a name="line445"></a>..445     get_token(C, fun
</span><span class="marked"><a name="line446"></a>..446         (colon, C2) ->
</span><span class="uncovered"><a name="line447"></a>..447             parse_object2(Obj, S, C2, Kv);
</span><span class="marked"><a name="line448"></a>..448         (T, C2) ->
</span><span class="uncovered"><a name="line449"></a>..449             {done, {error, {expecting_colon, T}}, C2}
</span><span class="marked"><a name="line450"></a>..450     end);
</span><span class="marked"><a name="line451"></a>..451 
</span><span class="marked"><a name="line452"></a>..452 parse_object(_Obj, M, C, _Kv) ->
</span><span class="uncovered"><a name="line453"></a>..453     {done, {error, {member_name_not_string, M}}, C}.
</span><span class="marked"><a name="line454"></a>..454 
</span><span class="marked"><a name="line455"></a>..455 parse_object2(Obj, S, C, Kv) ->
</span><span class="uncovered"><a name="line456"></a>..456     get_token(C, fun
</span><span class="marked"><a name="line457"></a>..457         (eof, C2) ->
</span><span class="uncovered"><a name="line458"></a>..458             {done, {error, premature_eof}, C2};
</span><span class="marked"><a name="line459"></a>..459         (T, C2) ->
</span><span class="uncovered"><a name="line460"></a>..460             parse_value(T, C2, fun(V, C3) ->	% V is member value
</span><span class="uncovered"><a name="line461"></a>..461                 Obj2 = obj_store(S, V, Obj),
</span><span class="uncovered"><a name="line462"></a>..462                 get_token(C3, fun
</span><span class="marked"><a name="line463"></a>..463                     (rcbrace, C4) ->    % "}" end of object
</span><span class="uncovered"><a name="line464"></a>..464 						{struct, PropList1} = Obj2,
</span><span class="uncovered"><a name="line465"></a>..465                         Kv({struct, lists:reverse(PropList1)}, C4);
</span><span class="marked"><a name="line466"></a>..466                     (comma, C4) ->		% "," another member follows
</span><span class="uncovered"><a name="line467"></a>..467                         get_token(C4, fun(T3, C5) ->
</span><span class="uncovered"><a name="line468"></a>..468                             parse_object(Obj2, T3, C5, Kv)
</span><span class="marked"><a name="line469"></a>..469                         end);
</span><span class="marked"><a name="line470"></a>..470                     (eof, C4) ->
</span><span class="uncovered"><a name="line471"></a>..471                         {done, {error, premature_eof}, C4};
</span><span class="marked"><a name="line472"></a>..472                     (T2, C4) ->
</span><span class="uncovered"><a name="line473"></a>..473                         {done, {error, {expecting_comma_or_curly, T2}}, C4}
</span><span class="marked"><a name="line474"></a>..474                 end)
</span><span class="marked"><a name="line475"></a>..475             end)
</span><span class="marked"><a name="line476"></a>..476     end).
</span><span class="marked"><a name="line477"></a>..477 
</span><span class="marked"><a name="line478"></a>..478 %% Continuation Kv must accept (Value, Chars)
</span><span class="marked"><a name="line479"></a>..479 
</span><span class="marked"><a name="line480"></a>..480 parse_array(C, Kv) ->
</span><span class="uncovered"><a name="line481"></a>..481     get_token(C, fun
</span><span class="uncovered"><a name="line482"></a>..482         (eof, C2) -> {done, {error, premature_eof}, C2};
</span><span class="uncovered"><a name="line483"></a>..483 	(rsbrace, C2) -> Kv({array, []}, C2);  % empty array	     
</span><span class="uncovered"><a name="line484"></a>..484         (T, C2) -> parse_array([], T, C2, Kv)
</span><span class="marked"><a name="line485"></a>..485     end).
</span><span class="marked"><a name="line486"></a>..486 
</span><span class="marked"><a name="line487"></a>..487 parse_array(E, T, C, Kv) ->
</span><span class="uncovered"><a name="line488"></a>..488     parse_value(T, C, fun(V, C2) ->
</span><span class="uncovered"><a name="line489"></a>..489 	E2 = [V | E],
</span><span class="uncovered"><a name="line490"></a>..490 	get_token(C2, fun
</span><span class="marked"><a name="line491"></a>..491             (rsbrace, C3) ->        % "]" end of array
</span><span class="uncovered"><a name="line492"></a>..492 	        Kv({array, lists:reverse(E2)}, C3);
</span><span class="marked"><a name="line493"></a>..493 
</span><span class="marked"><a name="line494"></a>..494             (comma, C3) ->          % "," another value follows
</span><span class="uncovered"><a name="line495"></a>..495                 get_token(C3, fun(T3, C4) ->
</span><span class="uncovered"><a name="line496"></a>..496                     parse_array(E2, T3, C4, Kv)
</span><span class="marked"><a name="line497"></a>..497                 end);
</span><span class="marked"><a name="line498"></a>..498             (eof, C3) ->
</span><span class="uncovered"><a name="line499"></a>..499                 {done, {error, premature_eof}, C3};
</span><span class="marked"><a name="line500"></a>..500             (T2, C3) ->
</span><span class="uncovered"><a name="line501"></a>..501                 {done, {error, {expecting_comma_or_close_array, T2}}, C3}
</span><span class="marked"><a name="line502"></a>..502         end)
</span><span class="marked"><a name="line503"></a>..503     end).
</span><span class="marked"><a name="line504"></a>..504 
</span><span class="marked"><a name="line505"></a>..505 %%% OBJECTS
</span><span class="marked"><a name="line506"></a>..506 %%%
</span><span class="marked"><a name="line507"></a>..507 %%% We'll use tagged property lists as the internal representation
</span><span class="marked"><a name="line508"></a>..508 %%% of JSON objects.  Unordered lists perform worse than trees for
</span><span class="marked"><a name="line509"></a>..509 %%% lookup and modification of members, but we expect objects to be
</span><span class="marked"><a name="line510"></a>..510 %%% have only a few members.  Lists also print better.
</span><span class="marked"><a name="line511"></a>..511 
</span><span class="marked"><a name="line512"></a>..512 %% Is this a proper JSON object representation?
</span><span class="marked"><a name="line513"></a>..513 
</span><span class="marked"><a name="line514"></a>..514 is_obj({struct, Props}) when is_list(Props) ->
</span><span class="uncovered"><a name="line515"></a>..515     lists:all(fun
</span><span class="uncovered"><a name="line516"></a>..516         ({Member, _Value}) when is_atom(Member); is_list(Member) -> true;
</span><span class="uncovered"><a name="line517"></a>..517         (_) -> false
</span><span class="marked"><a name="line518"></a>..518     end, Props);
</span><span class="marked"><a name="line519"></a>..519 
</span><span class="marked"><a name="line520"></a>..520 is_obj(_) ->
</span><span class="uncovered"><a name="line521"></a>..521     false.
</span><span class="marked"><a name="line522"></a>..522 
</span><span class="marked"><a name="line523"></a>..523 %% Create a new, empty object.
</span><span class="marked"><a name="line524"></a>..524 
</span><span class="marked"><a name="line525"></a>..525 obj_new() ->
</span><span class="uncovered"><a name="line526"></a>..526     {struct, []}.
</span><span class="marked"><a name="line527"></a>..527 
</span><span class="marked"><a name="line528"></a>..528 %% Fetch an object member's value, expecting it to be in the object.
</span><span class="marked"><a name="line529"></a>..529 %% Return value, runtime error if no member found with that name.
</span><span class="marked"><a name="line530"></a>..530 
</span><span class="marked"><a name="line531"></a>..531 obj_fetch(Key, {struct, Props}) when is_list(Props) ->
</span><span class="uncovered"><a name="line532"></a>..532     case proplists:get_value(Key, Props) of
</span><span class="marked"><a name="line533"></a>..533         undefined ->
</span><span class="uncovered"><a name="line534"></a>..534             exit({struct_no_key, Key});
</span><span class="marked"><a name="line535"></a>..535         Value ->
</span><span class="uncovered"><a name="line536"></a>..536             Value
</span><span class="marked"><a name="line537"></a>..537     end.
</span><span class="marked"><a name="line538"></a>..538     
</span><span class="marked"><a name="line539"></a>..539 %% Fetch an object member's value, or indicate that there is no such member.
</span><span class="marked"><a name="line540"></a>..540 %% Return {ok, Value} or 'error'.
</span><span class="marked"><a name="line541"></a>..541 
</span><span class="marked"><a name="line542"></a>..542 obj_find(Key, {struct, Props}) when is_list(Props) ->
</span><span class="uncovered"><a name="line543"></a>..543     case proplists:get_value(Key, Props) of
</span><span class="marked"><a name="line544"></a>..544         undefined ->
</span><span class="uncovered"><a name="line545"></a>..545             error;
</span><span class="marked"><a name="line546"></a>..546         Value ->
</span><span class="uncovered"><a name="line547"></a>..547             {ok, Value}
</span><span class="marked"><a name="line548"></a>..548     end.
</span><span class="marked"><a name="line549"></a>..549 
</span><span class="marked"><a name="line550"></a>..550 obj_is_key(Key, {struct, Props}) ->
</span><span class="uncovered"><a name="line551"></a>..551     proplists:is_defined(Key, Props).
</span><span class="marked"><a name="line552"></a>..552 
</span><span class="marked"><a name="line553"></a>..553 %% Store a new member in an object.  Returns a new object.
</span><span class="marked"><a name="line554"></a>..554 
</span><span class="marked"><a name="line555"></a>..555 obj_store(KeyList, Value, {struct, Props}) when is_list(Props) ->
</span><span class="uncovered"><a name="line556"></a>..556 	Key = list_to_atom(KeyList),
</span><span class="uncovered"><a name="line557"></a>..557     {struct, [{Key, Value} | proplists:delete(Key, Props)]}.
</span><span class="marked"><a name="line558"></a>..558 
</span><span class="marked"><a name="line559"></a>..559 %% Create an object from a list of Key/Value pairs.
</span><span class="marked"><a name="line560"></a>..560 
</span><span class="marked"><a name="line561"></a>..561 obj_from_list(Props) ->
</span><span class="uncovered"><a name="line562"></a>..562     Obj = {struct, Props},
</span><span class="uncovered"><a name="line563"></a>..563     case is_obj(Obj) of
</span><span class="uncovered"><a name="line564"></a>..564         true -> Obj;
</span><span class="uncovered"><a name="line565"></a>..565         false -> exit(json_bad_object)
</span><span class="marked"><a name="line566"></a>..566     end.
</span><span class="marked"><a name="line567"></a>..567 
</span><span class="marked"><a name="line568"></a>..568 %% Fold Fun across object, with initial accumulator Acc.
</span><span class="marked"><a name="line569"></a>..569 %% Fun should take (Value, Acc) as arguments and return Acc.
</span><span class="marked"><a name="line570"></a>..570 
</span><span class="marked"><a name="line571"></a>..571 obj_fold(Fun, Acc, {struct, Props}) ->
</span><span class="uncovered"><a name="line572"></a>..572     lists:foldl(Fun, Acc, Props).
</span><span class="marked"><a name="line573"></a>..573 
</span><span class="uncovered"><a name="line574"></a>..574 is_string([]) -> yes;
</span><span class="uncovered"><a name="line575"></a>..575 is_string(List) -> is_string(List, non_unicode).
</span><span class="marked"><a name="line576"></a>..576 
</span><span class="uncovered"><a name="line577"></a>..577 is_string([C|Rest], non_unicode) when C >= 0, C =< 255 -> is_string(Rest, non_unicode);
</span><span class="uncovered"><a name="line578"></a>..578 is_string([C|Rest], _) when C =< 65000 -> is_string(Rest, unicode);
</span><span class="uncovered"><a name="line579"></a>..579 is_string([], non_unicode) -> yes;
</span><span class="uncovered"><a name="line580"></a>..580 is_string([], unicode) -> unicode;
</span><span class="uncovered"><a name="line581"></a>..581 is_string(_, _) -> no.
</span><span class="marked"><a name="line582"></a>..582 
</span><span class="marked"><a name="line583"></a>..583 
</span><span class="marked"><a name="line584"></a>..584 %%% TESTING
</span><span class="marked"><a name="line585"></a>..585 %%%
</span><span class="marked"><a name="line586"></a>..586 %%% We can't expect to round-trip from JSON -> Erlang -> JSON,
</span><span class="marked"><a name="line587"></a>..587 %%% due to the degrees of freedom in the JSON syntax: whitespace,
</span><span class="marked"><a name="line588"></a>..588 %%% and ordering of object members.  We can, however, expect to
</span><span class="marked"><a name="line589"></a>..589 %%% round-trip from Erlang -> JSON -> Erlang, so the JSON parsing
</span><span class="marked"><a name="line590"></a>..590 %%% tests will in fact test the Erlang equivalence of the
</span><span class="marked"><a name="line591"></a>..591 %%% JSON -> Erlang -> JSON -> Erlang coding chain.
</span><span class="marked"><a name="line592"></a>..592 
</span><span class="marked"><a name="line593"></a>..593 %% Test driver.  Return 'ok' or {failed, Failures}.
</span><span class="marked"><a name="line594"></a>..594 
</span><span class="marked"><a name="line595"></a>..595 test() ->
</span><span class="uncovered"><a name="line596"></a>..596     E2Js = e2j_test_vec(),
</span><span class="uncovered"><a name="line597"></a>..597     Failures = lists:foldl(fun({E, J}, Fs) ->
</span><span class="uncovered"><a name="line598"></a>..598 	case (catch test_e2j(E, J)) of
</span><span class="marked"><a name="line599"></a>..599 	    ok ->
</span><span class="uncovered"><a name="line600"></a>..600                 case (catch round_trip(E)) of
</span><span class="marked"><a name="line601"></a>..601                     ok ->
</span><span class="uncovered"><a name="line602"></a>..602                         case (catch round_trip_one_char(E)) of
</span><span class="uncovered"><a name="line603"></a>..603                             ok -> Fs;
</span><span class="uncovered"><a name="line604"></a>..604                             Reason -> [{round_trip_one_char, E, Reason} | Fs]
</span><span class="marked"><a name="line605"></a>..605                         end;
</span><span class="marked"><a name="line606"></a>..606                     Reason ->
</span><span class="uncovered"><a name="line607"></a>..607                         [{round_trip, E, Reason} | Fs]
</span><span class="marked"><a name="line608"></a>..608                 end;
</span><span class="marked"><a name="line609"></a>..609 	    Reason ->
</span><span class="uncovered"><a name="line610"></a>..610                 [{erlang_to_json, E, J, Reason} | Fs]
</span><span class="marked"><a name="line611"></a>..611 	end;
</span><span class="uncovered"><a name="line612"></a>..612     (end_of_tests, Fs) -> Fs end, [], E2Js),
</span><span class="uncovered"><a name="line613"></a>..613     case Failures of
</span><span class="uncovered"><a name="line614"></a>..614 	[] -> ok;
</span><span class="uncovered"><a name="line615"></a>..615 	_ -> {failed, Failures}
</span><span class="marked"><a name="line616"></a>..616     end.
</span><span class="marked"><a name="line617"></a>..617 
</span><span class="marked"><a name="line618"></a>..618 %% Test for conversion from Erlang to JSON.  Note that unequal strings
</span><span class="marked"><a name="line619"></a>..619 %% may represent equal JSON data, due to discretionary whitespace,
</span><span class="marked"><a name="line620"></a>..620 %% object member order, trailing zeroes in floating point, etc.
</span><span class="marked"><a name="line621"></a>..621 %% Legitimate changes to the encoding routines may require tweaks to
</span><span class="marked"><a name="line622"></a>..622 %% the reference JSON strings in e2j_test_vec().
</span><span class="marked"><a name="line623"></a>..623 
</span><span class="marked"><a name="line624"></a>..624 test_e2j(E, J) ->
</span><span class="uncovered"><a name="line625"></a>..625     J2 = lists:flatten(encode(E)),
</span><span class="uncovered"><a name="line626"></a>..626     J = J2,					% raises error if unequal
</span><span class="uncovered"><a name="line627"></a>..627     ok.
</span><span class="marked"><a name="line628"></a>..628 
</span><span class="marked"><a name="line629"></a>..629 %% Test that Erlang -> JSON -> Erlang round-trip yields equivalent term.
</span><span class="marked"><a name="line630"></a>..630 
</span><span class="marked"><a name="line631"></a>..631 round_trip(E) ->
</span><span class="uncovered"><a name="line632"></a>..632     J2 = lists:flatten(encode(E)),
</span><span class="uncovered"><a name="line633"></a>..633     {ok, E2} = decode_string(J2),
</span><span class="uncovered"><a name="line634"></a>..634     true = equiv(E, E2),			% raises error if false
</span><span class="uncovered"><a name="line635"></a>..635     ok.
</span><span class="marked"><a name="line636"></a>..636 
</span><span class="marked"><a name="line637"></a>..637 %% Round-trip with one character at a time to test all continuations.
</span><span class="marked"><a name="line638"></a>..638 
</span><span class="marked"><a name="line639"></a>..639 round_trip_one_char(E) ->
</span><span class="uncovered"><a name="line640"></a>..640     J = lists:flatten(encode(E)),
</span><span class="uncovered"><a name="line641"></a>..641     {done, {ok, E2}, _} = lists:foldl(fun(C, Ret) ->
</span><span class="uncovered"><a name="line642"></a>..642         case Ret of
</span><span class="uncovered"><a name="line643"></a>..643             {done, _, _} -> Ret;
</span><span class="uncovered"><a name="line644"></a>..644             {more, Cont} -> decode(Cont, [C])
</span><span class="marked"><a name="line645"></a>..645         end
</span><span class="marked"><a name="line646"></a>..646     end, {more, first_continuation()}, J ++ [eof]),
</span><span class="uncovered"><a name="line647"></a>..647     true = equiv(E, E2),			% raises error if false
</span><span class="uncovered"><a name="line648"></a>..648     ok.
</span><span class="marked"><a name="line649"></a>..649 
</span><span class="marked"><a name="line650"></a>..650 %% Test for equivalence of Erlang terms.
</span><span class="marked"><a name="line651"></a>..651 %% Due to arbitrary order of construction, equivalent objects might
</span><span class="marked"><a name="line652"></a>..652 %% compare unequal as erlang terms, so we need to carefully recurse
</span><span class="marked"><a name="line653"></a>..653 %% through aggregates (tuples and objects).
</span><span class="marked"><a name="line654"></a>..654 
</span><span class="marked"><a name="line655"></a>..655 equiv({struct, Props1}, {struct, Props2}) ->
</span><span class="uncovered"><a name="line656"></a>..656     equiv_object(Props1, Props2);
</span><span class="marked"><a name="line657"></a>..657 equiv(T1, T2) when is_tuple(T1), is_tuple(T2) ->
</span><span class="uncovered"><a name="line658"></a>..658     equiv_tuple(T1, T2);
</span><span class="uncovered"><a name="line659"></a>..659 equiv(N1, N2) when is_number(N1), is_number(N2)	-> N1 == N2;
</span><span class="uncovered"><a name="line660"></a>..660 equiv(S1, S2) when is_list(S1), is_list(S2)	-> S1 == S2;
</span><span class="uncovered"><a name="line661"></a>..661 equiv(true, true) -> true;
</span><span class="uncovered"><a name="line662"></a>..662 equiv(false, false) -> true;
</span><span class="uncovered"><a name="line663"></a>..663 equiv(null, null) -> true.
</span><span class="marked"><a name="line664"></a>..664 
</span><span class="marked"><a name="line665"></a>..665 %% Object representation and traversal order is unknown.
</span><span class="marked"><a name="line666"></a>..666 %% Use the sledgehammer and sort property lists.
</span><span class="marked"><a name="line667"></a>..667 
</span><span class="marked"><a name="line668"></a>..668 equiv_object(Props1, Props2) ->
</span><span class="uncovered"><a name="line669"></a>..669     L1 = lists:keysort(1, Props1),
</span><span class="uncovered"><a name="line670"></a>..670     L2 = lists:keysort(1, Props2),
</span><span class="uncovered"><a name="line671"></a>..671     Pairs = lists:zip(L1, L2),
</span><span class="uncovered"><a name="line672"></a>..672     true = lists:all(fun({{K1, V1}, {K2, V2}}) ->
</span><span class="uncovered"><a name="line673"></a>..673 	equiv(K1, K2) and equiv(V1, V2)
</span><span class="marked"><a name="line674"></a>..674     end, Pairs).
</span><span class="marked"><a name="line675"></a>..675 
</span><span class="marked"><a name="line676"></a>..676 %% Recursively compare tuple elements for equivalence.
</span><span class="marked"><a name="line677"></a>..677 
</span><span class="marked"><a name="line678"></a>..678 equiv_tuple({}, {}) ->
</span><span class="uncovered"><a name="line679"></a>..679     true;
</span><span class="marked"><a name="line680"></a>..680 equiv_tuple(T1, T2) when size(T1) == size(T2) ->
</span><span class="uncovered"><a name="line681"></a>..681     S = size(T1),
</span><span class="uncovered"><a name="line682"></a>..682     lists:all(fun(I) ->
</span><span class="uncovered"><a name="line683"></a>..683 	equiv(element(I, T1), element(I, T2))
</span><span class="marked"><a name="line684"></a>..684     end, lists:seq(1, S)).
</span><span class="marked"><a name="line685"></a>..685 
</span><span class="uncovered"><a name="line686"></a>..686 e2j_test_vec() -> [
</span><span class="marked"><a name="line687"></a>..687     {1, "1"},
</span><span class="marked"><a name="line688"></a>..688     {3.1416, "3.14160"}, % text representation may truncate, trail zeroes
</span><span class="marked"><a name="line689"></a>..689     {-1, "-1"},
</span><span class="marked"><a name="line690"></a>..690     {-3.1416, "-3.14160"},
</span><span class="marked"><a name="line691"></a>..691     {12.0e10, "1.20000e+11"},
</span><span class="marked"><a name="line692"></a>..692     {1.234E+10, "1.23400e+10"},
</span><span class="marked"><a name="line693"></a>..693     {-1.234E-10, "-1.23400e-10"},
</span><span class="marked"><a name="line694"></a>..694     {"foo", "\"foo\""},
</span><span class="marked"><a name="line695"></a>..695     {"foo" ++ [500] ++ "bar", [$", $f, $o, $o, 500, $b, $a, $r, $"]},
</span><span class="marked"><a name="line696"></a>..696     {"foo" ++ [5] ++ "bar", "\"foo\\u0005bar\""},
</span><span class="marked"><a name="line697"></a>..697     {"", "\"\""},
</span><span class="marked"><a name="line698"></a>..698     {[], "\"\""},
</span><span class="marked"><a name="line699"></a>..699     {"\n\n\n", "\"\\n\\n\\n\""},
</span><span class="marked"><a name="line700"></a>..700     {obj_new(), "{}"},
</span><span class="marked"><a name="line701"></a>..701     {obj_from_list([{"foo", "bar"}]), "{\"foo\":\"bar\"}"},
</span><span class="marked"><a name="line702"></a>..702     {obj_from_list([{"foo", "bar"}, {"baz", 123}]),
</span><span class="marked"><a name="line703"></a>..703      "{\"foo\":\"bar\",\"baz\":123}"},
</span><span class="marked"><a name="line704"></a>..704     {{}, "[]"},
</span><span class="marked"><a name="line705"></a>..705     {{{}}, "[[]]"},
</span><span class="marked"><a name="line706"></a>..706     {{1, "foo"}, "[1,\"foo\"]"},
</span><span class="marked"><a name="line707"></a>..707 
</span><span class="marked"><a name="line708"></a>..708     % json array in a json object
</span><span class="marked"><a name="line709"></a>..709     {obj_from_list([{"foo", {123}}]),
</span><span class="marked"><a name="line710"></a>..710      "{\"foo\":[123]}"},
</span><span class="marked"><a name="line711"></a>..711 
</span><span class="marked"><a name="line712"></a>..712     % json object in a json object
</span><span class="marked"><a name="line713"></a>..713     {obj_from_list([{"foo", obj_from_list([{"bar", true}])}]),
</span><span class="marked"><a name="line714"></a>..714      "{\"foo\":{\"bar\":true}}"},
</span><span class="marked"><a name="line715"></a>..715 
</span><span class="marked"><a name="line716"></a>..716     % fold evaluation order
</span><span class="marked"><a name="line717"></a>..717     {obj_from_list([{"foo", {}},
</span><span class="marked"><a name="line718"></a>..718                      {"bar", obj_from_list([{"baz", true}])},
</span><span class="marked"><a name="line719"></a>..719                      {"alice", "bob"}]),
</span><span class="marked"><a name="line720"></a>..720      "{\"foo\":[],\"bar\":{\"baz\":true},\"alice\":\"bob\"}"},
</span><span class="marked"><a name="line721"></a>..721 
</span><span class="marked"><a name="line722"></a>..722     % json object in a json array
</span><span class="marked"><a name="line723"></a>..723     {{-123, "foo", obj_from_list([{"bar", {}}]), null},
</span><span class="marked"><a name="line724"></a>..724      "[-123,\"foo\",{\"bar\":[]},null]"},
</span><span class="marked"><a name="line725"></a>..725 
</span><span class="marked"><a name="line726"></a>..726     end_of_tests
</span><span class="marked"><a name="line727"></a>..727 ].
</span><span class="marked"><a name="line728"></a>..728 
</span><span class="marked"><a name="line729"></a>..729 %%% TODO:
</span><span class="marked"><a name="line730"></a>..730 %%%
</span><span class="marked"><a name="line731"></a>..731 %%% Measure the overhead of the CPS-based parser by writing a conventional
</span><span class="marked"><a name="line732"></a>..732 %%% scanner-parser that expects all input to be available.
</span><span class="marked"><a name="line733"></a>..733 %%%
</span><span class="marked"><a name="line734"></a>..734 %%% JSON has dropped comments - disable their parsing.
</span><span class="marked"><a name="line735"></a>..735 %%%
</span><span class="marked"><a name="line736"></a>..736 %%% Allow a compile-time option to decode object member names as atoms,
</span><span class="marked"><a name="line737"></a>..737 %%% to reduce the internal representation overheads when communicating
</span><span class="marked"><a name="line738"></a>..738 %%% with trusted peers.
</span></pre><hr /><p>Generated using <a href='http://github.com/ngerakines/etap'>etap 0.3.3</a>.</p>
          </body>
        </html>
    